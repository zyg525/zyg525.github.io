---
title: Java面试题——IO&多线程
tags: Java面试题
---

## 一、IO

* ### 简述IO的继承结构

　　![IO继承结构图](/assets/img/java/IO继承结构图.png)

* ### 简述Java对象的序列化和反序列化

　　**定义**：序列化指的是把一个Java对象变成二进制内容，从而可以将对象保存到文件中，或者通过网络传输到远程。反序列化指的是把一个二进制内容变回Java对象。

　　**实现**：可以通过`ObjectOutputStream`把一个Java对象转换为字节流写入文件，通过`ObjectInputStream`从一个二进制内容中读取Java对象。

　　**Serializable**：只有实现了`Serializable`接口的对象才能被序列化。

　　**transient**：只能修饰局部变量，被修饰的变量不会被序列化。

## 二、多线程

* ### 简述进程与线程的区别与联系

　　**联系**：都是用来实现并发任务的，进程实现了操作系统任务的并发，线程实现了进程任务的并发。

　　**区别**：

　　　　1、进程拥有独立的内存空间，各个进程互不干扰，而同一个进程中的线程共享该进程的内存空间；

　　　　2、进程是操作系统进行资源分配的基本单位，线程是操作系统进行调度的基本单位，即CPU分配时间的单位。

* ### 简述Java内存模型(JMM)

　　1、所有变量都存储在主内存，每个线程都有自己的工作内存；

　　2、工作内存中保存了被该线程使用的变量的主存副本，线程对变量的所有操作都在工作内存中进行，不能直接操作主内存；

　　3、操作完成后，线程的工作内存通过缓存一致性协议将变量刷回主内存，但是刷新操作并不一定立刻发生。

* ### 简述原子性操作

　　原子性操作指的是一个操作或多个操作，要么全部执行成功，要不全都不执行。

* ### 简述volatile关键字的作用

　　volatile用来修饰变量，它的作用是：

　　1、保证共享变量对所有线程的**可见性**。如果没有volatile关键字，由于Java内存模型的存在，一个线程读取到的变量值不一定是主内存中的最新值，一个线程修改了的变量不一定会马上刷新回主内存。加了volatile之后，该变量一旦被修改就会立刻刷新回主内存，读取该变量时会去主内存中读取最新值。

　　2、**禁止指令重排**。CPU为了提高程序执行效率，允许多条指令不按照规定的顺序执行，只会保证最终结果的正确，这在单线程中是安全的，但是在多线程中是不安全的。volatile可以禁止对该变量进行指令重排，典型的应用就是双重检验锁实现单例模式时，共享变量要用volatile修饰。

* ### 线程的创建方式有哪些？

　　1、**继承Thread类**，重写run方法；

　　2、**实现Runnable接口**，重写run方法，然后传入Thread的构造方法；

　　3、**实现Callable接口**，重写call方法，然后传入FutureTask的构造方法，再将新对象传入Thread的构造方法。和前两种方法不同的是，这种方式可以获取call方法的返回值。

　　Runnable和Callable都是函数式接口，可以用lambda表达式简化。

* ### 简述线程的6种状态以及转换过程

　　线程的6种状态分别是：**NEW(新建)、RUNNABLE(可运行)、BLOCKED(阻塞)、WAITING(等待)、TIMED_WAITING(超时等待)、TERMIATED(终止)**。

　　这6种状态的转换过程如下图所示：

![线程的6种状态](/assets/img/java/线程的6种状态.png)

　　各个状态之间的转换过程是：

　　1、新创建的线程处于NEW状态，当调用`start()`方法启动线程后就进入了RUNNABLE状态，更具体地说是进入了RUNNABLE状态中的**Ready(就绪)**状态，等待CPU为线程分配时间分片。

　　2、线程获取到CPU时间分片后进入RUNNABLE状态中的**Running(运行)**状态。

　　3、RUNNING状态下的线程无法获取到锁，就会进入BLOCKED状态，阻塞状态下的线程会失去时间分片。

　　4、BLOCKED状态下的线程获取到了锁，就会进入Ready状态。

　　5、RUNNING状态下的线程在执行过程中，被其它线程对象调用了`join()`方法，或者锁对象调用了`wait()`方法，都会进入WAITING状态，等待状态下的线程会失去时间分片。

　　6、WAITING状态下的线程在等待过程中，被其它线程唤醒，就会进入Ready状态。对于`join()`方法唤醒的方式就是调用线程结束，对于`wait()`方法唤醒的方式就是锁对象调用`notify()`或`notifyAll()`方法。

　　7、RUNNING状态下的线程在执行过程中，被其它线程对象调用了`join(long)`方法，或者调用了`sleep(long)`方法，或者对锁对象调用了`wait(long)`方法，都会进入TIMED_WAITING状态，它和WAITING状态的区别是在指定时间后会自动唤醒。

　　8、TIMED_WAITING状态下的线程在等待时间过后会自动唤醒，进入Ready状态，如果还在等待时间以内，并且锁对象调用了`notify()`或`notifyAll()`方法，也会被唤醒，进入Ready状态。

　　9、线程执行完成后就会进入TERMIATED。

> 　　BLOCKED和TIMED_WAITING的区别是，BLOCKED状态下的线程没有时间分片也没有锁，TIMED_WAITING状态下的线程没有时间分片，但是不一定没有锁，当调用`sleep()`方法使线程等待时，线程不会释放锁，只有当调用`wait()`方法使线程等待时，线程才会释放锁。

* ### sleep()和wait()的区别是什么？

　　1、`sleep()`必须指定时间，`wait()`可以不指定时间；

　　2、`sleep()`不会释放锁，`wait()`会释放锁；

　　3、`sleep()`可以放在任何位置，`wait()`只能放在同步代码中。

* ### 什么是可重入锁？

　　可以被同一个线程重复获取的锁叫做可重入锁，比如synchronized。

* ### 什么是死锁？

　　两个线程各自持有不同的锁，然后试图获取对方手里的锁，造成了无限等待，这就是死锁。

* ### 什么是公平锁和非公平锁？

　　公平锁指的是多个线程在等待同一个锁时，必须按照申请锁的顺序来依次获得锁，非公平锁不能保证这一点。

　　synchronized锁是不公平锁，ReentrantLock锁默认也是不公平锁，但可以设置为公平锁。非公平锁可以提高效率，但是有可能导致一些线程长时间得不到锁。

* ### 什么是CAS算法？

　　**CAS(Compare And Swap，比较并交换)**算法指的是在修改一个变量A时，先读取内存中变量的旧值old，然后在旧值old的基础上计算得到新值result，再从内存中读取变量的最新值new与旧值old进行比较，如果相同则说明变量A没有被其它线程修改过，这时再将result赋值给变量A，此时变量A修改完成。如果old和new不相等，说明变量A被其它线程修改过，此时不会将result赋值给变量A，而是会重新进行CAS操作，直到old和new相等。

* ### 什么是悲观锁和乐观锁？

　　悲观锁指的是在访问共享变量时，悲观地估计有其它线程修改该变量，于是访问时加锁以确保线程安全。

　　乐观锁指的是在访问共享变量时，乐观地估计没有其它线程修改该变量，于是访问时不加锁，一般通过CAS操作确保线程安全。乐观锁适用于读操作频率远大于写操作的场景。

* ### 什么是自旋锁？

　　在悲观锁中，等待锁的线程会进入阻塞状态，阻塞状态下的线程不会占用CPU，但是挂起和恢复线程的动作会影响虚拟机性能。假如计算机有多个处理器(或者一个处理器有多个核心)，可以让两个或以上的线程并发执行，我们就可以让等待锁的线程“稍等一会”，但仍然占用CPU，看看持有锁的线程是否能很快释放锁。为了让锁等待，我们只需让线程执行一个忙循环，这就是**自旋锁**。

　　JDK中默认启用自旋锁，默认的自旋次数是**10次**。自旋锁的优点是避免了线程频繁的挂起和恢复，缺点是会占用CPU时间，自旋锁适用于锁被占用的时间很短的场景。

　　**自适应自旋锁**：锁的自旋次数不固定，而是根据上一次自旋的时间和锁拥有者的状态动态决定。

* ### 什么是锁消除？

　　锁消除指的是编译器对一些代码中要求同步，但是经过检测发现不存在共享数据竞争的锁进行消除。

* ### 什么是锁粗化？

　　频繁地对一段同步代码进行加锁解锁会消耗性能，所以虚拟机会将这段代码的锁范围扩大，这就是锁粗化。

* ### 简述synchronized的同步机制

　　synchronized关键字是通过四种锁来实现同步的。synchronized的同步机制是：

　　1、**无锁**，即没有加锁，任何线程都可以访问；

　　2、当一个线程访问同步代码时，会通过CAS操作判断当前是否有其它线程在竞争锁，如果没有，就直接执行代码，不会走加锁、解锁流程，这就是**偏向锁**；如果有其它线程在竞争锁，就会升级为轻量级锁；

　　3、**轻量级锁**状态下，线程会通过CAS自旋的方式尝试获取锁，自旋时线程会消耗CPU资源。当竞争锁的线程达到一定数量，或者超过了自旋次数时，会升级为重量级锁；

　　4、**重量级锁**状态下，等待锁的线程会进入阻塞状态，不会消耗CPU资源。

* ### 简述ReentrantLock、ReentrantReadWriteLock、StampedLock的特点

　　**ReentantLock**：和synchronized很像，优点是可以指定获取锁的超时时间，避免长时间等待。一般情况下可以用synchronized代替。

　　**ReentrantReadWriteLock**：写的时候不允许其它线程写、读，读的时候不允许其它线程写，但是允许读。这是一种**悲观读锁**。

　　**StampedLock**：写的时候不允许其它线程写、读，读的时候允许其它线程写、读。这是一种**乐观读锁**。乐观读锁使用了`CAS`无锁方式实现线程安全，读的时候如果发现值发生了变化，会通过重试来获取新值。这种锁适用于读操作远多于写操作的场景。

* ### J.U.C包中线程安全的集合类有哪些？

| 接口  |  非线程安全的集合类   |            线程安全的集合类            |
| :---: | :-------------------: | :------------------------------------: |
| List  |       ArrayList       |          CopyOnWriteArrayList          |
|  Map  |        HashMap        |           ConcurrentHashMap            |
|  Set  |        HashSet        |          CopyOnWriteArraySet           |
| Queue | ArrayDeque/LinkedList | ArrayBlockingQueue/LinkedBlockingQueue |

　　**ConcurrentHashMap**：它的线程安全是通过`CAS和synchronized`实现的，比较复杂。

　　**CopyOnWriteArrayList和CopyOnWriteArraySet**：它们的线程安全是通过`CopyOnWrite`机制实现的，即只对原对象的拷贝进行写入，然后再将原对象的引用指向拷贝对象。当容器在进行写操作时，CopyOnWrite可以保证多个线程读取到的是同一个值，但是无法保证读取到的是最新值，因此**它只能保证最终数据的一致性**。

　　**ArrayBlockingQueue和LinkedBlockingQueue**：它们的线程安全是通过`加锁(ReentrantLock)`实现的。

* ### 介绍一下几种通信工具类

|   通信工具类   |                   作用                    |
| :------------: | :---------------------------------------: |
|   Semaphore    |          可以限制线程并发的数量           |
|   Exchanger    |         用于两个线程之间交换数据          |
| CountDownLatch |   用于在主线任务之前执行一系列前置任务    |
| CyclicBarrier  |    CountDownLatch的改进，可以重复使用     |
|     Phaser     | CyclicBarrier的改进，可以动态调整前置任务 |

　　工作原理介绍：

　　1、**Semaphore**：持有一个int类型的permits，线程执行任务时，每次调用`acquire()`方法会获得一个permit，每次调用`release()`方法会释放一个permit。只有获得了permit的线程才能执行，获取不到的进入等待。

　　2、**Exchanger**：两个线程通过执行`exchange()`方法交换数据。

　　3、**CountDownLatch**：持有一个int类型的count，主线任务调用`await()`方法进入等待，前置任务每调用一次`countDown()`方法count减一，当count减到0时主线任务开始执行。

　　4、**CyclicBarrier**：持有一个int类型的count，在前置任务中调用`await()`方法，当调用次数达到count时，执行主线任务，并重置调用次数。

* ### 简述Atomic类的工作原理

　　Atomic包装类实现了一组原子操作，它的工作原理是CAS。

* ### 简述线程池的参数和任务执行流程

　　线程池的核心类是ThreadPoolExecutor，它的构造方法有7个参数：

```java
public ThreadPoolExecutor(
	int corePoolSize,                    /*1、核心线程数量最大值*/
    int maximumPoolSize,                 /*2、总线程数量最大值，总线程数量包括了核心线程和非核心线程*/
    long keepAliveTime,                  /*3、非核心线程超时时间*/
    TimeUnit unit,                       /*4、时间单位*/
    BlockingQueue<Runnable> workQueue,   /*5、阻塞队列，用来存放等待执行的Runnable任务*/
    ThreadFactory threadFactory,         /*6、创建线程的工厂*/
    RejectedExecutionHandler handler)    /*7、拒绝策略*/
```

　　线程池的任务执行流程是：

　　1、当线程池中`有效线程数量<核心线程最大值`时，会新建线程执行任务。

　　2、当`有效线程数量>=核心线程最大值`，并且阻塞队列未满时，会将任务放进阻塞队列等待执行。

　　3、当阻塞队列已满，并且`有效线程数量<总线程数量最大值`时，会新建线程执行任务。

　　4、当`有效线程数量>=总线程数量最大值`，就会执行拒绝策略，默认的拒绝策略是抛出异常。

* ### 介绍一下线程池的拒绝策略

　　线程池有4种拒绝策略：

　　1、**AbortPolicy**：默认策略，丢弃任务并抛出异常。

　　2、**DiscardPolicy**：丢弃任务但不抛出异常。

　　3、**DiscardOldestPolicy**：丢弃阻塞队列中最早的任务，然后把当前任务添加进去。

　　4、**CallerRunsPolicy**：由调用线程去处理当前任务。

* ### 介绍一下线程池的运行状态

　　线程池有5种运行状态：

　　1、**RUNNING**：可以接受新的任务，也可以处理阻塞队列中的任务。

　　2、**SHUTDOWN**：不再接受新的任务，但是可以处理阻塞队列中的任务。

　　3、**STOP**：不再接受新的任务，也不能处理阻塞队列中的任务，并且会中断正在执行的任务。

　　4、**TIDYING**：所有任务都终止了，有效线程数量为0。

　　5、**TERNINATED**：在执行完terminated()方法后进入该状态。

* ### 介绍一下ThreadLocal

　　ThreadLocal是线程共享变量。可以把ThreadLocal看作是一个全局的`Map<Thread,Object>`，当它调用`set(Object o)`方法时，它会以当前线程对象作为key，o作为value进行存储。当它调用`get()`方法时，它会以当前线程对象为key，取出value。

　　

