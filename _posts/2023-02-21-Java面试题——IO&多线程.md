---
title: Java面试题——IO&多线程
tags: Java面试题
---

## 一、IO

* ### 简述IO的继承结构

　　![IO继承结构图](/assets/img/java/IO继承结构图.png)

* ### 简述Java对象的序列化和反序列化

　　**定义**：序列化指的是把一个Java对象变成二进制内容，从而可以将对象保存到文件中，或者通过网络传输到远程。反序列化指的是把一个二进制内容变回Java对象。

　　**实现**：可以通过`ObjectOutputStream`把一个Java对象转换为字节流写入文件，通过`ObjectInputStream`从一个二进制内容中读取Java对象。

　　**Serializable**：只有实现了`Serializable`接口的对象才能被序列化。

　　**transient**：只能修饰局部变量，被修饰的变量不会被序列化。

## 二、多线程

* ### 简述进程与线程的区别与联系

　　**联系**：都是用来实现并发任务的，进程实现了操作系统任务的并发，线程实现了进程任务的并发。

　　**区别**：

　　　　1、进程拥有独立的内存空间，各个进程互不干扰，而同一个进程中的线程共享该进程的内存空间；

　　　　2、进程是操作系统进行资源分配的基本单位，线程是操作系统进行调度的基本单位，即CPU分配时间的单位。

* ### 简述Java内存模型(JMM)

　　1、所有变量都存储在主内存，每个线程都有自己的工作内存；

　　2、工作内存中保存了被该线程使用的变量的主存副本，线程对变量的所有操作都在工作内存中进行，不能直接操作主内存；

　　3、操作完成后，线程的工作内存通过缓存一致性协议将变量刷回主内存，但是刷新操作并不一定立刻发生。

* ### 简述原子性操作

　　原子性操作指的是一个操作或多个操作，要么全部执行成功，要不全都不执行。

* ### 简述volatile关键字的作用

　　volatile用来修饰变量，它的作用是：

　　1、保证共享变量对所有线程的**可见性**。如果没有volatile关键字，由于Java内存模型的存在，一个线程读取到的变量值不一定是主内存中的最新值，一个线程修改了的变量不一定会马上刷新回主内存。加了volatile之后，该变量一旦被修改就会立刻刷新回主内存，读取该变量时会去主内存中读取最新值。

　　2、**禁止指令重排**。CPU为了提高程序执行效率，允许多条指令不按照规定的顺序执行，只会保证最终结果的正确，这在单线程中是安全的，但是在多线程中是不安全的。volatile可以禁止对该变量进行指令重排，典型的应用就是双重检验锁实现单例模式时，共享变量要用volatile修饰。

* ### 简述Java线程的状态

* ### 线程的创建方式有哪些？

　　1、**继承Thread类**，重写run方法；

　　2、**实现Runnable接口**，重写run方法，然后传入Thread的构造方法；

　　3、**实现Callable接口**，重写call方法，然后传入FutureTask的构造方法，再将新对象传入Thread的构造方法。和前两种方法不同的是，这种方式可以获取call方法的返回值。

　　Runnable和Callable都是函数式接口，可以用lambda表达式简化。

* ### 简述线程的6种状态以及转换过程

　　线程的6种状态分别是：**NEW(新建)、RUNNABLE(可运行)、BLOCKED(阻塞)、WAITING(等待)、TIMED_WAITING(超时等待)、TERMIATED(终止)**。

　　这6种状态的转换过程如下图所示：

![线程的6种状态](/assets/img/java/线程的6种状态.png)

　　各个状态之间的转换过程是：

　　1、新创建的线程处于NEW状态，当调用start()方法启动线程后就进入了RUNNABLE状态，更具体地说是进入了RUNNABLE状态中的**Ready(就绪)**状态，等待CPU为线程分配时间分片。

　　2、线程获取到CPU时间分片后进入RUNNABLE状态中的**Running(运行)**状态。

　　3、RUNNING状态下的线程无法获取到锁，就会进入BLOCKED状态，阻塞状态下的线程会失去时间分片。

　　4、BLOCKED状态下的线程获取到了锁，就会进入Ready状态。

　　5、RUNNING状态下的线程在执行过程中，被其它线程对象调用了join()方法，或者锁对象调用了wait()方法，都会进入WAITING状态，等待状态下的线程会失去时间分片。

　　6、WAITING状态下的线程在等待过程中，被其它线程唤醒，就会进入Ready状态。对于join()方法唤醒的方式就是调用线程结束，对于wait()方法唤醒的方式就是锁对象调用notify()或notifyAll()方法。

　　7、RUNNING状态下的线程在执行过程中，调用了sleep(long)方法，或者对锁对象调用了wait(long)方法，都会进入TIMED_WAITING状态，它和WAITING状态的区别是在指定时间后会自动唤醒。

　　8、TIMED_WAITING状态下的线程在等待时间过后会自动唤醒，进入Ready状态，如果还在等待时间以内，并且锁对象调用了notify()或notifyAll()方法，也会被唤醒，进入Ready状态。

　　9、线程执行完成后就会进入TERMIATED。

> 　　BLOCKED和TIMED_WAITING的区别是，BLOCKED状态下的线程没有时间分片也没有锁，TIMED_WAITING状态下的线程没有时间分片，但是不一定没有锁，当调用sleep()方法使线程等待时，线程不会释放锁，当调用wait()方法使线程等待时，线程才会释放锁。

* ### 什么是可重入锁？

　　可以被同一个线程重复获取的锁叫做可重入锁，比如synchronized。

* ### 什么是死锁？

　　两个线程各自持有不同的锁，然后试图获取对方手里的锁，造成了无限等待，这就是死锁。

* ### 简述ReentrantLock、ReadWriteLock、StampedLock的特点

　　**ReentantLock**：和synchronized很像，优点是可以指定获取锁的超时时间，避免长时间等待。一般情况下可以用synchronized代替。

　　**ReadWriteLock**：写的时候不允许其它线程写、读，读的时候不允许其它线程写，但是允许读。这是一种悲观读锁。

　　**StampedLock**：写的时候不允许其它线程写、读，读的时候允许其它线程写、读。这是一种乐观读锁。乐观读锁使用了`CAS`无锁方式实现线程安全，读的时候如果发现值发生了变化，会通过重试来获取新值。这种锁适用于读操作远多于写操作的场景。

* ### 线程安全的集合

* ### Atomic包装类

* ### 线程池

　　