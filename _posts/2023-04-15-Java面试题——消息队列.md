---
title: Java面试题——消息队列
tags: Java面试题
---

## 一、消息队列如何解决消息丢失问题(消息的一致性)？

　　要保证在这三个阶段中消息不丢失：

　　1、生产者到存储端；

　　2、存储端；

　　3、存储端到消费者。

* ### RabbitMQ实现

　　**1、生产者到交换器**

　　异步确认。当生产者收到存储端发来的成功确认后，说明消息成功到达了交换器，如果收到的是失败确认，说明消息没有成功到达交换器，生产者需要重新发送消息。

　　**2、交换器到队列**

　　**备份交换器**。如果交换器没有绑定队列，消息还是会丢失，所以最好为交换器再绑定一个备份交换器，数据会存储到备份交换器中的队列里。

　　**3、队列到磁盘**

　　**开启交换器持久化、队列持久化、消息持久化**。

　　**4、队列到消费者**

　　**消费者手动确认消息**。

* ### Kafka实现

　　**1、生产者到Topic**

　　和RabbitMQ类似，**在回调函数中对异常情况进行处理**，发生异常时重新发送消息。

 　　**2、Topic到磁盘**

　　集群。

　　**3、Topic到消费者**

　　**消费者手动提交**。

## 二、消息队列如何保证消息的有序性？

* ### RabbitMQ实现

　　保证这些消息在同一个队列中，并且该队列只有一个消费者。

* ### Kafka实现

　　保证这些消息在同一个Partiton中。

## 三、消息队列如何避免重复消费？

　　要避免重复消费，就要保证消费者接口的幂等性。**幂等性指的是重复消费与一次消费的结果是一样的，不会对业务系统产生负面影响**。

　　幂等性的实现方法有：

　　1、为每条消息分配一个**全局ID**，消费前先根据全局ID查询这条消费是否已经被消费过了，如果是就不再消费。

　　2、数据库唯一约束。

　　3、每次操作都直接**set到redis里面**，然后将redis数据定时同步到数据库中。

　　4、此方案多用于更新的场景下。其实现的大体思路是：给业务数据增加一个**版本号属性**，每次更新数据前，比较当前数据的版本号是否和消息中的版本一致，如果不一致则拒绝更新数据，更新数据的同时将版本号+1。

## 四、怎样解决消息堆积问题？

　　三种思路：

　　1、增加消费者；

　　2、在消费者内使用多线程；

　　3、扩大队列容积。