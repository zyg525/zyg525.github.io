---
title: RabbitMQ教程
tags: 消息中间件 RabbitMQ
---

　　本教程基于`RabbitMQ 3.9.11`。

## 一、RabbitMQ简介

　　RabbitMQ 是实现了高级消息队列协议（**AMQP**, Advanced Message Queuing Protocol）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ 服务器是用 Erlang 语言编写的。

*  ### 第一个案例

　　1、引入Maven依赖

```xml
<dependency>
    <groupId>com.rabbitmq</groupId>
    <artifactId>amqp-client</artifactId>
    <version>5.9.0</version>
</dependency>
```

　　2、创建生产者

```java
public class Sender {
    public static void main(String[] args) {
        //1、创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        //2、设置RabbitMQ服务主机
        factory.setHost("192.168.154.130");
        //3、设置虚拟主机
        factory.setVirtualHost("/host1");
        //4、设置用户名和密码
        factory.setUsername("test1");
        factory.setPassword("test1");

        try(Connection connection = factory.newConnection(); //5、创建连接
            Channel channel = connection.createChannel(); //6、创建信道
            ){

            //7、声明队列queue1
            channel.queueDeclare("queue1",false,false,false,null);

            String msg = "你好RabbitMQ！";
            //8、向队列queue1发送消息msg
            channel.basicPublish("","queue1",null,msg.getBytes(StandardCharsets.UTF_8));

            System.out.println("send message...");
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}
```

　　3、创建消费者

```java
public class Receiver {
    public static void main(String[] args) throws Exception {
        //1、创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        //2、设置RabbitMQ服务主机
        factory.setHost("192.168.154.130");
        //3、设置虚拟主机
        factory.setVirtualHost("/host1");
        //4、设置用户名和密码
        factory.setUsername("test1");
        factory.setPassword("test1");
        //5、创建连接
        Connection connection = factory.newConnection();
        //6、创建信道
        Channel channel = connection.createChannel();

        //7、声明队列queue1
        channel.queueDeclare("queue1",false,false,false,null);

        //8、创建回调函数，当队列中有消息时会执行这个函数，进行消费
        DeliverCallback deliverCallback = (tag, delivery)->{
            String msg = new String(delivery.getBody(),"UTF-8");
            System.out.println("Received msg: "+msg);
        };
        //9、消费queue1队列中的消息
        channel.basicConsume("queue1",true,deliverCallback,tag->{});

        System.out.println("waiting for message...");
    }
}
```

　　4、启动消费者和生产者，会发现消费者在监听队列queue1，并消费了生产者发送的消息。

* ### 基本概念

　　**连接(Connection)**：网络连接，比如一个TCP连接。

　　**信道(Channel)**：建立在Connection上的虚拟连接，消息通过信道进行传输。对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。

　　**虚拟主机(Virtual Host)**：表示一批交换器、消息队列和相关对象。虚拟主机之间是互相独立的，只有同一个虚拟主机内才可以发送消息。

## 二、交换器

* ### 交换器的工作原理

　　交换器的工作原理如下图所示：

![交换器工作原理](/assets/img/java/交换器工作原理.png)

　　1、队列通过`BindingKey(绑定键)`绑定到了交换器上；

　　2、生产者向交换器发送消息，消息中携带有`RoutingKey(路由键)`，交换器会根据路由键和绑定键是否匹配，决定这条消息应该发送到哪个队列中；

　　3、多个队列的绑定键可以相同，此时消息会发送到多个队列上。

* ### 交换器类型

　　交换器支持四种类型，它们的区别仅仅在于路由规则(路由键和绑定键的匹配规则)不同：

　　1、**direct**：路由键和绑定键必须完全一样。

　　2、**fanout**：不需要路由键和绑定键，消息会发送到交换器绑定的所有队列中。

　　3、**topic**：对direct进行了扩展，路由键和绑定键是一个由`.`分割的字符串，绑定键包含`*`和`#`两种特殊字符，支持模糊匹配，其中`*`用于匹配一个单词，`#`用于匹配0个或多个单词。比如路由键`www.baidu.com`和绑定键`*.baidu.com`、`#.com`都是匹配的。

　　4、**headers**：不需要路由键和绑定键，但是队列和交换器绑定时会指定消息头键值对，只有当消息中包含指定的消息头键值对时，这条消息才会被发送到队列中。队列和交换器绑定时，有一个特殊的键`x-match`，当它的值是`all`时，表示完全匹配，即当消息中包含所有指定的消息头时，才能匹配上，当它的值是`any`时，表示部分匹配，即当消息中只要包含一个指定的消息头时，就能匹配上。

* ### 声明交换器

　　可以在RabbitMQ可视化面板中创建一个交换器，也可以在Java代码中声明一个交换器：

```java
Exchange.DeclareOk exchangeDeclare(String exchange,
                                   String type,
                                   boolean durable,
                                   boolean autoDelete,
                                   boolean internal,
                                   Map<String, Object> arguments) throws IOException;
```

　　这是Channel接口中的方法，它的6个参数含义如下：

　　1、exchange：交换器名称。

　　2、type：交换器类型，有`direct`、`fanout`、`topic`、`headers`四种。

　　3、durable：是否持久化。`true`代表开启持久化，可以将交换器信息保存到磁盘中，服务重启后交换器信息不会丢失。

　　4、autoDelete：是否自动删除。自动删除的前提是至少有一个队列或交换器与这个交换器绑定，当所有队列或交换器与它解绑时，会触发自动删除。

　　5、internal：是否是内置交换器。客户端无法发送消息到内置交换器，只能通过交换器路由到内置交换器。

　　6、arguments：其它一些结构化参数。

## 三、队列

　　RabbitMQ中的队列是符合**先进先出**规则的线性表。**多个消费者可以订阅同一个队列，这时队列中的消息会被平均分摊给多个消费者进行消费，而不是每个消费者都收到所有的消息并消费**。

* ### 声明队列

　　可以在RabbitMQ可视化面板中创建一个队列，也可以在Java代码中声明一个队列：

```java
Queue.DeclareOk queueDeclare() throws IOException;
Queue.DeclareOk queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete,
                             Map<String, Object> arguments) throws IOException;
```

　　这是Channel接口中的方法，它的5个参数含义如下：

　　1、queue：队列名称。

　　2、durable：是否持久化。`true`代表开启持久化，可以将队列信息保存到磁盘中，服务重启后队列信息不会丢失(但队列中的消息会丢失)。

　　3、exclusive：是否排他队列。排他队列只对首次声明它的连接(Connection)可见，当连接断开后自动删除(即使开启持久化也会删除)，多个连接不允许建立同名的排他队列。

　　4、autoDelete：是否自动删除。自动删除的前提是至少有一个消费者连接这个队列，当所有消费者与它断开连接后，会触发自动删除。

　　5、arguments：设置队列的一些其它参数。

　　不带任何参数的`queueDeclare()`方法默认创建一个由 RabbitMQ 命名的（类似这种 `amq.gen-**** `名称，这种队列称为匿名队列）、排他的、自动删除的、非持久化的队列。　

* ### 队列绑定交换器

　　可以在RabbitMQ可视化面板中绑定队列到交换器，也可以在Java代码中绑定：

```java
Queue.BindOk queueBind(String queue, String exchange, String routingKey, Map<String, Object> arguments)                            throws IOException;
```

　　这是Channel接口中的方法，它的4个参数含义如下：

　　1、queue：队列名称。

　　2、exchange：交换器名称。

　　3、routingkey：绑定键。

　　4、arguments：指定消息中需要携带的键值对。

## 四、发送消息

* ### basicPublish()方法

　　可以通过`basicPublish()`方法，经由交换器发送消息到队列中：

```java
void basicPublish(String exchange, String routingKey, boolean mandatory, boolean immediate, 
                  BasicProperties props, byte[] body) throws IOException;
```

　　这是Channel接口中的方法，它的6个参数含义如下：

　　1、exchange：交换器名称。

　　2、routingKey：路由键。

　　3、mandatory：如果将 mandatory 参数设为 true 时，交换器无法根据自身的类型和路由键找到一个符合条件的队列，那么 RabbitMQ 会调用 Basic.Return 命令将消息返回给生产者。当 mandatory 参数设置为 false 时，交换器无法根据自身的类型和路由键找到一个符合条件的队列，则消息直接被丢弃。

　　4、immediate：当 immediate 参数设为 true 时，如果交换器在将消息路由到队列时发现队列上并不存在任何消费者，那么这条消息将不会存入队列中。当与路由键匹配的所有队列都没有消费者时，该消息会通过 Basic .Return 返回至生产者。

　　5、props：消息的基本属性集，其包含 14 个属性成员，分别有 `contentType、contentEncoding、headers(Map<String,Object>)、deliveryMode、priority、correlationId、 replyTo、expiration、messageId、timestamp、type、userId、appId、clusterId`。

　　6、body：消息体。

* ### 案例

```java
//1、消息头
HashMap<String, Object> headers = new HashMap<>();
headers.put("name","jack");
headers.put("age","18");

//2、消息体
String msg = "你好RabbitMQ！";

//3、消息的基本属性集
AMQP.BasicProperties basicProperties = new AMQP.BasicProperties().builder()
        .headers(headers) //设置消息头
        .contentType("text/plain") //设置消息类型
        .deliveryMode(2) //开启消息持久化
        .build();

//4、发送消息到交换器exchange1中绑定键与路由键key1相匹配的队列
channel.basicPublish("exchange1", "key1", false, false,
        basicProperties, msg.getBytes(StandardCharsets.UTF_8));
```

## 五、消费消息

* ### basicConsume()方法

　　`basicConsume()`方法的作用是让RabbitMQ服务不断推送消息给消费者，并触发回调方法(Consumer 接口实现类)：

```java
String basicConsume(String queue, boolean autoAck, String consumerTag, boolean noLocal, boolean exclusive,                       Map<String, Object> arguments, Consumer callback) throws IOException;
```

　　这是Channel接口中的方法，它的7个参数含义如下：

　　1、queue：队列名称。

　　2、autoAck：是否自动确认消息。

　　3、consumerTag：消费者标签，用来对多个消费者进行区分。

　　4、noLocal：设置为 true 则表示不能将同一个 Connection（连接）中生产者发送的消息传送给这个 Connection 中的消费者。

　　5、exclusive：置是否排它，true 表示排它。

　　6、arguments：设置消费者的其他参数。

　　7、callback：设置消费者的回调方法（必须实现 Consumer 接口）。通常使用`DefaultConsumer`类，只需要重写它的`handleDelivery()`方法作为回调方法。

* ### 案例

```java
//1、创建回调方法
DefaultConsumer defaultConsumer = new DefaultConsumer(channel){
    @Override
    public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
        String msg = new String(body,"UTF-8");
        System.out.println("msg: "+msg); //打印消息
    }
};

//2、让RabbitMQ服务推送队列queue1中的消息给消费者，并触发回调方法
channel.basicConsume("queue1",true,"consumer1",false,false,null,defaultConsumer);
```

* ### 消息确认

　　RabbitMQ 为了保证消息从队列可靠地到达消费者，它提供了消息确认机制（Message Acknowledgement）。消费者在订阅队列时，可以指定 autoAck 参数，**当 autoAck 设置为 false，RabbitMQ 会等待消费者手动地回复 ACK 确认信号，当收到 ACK 确认信号后才将消息从消息队列移除（实际上是先打上删除标记，之后再删除），如果没收到确认信号，那么这条消息还会保留在队列中，但是只能被当前消费者消费，只有当前消费者断开连接后，这条消息才能被其它消费者消费**。当 autoAck 等于 true 时，RabbitMQ 会自动把发送出去的消息设置为确认，然后从队列中删除，而不管消费者是否真正地消费到这个消息。

　　在回调方法中手动确认消息：

```java
DefaultConsumer defaultConsumer = new DefaultConsumer(channel){
    @Override
    public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
        String msg = new String(body,"UTF-8");
        System.out.println("msg: "+msg);
        long deliveryTag = envelope.getDeliveryTag();deliveryTag等于小于当前
        channel.basicAck(deliveryTag,false); //false表示只确认这一条消息，true表示确认deliveryTag等于小于当前值的所有消息(批量确认)
    }
};
```

* ### 消息拒绝

　　假如我们不想消费某条消息，并且希望这条消息被其它消费者消费，这时消息确认就派不上用场了，因为如果一直不确认消息，并且当前消费者没有断开连接，那么这条消息是无法被其它消费者消费的。此时可以使用消息拒绝，**被拒绝的消息会被重新放回队列，等待被其它消费者消费，即使当前消费者没有断开连接**。

　　在回调方法中拒绝消息：

```java
DefaultConsumer defaultConsumer = new DefaultConsumer(channel){
    @Override
    public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
        String msg = new String(body,"UTF-8");
        System.out.println("msg: "+msg);
        long deliveryTag = envelope.getDeliveryTag();
        channel.basicReject(deliveryTag,true); //true表示被拒绝的消息会被重新放回队列，false表示被拒绝的消息会被删除
    }
};
channel.basicConsume("queue1",true,"consumer1",false,false,null,defaultConsumer); //关闭自动确认
```

　　`basicReject()`方法只能拒绝一条消息，如果要批量拒绝消息，可以使用`basicNack()`方法：

```java
//multiple为false时，表示只拒绝这一条消息，为true时表示拒绝deliveryTag等于小于当前值的所有消息(批量拒绝)
void basicNack(long deliveryTag, boolean multiple, boolean requeue)
        throws IOException; 
```

## 六、特殊队列

* ### 过期时间(TTL)

　　RabbitMQ 可以对消息和队列设置过期时间（TTL，全称 Time To Live）。目前有两种方法可以设置过期时间：

　　1、第一种方法是通过队列属性设置，队列中所有消息都有相同的过期时间。

```java
AMQP.BasicProperties properties = new AMQP.BasicProperties.Builder()
        .deliveryMode(2) // 持久化消息
        .expiration("10000") // 设置过期时间为 10 秒
        .build();
```

　　2、第二种方法是对消息进行单独设置，每条消息的过期时间可以不同。

```JAVA
Map<String,Object> argss =new HashMap<String,Object>() ;
argss.put("x-message-ttl", 10000); // 设置过期时间为 10 秒
channel.queueDeclare(QUEUE_NAME, true, false, true, argss) ;
```

　　如果同时设置队列和消息的过期时间，则消息的过期时间以两者之间过期时间较小的那个数值为准。**消息在队列的生存时间一旦超过设置的过期时间值，就成为“死信”（Dead Message），消费者将无法再收到该消息**。

* ### 死信队列(DLX)

　　RabbitMQ 中由于某些原因（如路由键和绑定键不匹配，或者交换器上面没有绑定队列等等）导致消息无法被正确的投递，**为了确保消息不会被无故的丢弃，一般将其置于一个特殊的队列中，这个队列一般称之为死信队列。**如果消息在一个队列中变成死信（Dead Message）之后，它将被重新发送到另一个交换器中，该交换器称为死信交换器，绑定在死信交换器上的队列就称之为死信队列，死信交换器的简称为 DLX（Dead-Letter-Exchange）。

　　消息变成死信有如下几种情况：

　　1、消息被拒绝（Basic.Reject/Basic.Nack），并且设置 requeue 参数为 false；

　　2、消息过期；

　　3、队列达到最大长度。



　　可以在RabbitMQ可视化面板中为一个普通队列设置死信队列，也可以在Java代码中设置：

```java
//1、声明死信交换器
channel.exchangeDeclare("exchange-dlx","fanout");
//2、声明死信队列
channel.queueDeclare("queue-dlx",true,false,false,null);
//3、绑定死信交换器和死信队列
channel.queueBind("queue-dlx","exchange-dlx","");

//4、为普通队列设置死信交换器
HashMap<String, Object> map = new HashMap<>();
map.put("x-dead-letter-exchange","exchange-dlx");
channel.queueDeclare("queue3",true,false,false,map);
```

* ### 延迟队列

　　延迟队列顾名思义就是存放延迟消息的队列，所谓“延迟消息”是指消息被发送后，并不想让消费者立刻进行消费，而是需要等待指定的时间后，消费者才能够进行消费。**通过死信交换器（DLX）和过期时间（TTL）可以实现延迟队列的功能**。思路是：消息生产者发送一个带有 TTL（延迟时间）的消息到正常的交换器，且正常交换器绑定的队列没有被任何消费者订阅（也就不会被消费）。当时间慢慢过去，一旦时间超过我们为消息设置的 TTL 时间后，RabbitMQ 将会自动将过期的消息发送到队列指定的死信交换器，死信交换器将消息路由到死信队列。此时，如果有消费者订阅了死信队列，则这些消息将被消费者消费，就这样成功模拟了一个延迟队列。
