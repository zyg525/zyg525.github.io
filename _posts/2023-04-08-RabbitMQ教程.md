---
title: RabbitMQ教程
tags: 消息中间件 RabbitMQ
---

　　本教程基于`RabbitMQ 3.9.11`。

## 一、RabbitMQ简介

　　RabbitMQ 是实现了高级消息队列协议（**AMQP**, Advanced Message Queuing Protocol）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ 服务器是用 Erlang 语言编写的。

*  ### 第一个案例

　　1、引入Maven依赖

```xml
<dependency>
    <groupId>com.rabbitmq</groupId>
    <artifactId>amqp-client</artifactId>
    <version>5.9.0</version>
</dependency>
```

　　2、创建生产者

```java
public class Sender {
    public static void main(String[] args) {
        //1、创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        //2、设置RabbitMQ服务主机
        factory.setHost("192.168.154.130");
        //3、设置虚拟主机
        factory.setVirtualHost("/host1");
        //4、设置用户名和密码
        factory.setUsername("test1");
        factory.setPassword("test1");

        try(Connection connection = factory.newConnection(); //5、创建连接
            Channel channel = connection.createChannel(); //6、创建信道
            ){

            //7、声明队列queue1
            channel.queueDeclare("queue1",false,false,false,null);

            String msg = "你好RabbitMQ！";
            //8、向队列queue1发送消息msg
            channel.basicPublish("","queue1",null,msg.getBytes(StandardCharsets.UTF_8));

            System.out.println("send message...");
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}
```

　　3、创建消费者

```java
public class Receiver {
    public static void main(String[] args) throws Exception {
        //1、创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        //2、设置RabbitMQ服务主机
        factory.setHost("192.168.154.130");
        //3、设置虚拟主机
        factory.setVirtualHost("/host1");
        //4、设置用户名和密码
        factory.setUsername("test1");
        factory.setPassword("test1");
        //5、创建连接
        Connection connection = factory.newConnection();
        //6、创建信道
        Channel channel = connection.createChannel();

        //7、声明队列queue1
        channel.queueDeclare("queue1",false,false,false,null);

        //8、创建回调函数，当队列中有消息时会执行这个函数，进行消费
        DeliverCallback deliverCallback = (tag, delivery)->{
            String msg = new String(delivery.getBody(),"UTF-8");
            System.out.println("Received msg: "+msg);
        };
        //9、消费queue1队列中的消息
        channel.basicConsume("queue1",true,deliverCallback,tag->{});

        System.out.println("waiting for message...");
    }
}
```

　　4、启动消费者和生产者，会发现消费者在监听队列queue1，并消费了生产者发送的消息。

* ### 基本概念

　　**连接(Connection)**：网络连接，比如一个TCP连接。

　　**信道(Channel)**：建立在Connection上的虚拟连接，消息通过信道进行传输。对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。

　　**虚拟主机(Virtual Host)**：表示一批交换器、消息队列和相关对象。虚拟主机之间是互相独立的，只有同一个虚拟主机内才可以发送消息。

## 二、交换器

* ### 交换器的工作原理

　　交换器的工作原理如下图所示：

![交换器工作原理](/assets/img/java/交换器工作原理.png)

　　1、队列通过`BindingKey(绑定键)`绑定到了交换器上；

　　2、生产者向交换器发送消息，消息中携带有`RoutingKey(路由键)`，交换器会根据路由键和绑定键是否匹配，决定这条消息应该发送到哪个队列中；

　　3、多个队列的绑定键可以相同，此时消息会发送到多个队列上。

* ### 交换器类型

　　交换器支持四种类型，它们的区别仅仅在于路由规则(路由键和绑定键的匹配规则)不同：

　　1、**direct**：路由键和绑定键必须完全一样。

　　2、**fanout**：不需要路由键和绑定键，消息会发送到交换器绑定的所有队列中。

　　3、**topic**：对direct进行了扩展，路由键和绑定键是一个由`.`分割的字符串，绑定键包含`*`和`#`两种特殊字符，支持模糊匹配，其中`*`用于匹配一个单词，`#`用于匹配0个或多个单词。比如路由键`www.baidu.com`和绑定键`*.baidu.com`、`#.com`都是匹配的。

　　4、**headers**：不需要路由键和绑定键，但是队列和交换器绑定时会指定消息头键值对，只有当消息中包含指定的消息头键值对时，这条消息才会被发送到队列中。队列和交换器绑定时，有一个特殊的键`x-match`，当它的值是`all`时，表示完全匹配，即当消息中包含所有指定的消息头时，才能匹配上，当它的值是`any`时，表示部分匹配，即当消息中只要包含一个指定的消息头时，就能匹配上。

* ### 声明交换器

　　可以在RabbitMQ可视化面板中创建一个交换器，也可以在Java代码中声明一个交换器：

```java
Exchange.DeclareOk exchangeDeclare(String exchange,
                                   String type,
                                   boolean durable,
                                   boolean autoDelete,
                                   boolean internal,
                                   Map<String, Object> arguments) throws IOException;
```

　　这是Channel接口中的方法，它的6个参数含义如下：

　　1、exchange：交换器名称。

　　2、type：交换器类型，有`direct`、`fanout`、`topic`、`headers`四种。

　　3、durable：是否持久化。`true`代表开启持久化，可以将交换器信息保存到磁盘中，服务重启后交换器信息不会丢失。

　　4、autoDelete：是否自动删除。自动删除的前提是至少有一个队列或交换器与这个交换器绑定，当所有队列或交换器与它解绑时，会触发自动删除。

　　5、internal：是否是内置交换器。客户端无法发送消息到内置交换器，只能通过交换器路由到内置交换器。

　　6、arguments：其它一些结构化参数。

## 三、队列

　　RabbitMQ中的队列是符合**先进先出**规则的线性表。**多个消费者可以订阅同一个队列，这时队列中的消息会被平均分摊给多个消费者进行消费，而不是每个消费者都收到所有的消息并消费**。

* ### 声明队列

　　可以在RabbitMQ可视化面板中创建一个队列，也可以在Java代码中声明一个队列：

```java
Queue.DeclareOk queueDeclare() throws IOException;
Queue.DeclareOk queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete,
                             Map<String, Object> arguments) throws IOException;
```

　　这是Channel接口中的方法，它的5个参数含义如下：

　　1、queue：队列名称。

　　2、durable：是否持久化。`true`代表开启持久化，可以将队列信息保存到磁盘中，服务重启后队列信息不会丢失(但队列中的消息会丢失)。

　　3、exclusive：是否排他队列。排他队列只对首次声明它的连接(Connection)可见，当连接断开后自动删除(即使开启持久化也会删除)，多个连接不允许建立同名的排他队列。

　　4、autoDelete：是否自动删除。自动删除的前提是至少有一个消费者连接这个队列，当所有消费者与它断开连接后，会触发自动删除。

　　5、arguments：设置队列的一些其它参数。

　　不带任何参数的`queueDeclare()`方法默认创建一个由 RabbitMQ 命名的（类似这种 `amq.gen-**** `名称，这种队列称为匿名队列）、排他的、自动删除的、非持久化的队列。　

* ### 队列绑定交换器

　　可以在RabbitMQ可视化面板中绑定队列到交换器，也可以在Java代码中绑定：

```java
Queue.BindOk queueBind(String queue, String exchange, String routingKey, Map<String, Object> arguments)                            throws IOException;
```

　　这是Channel接口中的方法，它的4个参数含义如下：

　　1、queue：队列名称。

　　2、exchange：交换器名称。

　　3、routingkey：绑定键。

　　4、arguments：指定消息中需要携带的键值对。

## 四、发送消息

* ### basicPublish()

　　可以通过`basicPublish()`方法，经由交换器发送消息到队列中：

```java
void basicPublish(String exchange, String routingKey, boolean mandatory, boolean immediate, 
                  BasicProperties props, byte[] body) throws IOException;
```

　　这是Channel接口中的方法，它的6个参数含义如下：

　　1、exchange：交换器名称。

　　2、routingKey：路由键。

　　3、mandatory：如果将 mandatory 参数设为 true 时，交换器无法根据自身的类型和路由键找到一个符合条件的队列，那么 RabbitMQ 会调用 Basic.Return 命令将消息返回给生产者。当 mandatory 参数设置为 false 时，交换器无法根据自身的类型和路由键找到一个符合条件的队列，则消息直接被丢弃。

　　4、immediate：当 immediate 参数设为 true 时，如果交换器在将消息路由到队列时发现队列上并不存在任何消费者，那么这条消息将不会存入队列中。当与路由键匹配的所有队列都没有消费者时，该消息会通过 Basic .Return 返回至生产者。

　　5、props：消息的基本属性集，其包含 14 个属性成员，分别有 `contentType、contentEncoding、headers(Map<String,Object>)、deliveryMode、priority、correlationId、 replyTo、expiration、messageId、timestamp、type、userId、appId、clusterId`。

　　6、body：消息体。



　　生产者发送消息的案例：

```java
//1、消息头
HashMap<String, Object> headers = new HashMap<>();
headers.put("name","jack");
headers.put("age","18");

//2、消息体
String msg = "你好RabbitMQ！";

//3、消息的基本属性集
AMQP.BasicProperties basicProperties = new AMQP.BasicProperties().builder()
        .headers(headers) //设置消息头
        .contentType("text/plain") //设置消息类型
        .deliveryMode(2) //开启消息持久化
        .build();

//4、发送消息到交换器exchange1中绑定键与路由键key1相匹配的队列
channel.basicPublish("exchange1", "key1", false, false,
        basicProperties, msg.getBytes(StandardCharsets.UTF_8));
```

* ### 生产者确认

　　在使用消息队列的时候，我们会遇到一个问题：当消息的生产者将消息发送出去之后，消息到底有没有正确地被发送到服务器呢？RabbitMQ 针对上面问题，提供了两种解决方案：

　　1、通过事务机制实现；

　　2、通过发送方确认（Publisher Confirm）机制实现。

　　事务机制和发送方确认机制确保的是消息能够正确地发送至 RabbitMQ 服务器，**这里的“发送至 RabbitMQ” 的含义是指消息被正确地发往至 RabbitMQ 的交换器**，如果此交换器没有匹配的队列，那么消息也会丢失。所以在使用这两种机制的时候要确保所涉及的交换器能够有匹配的队列。更进一步地讲，**发送方要配合 mandatory 参数或者备份交换器一起使用来提高消息传输的可靠性**。

　　

　　**RabbitMQ事务**

　　RabbitMQ事务通过AMQP协议来保证消息可以被正确发送到服务器。一个典型的事务如下：

```java
public void sendMessage(String msg) {
    ...
    try{
        //1、将当前channel设置为事务模式
        channel.txSelect(); 
        //2、发送消息到服务器
        channel.basicPublish("exchange1","key1",null,msg.getBytes(StandardCharsets.UTF_8));
        //3、提交事务，如果提交成功，则消息一定会成功到达服务器
        channel.txCommit();
    }catch (Exception e){
        e.printStackTrace();
        //4、如果消息没有到达服务器，会抛出异常，事务回滚
        channel.txRollback();
        //5、重新发送消息
        sendMessage(msg);
    }
    ...
}
```

　　

　　**发送方确认**

　　事务机制在一条消息发送之后会使发送端阻塞，以等待 RabbitMQ 的回应，之后才能继续发送下一条消息。相比之下，**发送方确认机制最大的好处在于它可以实现异步确认**，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息。

　　先来看看发送方确认的同步实现：

```java
public void sendMessage(String msg) {
    try{
        //1、将信道设置为publisher confirm模式
        channel.confirmSelect();
        for(int i=0;i<100;i++){
            //2、发送消息到服务器
            channel.basicPublish("exchange1","key1",null,(msg+":"+i).getBytes(StandardCharsets.UTF_8));
            //3、等待服务器返回确认
            if(channel.waitForConfirms(1000)){ //1000表示超时时间，一旦等待超时就会抛出异常
                System.out.println("消息发送成功");
            }else{
                System.out.println("消息发送失败，正在重新发送");
                //4、如果服务器返回false，说明消息发送失败，需要重新发送
                sendMessage(msg);
            }
        }
    }catch (Exception e){
        e.printStackTrace();
        //5、如果捕获异常，说明消息发送失败，需要重新发送
        sendMessage(msg);
    }
}
```

　　如果使用这种方法，生产者每次只能确认一条消息，效率太低，我们可以把它改进为批量确认消息：

```java
for(int i=1;i<=100;i++){
    channel.basicPublish("exchange1","key1",null,msg.getBytes(StandardCharsets.UTF_8));
    //1、每发送20条消息确认一次
    if(i%20 == 0){
        if(channel.waitForConfirms(1000)){
            System.out.println("消息发送成功");
        }else{
            System.out.println("消息发送失败，正在重新发送");
            //2、如果服务器返回false，需要重新发送这20条消息，很可能会导致重复发送消息
            sendMessages(msgs);
        }
    }
}
```

　　上面的方法可能会导致重复发送消息，所以不建议使用。更好的方法是采用异步发送：

```java
try{
    //1、将信道设置为publisher confirm模式
    channel.confirmSelect();
    //2、创建未确认集合，用来存储未确认的消息，键是deliveryTag，值是消息体
    HashMap<Long, String> unConfirmMap = new HashMap<>();
    //3、添加监听器
    channel.addConfirmListener(new ConfirmListener() {
        //消息发送成功后返回确认，执行回调函数
        @Override
        public void handleAck(long deliveryTag, boolean multiple) throws IOException {
            System.out.println("deliveryTag="+deliveryTag+" multiple="+multiple);
            //multiple=true表示当前deliveryTag及之前的所有deliveryTag对应的消息都已成功确认
            if(multiple){
                //删除未确认集合中已经成功确认的消息
                Long[] deliveryTags = unConfirmMap.keySet().toArray(new Long[unConfirmMap.size()]);
                for(Long tag:deliveryTags){
                    if(tag<=deliveryTag){
                        unConfirmMap.remove(tag);
                    }
                }
            //multiple=false表示当前deliveryTag对应的消息成功确认
            }else {
                //删除未确认集合中已经成功确认的消息
                unConfirmMap.remove(deliveryTag);
            }
        }

        //消息发送失败后返回确认，执行回调函数
        @Override
        public void handleNack(long deliveryTag, boolean multiple) throws IOException {
            System.out.println("deliveryTag="+deliveryTag+" multiple="+multiple);
            //删除未确认集合中已经失败确认的消息(目前还不清楚如何确认)
            if(multiple){
            }else {
            }
            //重新发送消息
            sendMsgAgain(msgs);
        }
    });

    for(int i=0;i<100;i++){
        String msg = "msg:"+i;
        //4、RabbitMQ客户端会自动为每一条消息生成一个从1开始递增的整数作为消息序号(deliveryTag)
        long deliveryTag = channel.getNextPublishSeqNo();
        //5、将发送过但还未确认的消息暂存到未确认集合中，等待再次消费
        unConfirmMap.put(deliveryTag,msg);
        //6、异步发送消息
        channel.basicPublish("exchange1","key1",null,msg.getBytes(StandardCharsets.UTF_8));
    }
}catch (Exception e){
    e.printStackTrace();
    //重新发送消息
    sendMsgAgain(msgs);
}
```

## 五、消费消息

* ### basicConsume()方法

　　`basicConsume()`方法的作用是让RabbitMQ服务不断推送消息给消费者，并触发回调方法(Consumer 接口实现类)：

```java
String basicConsume(String queue, boolean autoAck, String consumerTag, boolean noLocal, boolean exclusive,                       Map<String, Object> arguments, Consumer callback) throws IOException;
```

　　这是Channel接口中的方法，它的7个参数含义如下：

　　1、queue：队列名称。

　　2、autoAck：是否自动确认消息。

　　3、consumerTag：消费者标签，用来对多个消费者进行区分。

　　4、noLocal：设置为 true 则表示不能将同一个 Connection（连接）中生产者发送的消息传送给这个 Connection 中的消费者。

　　5、exclusive：置是否排它，true 表示排它。

　　6、arguments：设置消费者的其他参数。

　　7、callback：设置消费者的回调方法（必须实现 Consumer 接口）。通常使用`DefaultConsumer`类，只需要重写它的`handleDelivery()`方法作为回调方法。

* ### 案例

```java
//1、创建回调方法
DefaultConsumer defaultConsumer = new DefaultConsumer(channel){
    @Override
    public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
        String msg = new String(body,"UTF-8");
        System.out.println("msg: "+msg); //打印消息
    }
};

//2、让RabbitMQ服务推送队列queue1中的消息给消费者，并触发回调方法
channel.basicConsume("queue1",true,"consumer1",false,false,null,defaultConsumer);
```

* ### 消息确认

　　RabbitMQ 为了保证消息从队列可靠地到达消费者，它提供了消息确认机制（Message Acknowledgement）。消费者在订阅队列时，可以指定 autoAck 参数，**当 autoAck 设置为 false，RabbitMQ 会等待消费者手动地回复 ACK 确认信号，当收到 ACK 确认信号后才将消息从消息队列移除（实际上是先打上删除标记，之后再删除），如果没收到确认信号，那么这条消息还会保留在队列中，但是只能被当前消费者消费，只有当前消费者断开连接后，这条消息才能被其它消费者消费**。当 autoAck 等于 true 时，RabbitMQ 会自动把发送出去的消息设置为确认，然后从队列中删除，而不管消费者是否真正地消费到这个消息。

　　在回调方法中手动确认消息：

```java
DefaultConsumer defaultConsumer = new DefaultConsumer(channel){
    @Override
    public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
        String msg = new String(body,"UTF-8");
        System.out.println("msg: "+msg);
        long deliveryTag = envelope.getDeliveryTag(); //deliveryTag等于小于当前
        channel.basicAck(deliveryTag,false); //false表示只确认这一条消息，true表示确认deliveryTag等于小于当前值的所有消息(批量确认)
    }
};
```

* ### 消息拒绝

　　假如我们不想消费某条消息，并且希望这条消息被其它消费者消费，这时消息确认就派不上用场了，因为如果一直不确认消息，并且当前消费者没有断开连接，那么这条消息是无法被其它消费者消费的。此时可以使用消息拒绝，**被拒绝的消息会被重新放回队列，等待被其它消费者消费，即使当前消费者没有断开连接**。

　　在回调方法中拒绝消息：

```java
DefaultConsumer defaultConsumer = new DefaultConsumer(channel){
    @Override
    public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
        String msg = new String(body,"UTF-8");
        System.out.println("msg: "+msg);
        long deliveryTag = envelope.getDeliveryTag();
        channel.basicReject(deliveryTag,true); //true表示被拒绝的消息会被重新放回队列，false表示被拒绝的消息会被删除
    }
};
channel.basicConsume("queue1",true,"consumer1",false,false,null,defaultConsumer); //关闭自动确认
```

　　`basicReject()`方法只能拒绝一条消息，如果要批量拒绝消息，可以使用`basicNack()`方法：

```java
//multiple为false时，表示只拒绝这一条消息，为true时表示拒绝deliveryTag等于小于当前值的所有消息(批量拒绝)
void basicNack(long deliveryTag, boolean multiple, boolean requeue)
        throws IOException; 
```

## 六、特殊队列

* ### 过期时间(TTL)

　　RabbitMQ 可以对消息和队列设置过期时间（TTL，全称 Time To Live）。目前有两种方法可以设置过期时间：

　　1、第一种方法是通过队列属性设置，队列中所有消息都有相同的过期时间。

```java
AMQP.BasicProperties properties = new AMQP.BasicProperties.Builder()
        .deliveryMode(2) // 持久化消息
        .expiration("10000") // 设置过期时间为 10 秒
        .build();
```

　　2、第二种方法是对消息进行单独设置，每条消息的过期时间可以不同。

```JAVA
Map<String,Object> argss =new HashMap<String,Object>() ;
argss.put("x-message-ttl", 10000); // 设置过期时间为 10 秒
channel.queueDeclare(QUEUE_NAME, true, false, true, argss) ;
```

　　如果同时设置队列和消息的过期时间，则消息的过期时间以两者之间过期时间较小的那个数值为准。**消息在队列的生存时间一旦超过设置的过期时间值，就成为“死信”（Dead Message），消费者将无法再收到该消息**。

* ### 死信队列(DLX)

　　RabbitMQ 中由于某些原因（如路由键和绑定键不匹配，或者交换器上面没有绑定队列等等）导致消息无法被正确的投递，**为了确保消息不会被无故的丢弃，一般将其置于一个特殊的队列中，这个队列一般称之为死信队列。**如果消息在一个队列中变成死信（Dead Message）之后，它将被重新发送到另一个交换器中，该交换器称为死信交换器，绑定在死信交换器上的队列就称之为死信队列，死信交换器的简称为 DLX（Dead-Letter-Exchange）。

　　消息变成死信有如下几种情况：

　　1、消息被拒绝（Basic.Reject/Basic.Nack），并且设置 requeue 参数为 false；

　　2、消息过期；

　　3、队列达到最大长度。



　　可以在RabbitMQ可视化面板中为一个普通队列设置死信队列，也可以在Java代码中设置：

```java
//1、声明死信交换器
channel.exchangeDeclare("exchange-dlx","fanout");
//2、声明死信队列
channel.queueDeclare("queue-dlx",true,false,false,null);
//3、绑定死信交换器和死信队列
channel.queueBind("queue-dlx","exchange-dlx","");

//4、为普通队列设置死信交换器
HashMap<String, Object> map = new HashMap<>();
map.put("x-dead-letter-exchange","exchange-dlx");
channel.queueDeclare("queue3",true,false,false,map);
```

* ### 延迟队列

　　延迟队列顾名思义就是存放延迟消息的队列，所谓“延迟消息”是指消息被发送后，并不想让消费者立刻进行消费，而是需要等待指定的时间后，消费者才能够进行消费。**通过死信交换器（DLX）和过期时间（TTL）可以实现延迟队列的功能**。思路是：消息生产者发送一个带有 TTL（延迟时间）的消息到正常的交换器，且正常交换器绑定的队列没有被任何消费者订阅（也就不会被消费）。当时间慢慢过去，一旦时间超过我们为消息设置的 TTL 时间后，RabbitMQ 将会自动将过期的消息发送到队列指定的死信交换器，死信交换器将消息路由到死信队列。此时，如果有消费者订阅了死信队列，则这些消息将被消费者消费，就这样成功模拟了一个延迟队列。



本文参考：

1、[RabbitMQ 教程](https://www.hxstrive.com/subject/rabbitmq.htm)
