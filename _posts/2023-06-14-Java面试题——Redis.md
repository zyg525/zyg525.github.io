---
title: Java面试题——Redis
tags: Java面试题
layout: post
---

## 基础

* ### 1、Redis为什么这么快？

　　1、Redis是**基于内存**的数据库。数据存放在内存中，操作数据时不需要进行磁盘IO。

　　2、Redis键值对的读取与写入是由**单线程**完成的，避免了线程上下文切换和锁竞争的消耗。

* ### 2、Redis有哪些数据结构？

　　Redis数据库中存放的是`key-value`键值对，`key`一般是string类型，`value`有五种常用的数据结构，分别是：`string、list、hash、set、zset`。

　　**1、string**：字符串类型。应用场景有缓存`JSON`格式的对象、生成唯一ID、缓存短信验证码等。

```shell
> set k v
> get k
```

　　**2、list**：列表类型，相当于一个**双向队列**。

```shell
> lpush k v1 v2 v3
> lpop k
```

　　**3、hash**：哈希类型，相当于一个**Map集合**，包含多个键值对，其中键不能重复。应用场景有缓存对象等。

```shell
> hmset k k1 v1 k2 v2 k3 v3
> hgetall k
```

　　**4、set**：集合类型，相当于一个**set集合**，集合中不能有重复的元素。

```shell
> sadd k v1 v2 v3
> smembers k
```

　　**5、zset**：有序集合类型，相当于**有序的set集合**，集合中不能有重复的元素，每个元素都关联了一个`score`，集合元素按照`score`升序排列。

```shell
> zadd k 1.1 v1 1.2 v2 1.3 v3
> zrange k 0 -1
```

* ### 3、介绍一下Redis事务

　　Redis事务和MySQL中的事务不同，它的目的是为了方便用户一次执行多条命令。**Redis中的多个事务是串行执行的，并且事务不支持回滚**。Redis事务之所以不支持回滚，是因为回滚会增加系统的复杂度。

## 缓存设计

* ### 1、怎样保证缓存和数据库的一致性？

　　我们无法实现缓存和数据库的完全一致性，只能尽可能满足。缓存的更新策略如下：

　　1、对于低一致性需求，可以使用Redis的**内存淘汰**策略，即当Redis内存不足时淘汰部分数据。

　　2、对于高一致性需求，应采取**缓存主动更新+超时剔除**的策略，主动更新指的是更新数据库的同时删除缓存，超时剔除指的是为缓存设置过期时间，然后在查询时重建缓存。

* ### 2、缓存主动更新策略有哪些要点？

　　1、**更新数据库时删除缓存**，而不是更新缓存，这样可以避免很多无效的更新操作。

　　2、保证更新数据库和删除缓存在**同一个事务**中。

　　3、应该**先更新数据库，再删除缓存**。原因是更新数据库比较耗时，如果先删除缓存再更新数据库，其它线程很容易读取到脏数据。

* ### 3、什么是缓存穿透、缓存击穿、缓存雪崩？

　　1、缓存穿透指的是**缓存和数据库中都不存在要查询的数据**，导致缓存无法重建，每次都请求到数据库中，造成压力。

　　2、缓存击穿指的是缓存中的某个key接收着大量的并发请求，一旦**这个key过期**，就会导致大量的并发请求进入数据库，造成压力。

　　3、缓存雪崩指的是缓存中**大量的key同时过期**，大量的并发请求进入数据库，造成压力。

* ### 4、缓存穿透、缓存击穿、缓存雪崩的解决方案是什么？

　　**解决缓存穿透**

　　1、为数据库中不存在的数据，在Redis中**缓存NULL值**，同时设置过期时间，提高缓存的一致性。

　　2、在用户和缓存之间增加**布隆过滤器**，缺点是实现复杂，存在误判可能。

　　**解决缓存击穿**

　　2、使用**互斥锁**，当key过期后，保证只有第一个线程可以查询数据库并重建缓存，其它线程阻塞，直至缓存重建完成。缺点是并发性太差。

　　3、设置热点数据永不过期，实际上是为缓存**设置逻辑过期时间**，当key逻辑过期后，第一个线程会新开一个线程，同时所有线程返回过期的缓存数据，新线程去查询数据库并重建缓存。

　　**解决缓存雪崩**

　　1、为缓存**设置随机过期时间**，避免大量缓存同时过期。

　　2、设置热点数据永不过期。

## 持久化

* ### 1、Redis的持久化方式有哪些？它们的区别是什么？

　　Redis的持久化方式包括`RDB`和`AOF`。

　　**RDB**

　　`RDB`是将当前进程数据生成快照保存到磁盘，它是**默认的持久化方式**，它会将数据保存到`dump.rdb`文件中。`RDB`可以手动触发，也可以自动触发。手动触发的命令是`save`和`bgsave`，前者会阻塞当前进程，后者会新开一个进程，不会阻塞当前进程。自动触发策略可以在`redis.conf`文件中进行配置，可以规定多少秒内、修改了几次数据就触发持久化。

　　**AOF**

　　`AOF`是将命令记录到日志文件中，默认是关闭的，需要在`redis.conf`文件中开启，`AOF`会将命令记录到`appendonly.aof`文件中。`AOF`的自动触发策略包括三种，分别是每执行一条命令就触发一次持久化、每隔一秒触发一次持久化(默认)、由操作系统决定何时持久化。当`AOF`文件越来越大时，可以对其进行重写，删除多余的命令，减小文件体积。

　　**区别**

　　1、`RDB`备份速度慢，`AOF`备份速度快；

　　2、`RDB`恢复速度快，`AOF`恢复速度慢；

　　3、当服务器宕机时，`RDB`可能会丢失较多数据，`AOF`最多丢失一秒的数据；

* ### 2、什么是混合持久化？

　　`RDB`和`AOF`混合使用，`AOF`只记录从`RDB`持久化开始到结束期间的命令，以此来提高`RDB`持久化的数据完整性，同时又大大减小了aof文件的体积。

## 集群

* ### 1、介绍一下Redis的主从模式

　　Redis的主节点和从节点分布在不同的服务器上，主节点负责写入数据，从节点负责读取数据，主节点会向从节点同步数据。主从同步的方式包括**全量复制和增量复制**，当从节点第一次同步数据时，是全量复制，之后就是增量复制。

* ### 2、介绍一下Redis的哨兵模式

　　哨兵模式是对主从模式的一种改进，在主从模式中，一旦主节点发生故障，需要手动将从节点切换为主节点，这个过程中服务不可用。哨兵集群会实时监控Redis集群中的主节点和从节点，一旦发现主节点不可用，就会自动选举出一个从节点作为主节点。

　　哨兵集群中的每个节点都会定时向Redis集群中的节点发送ping命令做心跳检测，当某个节点超时未响应，哨兵节点就会认为这个Redis节点不可用，这也叫**主观下线**。当主观下线的节点是主节点时，哨兵节点会询问其它哨兵节点对该主节点的判断，如果超过一定数量的哨兵节点都认为该主节点主观下线时，那么就认为该节点**客观下线**，此时会选举出一个新的主节点。