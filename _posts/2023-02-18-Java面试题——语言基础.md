---
title: Java面试题——语言基础&面向对象
tags: Java面试题
---

## 一、语言基础

* ### 如何理解Java的跨平台特性？

　　Java具有平台无关性。Java是解释型语言，编译器把Java代码编译成字节码，然后在`JVM`解释运行。字节码是跨平台的，而`JVM`是为各个平台分别开发的，这就是为什么Java可以实现“一次编写、多次运行”。

* ### JRE和JDK有什么区别？

　　`JRE`指的是Java运行环境，负责运行Java程序，它包括`JVM`和一些标准类库；

　　`JDK`指的是Java开发工具，供开发人员使用，它包括了`JRE`，同时还包括了编译器和调试器。

* ### Java数据类型有哪些？

　　数据类型分为基本数据类型和引用数据类型，基本数据类型有8种：`byte、short、int、long、float、double、char、boolean`，它们分别占`1、2、4、8、4、8、2、不确定`个字节。除了基本数据类型，剩下的类型都是引用数据类型。

## 二、面向对象

* ### 说说你对Java面向对象的理解？

　　面向对象，是一种将现实生活中的实体映射到计算机模型中的一种编程方法，对象中存储了程序和数据，对象之间通过相互作用传递信息，从而组成完整的程序设计。

　　面向对象的三大特征是：**封装、继承、多态**。

　　**封装**：将客观事物封装成抽象的类，类将自身的方法和变量隐藏起来，只让可信的对象进行操作。

　　**继承**：对象的新类可以从现有的类派生，派生类可以从它的基类中继承方法和成员变量，并且可以修改或者新增新的方法和成员变量，来增强基类的功能。

　　**多态**：多态的表面意思是一个事务的多种形态，在Java中指的是一个实例的相同方法在不同情况下有不同的实现。多态可以分为编译器多态和运行期多态，编译期多态指的是重载，即通过参数列表的不同来区分不同的方法，运行期多态指的是继承类和实现接口时，让父类引用指向子类实例。

* ### 介绍一下几种访问权限修饰符

　　访问权限从大到小依次是：

　　**public**：用来修饰外部类、类的属性。当修饰类的属性时，表示该属性可以在任何类中被访问到，可以被任何子类继承。

　　**protected**：用来修饰类的属性。表示该属性可以在同一个包的类中、所有子类中被访问到，可以被任何子类继承。

　　**缺省**：用来修饰外部类、类的属性。当修饰类的属性时，表示该属性可以在同一个包的类中被访问到，可以被同一个包内的子类继承。

　　**private**：用来修饰类的属性。表示该属性只能在本类中访问到。

　　当使用public和缺省来修饰一个外部类时，分别表示可以访问所有位置的该类、可以访问同一个包内的该类。

* ### 介绍一下this、super关键字

　　**this**：当`JVM`创建一个实例后，就会为该实例分配一个指向自己的引用，这个引用就是this，this只能在方法中使用。this的另一个作用是在一个构造方法中调用当前类的另一个构造方法，此时this语句应该位于构造方法中的第一行。

　　**super**：对于一个子类来说，它的实例中会持有一个父类的实例，super就是指向了父类实例的引用。super的另一个作用是在子类的构造方法中调用父类的构造方法，此时super语句应该位于构造方法中的第一行。当子类构造方法中没有显式地调用父类构造方法时，编译器会自动帮我们加上`super();`来调用父类的无参构造方法，如果父类没有无参构造方法，我们就必须显式地通过super调用父类的某个有参构造方法。

* ### 介绍一下final关键字

　　final关键字可以用来修饰类、方法、变量。

　　被final修饰的类不能被继承，被final修饰的方法不能被重写。被final修饰的变量，如果该变量是基本数据类型，那么初始化后它的值就不能再修改；如果该变量是引用类型，那么初始化后它的引用就不能再指向其它对象。

　　当final修饰成员变量时，不会为该变量分配默认值，必须在声明变量时赋值或在构造方法中为该变量赋值。

* ### 介绍一下static关键字

　　static可以用来修饰成员变量、成员方法、代码块、内部类。它的作用是为属性创建与实例无关的存储空间，使得该属性与类关联，而不是与实例关联。在不创建实例的情况下，可以直接通过`类名.静态属性名`的方式进行调用。当static修饰方法时，该方法中不能直接访问其它实例属性，比如实例变量、实例方法、super、this关键字等，只能通过实例去访问实例属性。**原因是当类被`JVM`加载后，静态属性就被分配了空间，此时实例属性还未被分配空间，自然无法访问**。

* ### 抽象类和接口的异同？

　　**抽象类的特点**：

　　1、除了可以定义抽象方法外，其它和普通类无异。抽象方法不能是private类型的。

　　**接口的特点**：

　　1、可以有成员变量和非抽象方法，但是成员变量一定是public static final类型的，非抽象方法一定是public default类型的，抽象方法一定是public abstract类型的。除了default关键字外，其它关键字都可以省略。

> **相同点**：
>
> 　　1、抽象类和接口都不能被实例化；
>
> 　　2、抽象类和接口中可以不定义抽象方法。
>
> 　　3、抽象类的子类和接口的实现类必须实现抽象方法。
>
> **不同点**：
>
> 　　1、抽象类体现的是is的关系，比如man is a person，此时person可以作为一个抽象类；而接口体现的是can的关系，比如plane和bird都能fly，此时fly可以作为一个接口，而plane和bird可以实现该接口；
>
> 　　2、一个类只可以继承一个抽象类，但是可以实现多个接口。

* ### 重载和重写的区别是什么？

　　**重载**：在一个类中，方法名相同、参数列表不同。

　　**重写**：子类和父类的方法名、参数列表相同。子类方法的返回值类型必须等于父类方法返回值类型或其子类，子类方法的的权限修饰符范围不能小于父类方法的权限修饰符，子类方法抛出的异常范围不能大于父类方法的异常范围。原因很简单：**为了保证向上转型能够通过编译**。

> 注意，静态方法不能被重写。

* ### 简述内部类及其作用

　　**非静态成员内部类**：可以把这种内部类看作是非静态的成员变量，它可以直接访问所在外部类的private属性，外部类也可以访问它的private属性。它的实例创建方式是：`外部类实例.new Inner()`。因为是非静态的，所以它不能定义静态属性，但是可以访问外部类的静态和非静态属性。

　　**静态成员内部类**：可以把这种内部类看作是静态的成员变量，它可以直接访问所在外部类的private static属性，外部类也可以访问它的private属性。它的实例创建方式是：`new 外部类类名.Inner()`。因为是静态的，所以它可以定义静态属性，但是不能访问外部类的非静态属性。

　　**局部内部类**：位于方法中的内部类，类似于局部变量，它没有访问权限修饰符。

　　**匿名内部类**：它的作用是实现接口，没有类名，只能使用一次。

* ### 创建实例时，代码的执行顺序是什么？

　　1、父类静态代码块、静态变量(静态代码块和静态变量按照声明顺序执行)；

　　2、子类静态代码块、静态变量；

　　3、父类局部代码块、成员变量(局部代码块和成员变量按照声明顺序执行)；

　　4、父类构造方法；

　　5、子类局部代码块、成员变量；

　　6、子类构造方法。

　　其中，静态代码块和静态变量只会在类加载的时候执行一次。

　　

