---
title: Spring框架之核心框架
categories: 四、Spring框架
tags: Spring框架
layout: post
---





## 一、IOC

### 基本概念

　　`IOC`全称`Inversion of Control`，直译为控制反转，意思是**将创建对象的操作权转交给Spring容器，对象的调用者无需使用new关键字手动创建对象**。在`IOC`没有出现之前，我们是通过new关键字创建对象的，这种方式的缺点是，当一个系统有大量的组件(即对象)，其生命周期和相互之间的依赖关系如果由组件自身来维护，不但大大增加了系统的复杂度，而且会导致组件之间极为紧密的耦合，继而给测试和维护带来了极大的困难。

　　在`IOC`模式下，控制权发生了反转，即从应用程序转移到了`IOC`容器，所有组件不再由应用程序自己创建和配置，而是由`IOC`容器负责，这样，应用程序只需要直接使用已经创建好并且配置好的组件。

### 简单使用

　　在Spring中使用`IOC`的步骤是：

　　1、创建一个Maven项目，导入Spring容器依赖

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>5.2.3.RELEASE</version>
</dependency>
```

　　2、创建Bean类，如果要使用setter方法注入属性，还要创建对应属性的setter方法和无参构造方法；如果要使用构造方法注入属性，还要创建对应属性的构造方法

```java
public class Teacher {
    private String name;
    private Student stu;
    public void setName(String name) {
        this.name = name;
    }
    public void setStu(Student student) {
        this.stu = student;
    }
}

public class Student {
    private String name;
    private int age;
    public Student() {}
    public Student(int age) {
        this.age = age;
    }
    
    public void setName(String name) {
        this.name = name;
    } 
}
```

　　3、在`classpath`路径下创建Bean的配置文件`application.xml`，在配置文件中约定Bean对象属性的注入方式

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="teacher" class="com.zyg.bean.Teacher">
        <property name="name" value="张三"/>
        <property name="stu" ref="student"/>
    </bean>

    <bean id="student" class="com.zyg.bean.Student">
        <!-- 使用setter方法注入name属性 -->
        <property name="name" value="tom"/>
        <!-- 使用构造方法注入age属性 -->
        <constructor-arg name="age" value="18"/>
    </bean>

</beans>
```

　　4、Spring容器会解析配置文件，并创建对象，我们只需要从容器中获取对象

```java
public static void main(String[] args) {
    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("application.xml");
    Student student = (Student) context.getBean("student");
    Teacher teacher = (Teacher) context.getBean("teacher");
}
```

### ApplicationContext和BeanFactory

　　`BeanFactory`是`IOC`的核心，它的作用是创建并管理对象，面向Spring底层；而`ApplicationContext`在`BeanFactory`的基础上增加了一些新的功能，面向开发者。

　　`ApplicationContext`和`BeanFactory`都可以用来创建对象：

```java
// 使用ApplicationContext创建对象
ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("application.xml");
Student student = (Student) context.getBean("student");

// 使用BeanFactory创建对象
BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource("application.xml"));
Student student = (Student) beanFactory.getBean("student");
```

　　**`ApplicationContext`和`BeanFactory`的区别是，前者在创建容器时就已经创建好了所有对象，而后者只有在调用`getBean()`方法后才会创建对象。**

### 依赖注入

　　依赖注入指的是创建对象时，为对象的属性赋值。Spring支持的依赖注入方式主要包括**`setter`方法注入和构造方法注入**。

　　使用`setter`方法注入时，需要保证属性有对应的`setter()`方法和无参构造方法，`IOC`容器会通过反射的方式，先调用无参构造方法生成实例，然后调用`setter()`方法注入属性。

　　使用构造方法注入时，需要保证属性有对应的构造方法，`IOC`容器会通过反射的方式，调用有参构造方法，在生成实例的同时注入属性。

### Bean的作用域

　　Spring中Bean的作用域分为`singleton`（单例模式，默认）和`prototype`（原型模式）。**在单例模式下，在同一个`IOC`容器中，同一类型的对象是唯一的，每次调用`getBean()`方法返回的都是同一个对象，而在原型模式下，在同一个`IOC`容器中，同一类型的对象不是唯一的，每次调用`getBean()`方法返回的都是新的对象。**

### 循环依赖

　　循环依赖指的是两个对象各自将对方作为自己的属性，或者一个对象将自身作为属性。Spring只支持单例模式下的循环依赖，不支持原型模式下的循环依赖，因为在原型模式下，每调用一次`getBean()`方法都会创建新的对象，对象之间的循环依赖会导致死循环。

　　Spring实际上是通过`setter`注入来实现循环依赖的，具体有两种情况：

　　1、假设对象A和B互相依赖，并且都使用`setter`方法注入属性。容器会首先创建A的实例，但不注入B属性，然后创建B的实例，注入A属性，最后A实例再注入B属性；

　　2、假设对象A和B互相依赖，A使用`setter`方法注入属性，B使用构造方法注入属性。容器会首先创建A的实例，但不注入B属性，然后创建B的实例同时注入A属性，最后A实例再注入B属性。

　　**总结：Spring通过`setter`实现循环依赖的原理是，`setter`注入方式可以把对象的实例化和注入属性两个步骤分离开。**

> warning "提醒"
>
> 在定义类时，最好不要出现循环依赖，避免不必要的麻烦。

### IOC注解

* #### @Component

　　标注在类上，`IOC`容器会创建并管理该类的实例。在SpringMVC项目中，有3个注解和`@Component`的作用相同，它们是`@Controller`、`@Service`、`@Repository`，分别位于controller、service、dao层。

　　使用`@Component`时，还可以指定对象的别名：

```java
@Component("stu")
public class Student {}
```

* #### @Scope

　　标注在类上，和`@Component`配合使用，用于指定对象是单例模式还是原型模式，默认是单例模式。

```java
@Component
@Scope("singleton")
public class Student {}

@Component
@Scope("prototype")
public class Student {}
```

* #### @Value

　　标注在字段上，用于基本类型和`String`类型的属性注入。

```java
@Component
public class Student {
    @Value("张三")
    private String name;
}
```

* #### @PropertySource

　　标注在类上，和`@Value`配合使用，用于将配置类中的属性注入实例。

```java
@Component
@PropertySource("config.properties")
public class Student {
    @Value("${stu.name}")
    private String name;
}
```

* #### @Autowired

　　标注在字段上，用于引用类型的属性自动注入。默认按照类型注入，也可以搭配`@Qualifier`按照名称注入。

```java
@Component
public class Teacher {
    // 按照名称注入
    @Autowired
    @Qualifier("stu")
    private Student student;
}
```

* #### @Resource

　　标注在字段上，和`@Autowired`+`@Qualifier`的效果一样，按照名称注入。不同的是，`@Resource`是JDK提供的注解。

```java
@Component
public class Teacher {
    // 按照名称注入
    @Resource("stu")
    private Student student;
}
```

* #### @Configuration

　　标注在类上，用于声明该类是配置类。通过配置类可以获取容器、创建对象。

```java
@Configuration
public class MyConfig {...}
```

* #### @Bean

　　标注在配置类中的方法上，用于创建对象，然后交给`IOC`容器管理。方法返回值就是对象，方法名是对象的默认名称，当然也可以指定别名。`@Bean`通常用来创建不在我们管辖范围内的类的对象。

```java
@Configuration
public class MyConfig {
    @Bean("stu")
    Student student() {
        return new Student();
    }
}
```

* #### @ComponentScan

　　标注在类上，默认用于扫描类所在目录和所有子目录中标注了`@Component`的Bean，也可以扫描指定目录下的Bean。

```java
@ComponentScan
public class Main {
    public static void main(String[] args) {
        // 创建IOC容器并扫描Main类所在目录和所有子目录中标注了@Component的Bean，然后创建它们的实例
        ApplicationContext context = new AnnotationConfigApplicationContext(Main.class);
        Student student = context.getBean(Student.class);
    }
}
```

