---
title: Spring框架之核心框架
categories: 四、Spring框架
tags: Spring框架
layout: post
---





## 一、IOC

### 基本概念

　　`IOC`全称`Inversion of Control`，直译为控制反转，意思是**将创建对象的操作权转交给Spring容器，对象的调用者无需使用new关键字手动创建对象**。在`IOC`没有出现之前，我们是通过new关键字创建对象的，这种方式的缺点是，当一个系统有大量的组件(即对象)，其生命周期和相互之间的依赖关系如果由组件自身来维护，不但大大增加了系统的复杂度，而且会导致组件之间极为紧密的耦合，继而给测试和维护带来了极大的困难。

　　在`IOC`模式下，控制权发生了反转，即从应用程序转移到了`IOC`容器，所有组件不再由应用程序自己创建和配置，而是由`IOC`容器负责，这样，应用程序只需要直接使用已经创建好并且配置好的组件。

### 简单使用

　　在Spring中使用`IOC`的步骤是：

　　1、创建一个Maven项目，导入Spring容器依赖

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>5.2.3.RELEASE</version>
</dependency>
```

　　2、创建Bean类，如果要使用setter方法注入属性，还要创建对应属性的setter方法和无参构造方法；如果要使用构造方法注入属性，还要创建对应属性的构造方法

```java
public class Teacher {
    private String name;
    private Student stu;
    public void setName(String name) {
        this.name = name;
    }
    public void setStu(Student student) {
        this.stu = student;
    }
}

public class Student {
    private String name;
    private int age;
    public Student() {}
    public Student(int age) {
        this.age = age;
    }
    
    public void setName(String name) {
        this.name = name;
    } 
}
```

　　3、在`classpath`路径下创建Bean的配置文件`application.xml`，在配置文件中约定Bean对象属性的注入方式

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="teacher" class="com.zyg.bean.Teacher">
        <property name="name" value="张三"/>
        <property name="stu" ref="student"/>
    </bean>

    <bean id="student" class="com.zyg.bean.Student">
        <!-- 使用setter方法注入name属性 -->
        <property name="name" value="tom"/>
        <!-- 使用构造方法注入age属性 -->
        <constructor-arg name="age" value="18"/>
    </bean>

</beans>
```

　　4、Spring容器会解析配置文件，并创建对象，我们只需要从容器中获取对象

```java
public static void main(String[] args) {
    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("application.xml");
    Student student = (Student) context.getBean("student");
    Teacher teacher = (Teacher) context.getBean("teacher");
}
```

### ApplicationContext和BeanFactory

　　`BeanFactory`是`IOC`的核心，它的作用是创建并管理对象，面向Spring底层；而`ApplicationContext`在`BeanFactory`的基础上增加了一些新的功能，面向开发者。

　　`ApplicationContext`和`BeanFactory`都可以用来创建对象：

```java
// 使用ApplicationContext创建对象
ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("application.xml");
Student student = (Student) context.getBean("student");

// 使用BeanFactory创建对象
BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource("application.xml"));
Student student = (Student) beanFactory.getBean("student");
```

　　**`ApplicationContext`和`BeanFactory`的区别是，前者在创建容器时就已经创建好了所有对象，而后者只有在调用`getBean()`方法后才会创建对象。**

### 依赖注入

　　依赖注入指的是创建对象时，为对象的属性赋值。Spring支持的依赖注入方式主要包括**`setter`方法注入和构造方法注入**。

　　使用`setter`方法注入时，需要保证属性有对应的`setter()`方法和无参构造方法，`IOC`容器会通过反射的方式，先调用无参构造方法生成实例，然后调用`setter()`方法注入属性。

　　使用构造方法注入时，需要保证属性有对应的构造方法，`IOC`容器会通过反射的方式，调用有参构造方法，在生成实例的同时注入属性。

### Bean的作用域

　　Spring中Bean的作用域分为`singleton`（单例模式，默认）和`prototype`（原型模式）。**在单例模式下，在同一个`IOC`容器中，同一类型的对象是唯一的，每次调用`getBean()`方法返回的都是同一个对象，而在原型模式下，在同一个`IOC`容器中，同一类型的对象不是唯一的，每次调用`getBean()`方法返回的都是新的对象。**

### 循环依赖

　　循环依赖指的是两个对象各自将对方作为自己的属性，或者一个对象将自身作为属性。Spring只支持单例模式下的循环依赖，不支持原型模式下的循环依赖，因为在原型模式下，每调用一次`getBean()`方法都会创建新的对象，对象之间的循环依赖会导致死循环。

　　Spring实际上是通过`setter`注入来实现循环依赖的，具体有两种情况：

　　1、假设对象A和B互相依赖，并且都使用`setter`方法注入属性。容器会首先创建A的实例，但不注入B属性，然后创建B的实例，注入A属性，最后A实例再注入B属性；

　　2、假设对象A和B互相依赖，A使用`setter`方法注入属性，B使用构造方法注入属性。容器会首先创建A的实例，但不注入B属性，然后创建B的实例同时注入A属性，最后A实例再注入B属性。

　　**总结：Spring通过`setter`实现循环依赖的原理是，`setter`注入方式可以把对象的实例化和注入属性两个步骤分离开。**

> warning "提醒"
>
> 在定义类时，最好不要出现循环依赖，避免不必要的麻烦。

### IOC注解

* #### @Component

　　标注在类上，`IOC`容器会创建并管理该类的实例。在SpringMVC项目中，有3个注解和`@Component`的作用相同，它们是`@Controller`、`@Service`、`@Repository`，分别位于controller、service、dao层。

　　使用`@Component`时，还可以指定对象的别名：

```java
@Component("stu")
public class Student {}
```

* #### @Scope

　　标注在类上，和`@Component`配合使用，用于指定对象是单例模式还是原型模式，默认是单例模式。

```java
@Component
@Scope("singleton")
public class Student {}

@Component
@Scope("prototype")
public class Student {}
```

* #### @Value

　　标注在字段上，用于基本类型和`String`类型的属性注入。

```java
@Component
public class Student {
    @Value("张三")
    private String name;
}
```

* #### @PropertySource

　　标注在类上，和`@Value`配合使用，用于将配置类中的属性注入实例。

```java
@Component
@PropertySource("config.properties")
public class Student {
    @Value("${stu.name}")
    private String name;
}
```

* #### @Autowired

　　标注在字段上，用于引用类型的属性自动注入。默认按照类型注入，也可以搭配`@Qualifier`按照名称注入。

```java
@Component
public class Teacher {
    // 按照名称注入
    @Autowired
    @Qualifier("stu")
    private Student student;
}
```

* #### @Resource

　　标注在字段上，和`@Autowired`+`@Qualifier`的效果一样，按照名称注入。不同的是，`@Resource`是JDK提供的注解。

```java
@Component
public class Teacher {
    // 按照名称注入
    @Resource("stu")
    private Student student;
}
```

* #### @Configuration

　　标注在类上，用于声明该类是配置类。通过配置类可以获取容器、创建对象。

```java
@Configuration
public class MyConfig {...}
```

* #### @Bean

　　标注在配置类中的方法上，用于创建对象，然后交给`IOC`容器管理。方法返回值就是对象，方法名是对象的默认名称，当然也可以指定别名。`@Bean`通常用来创建不在我们管辖范围内的类的对象。

```java
@Configuration
public class MyConfig {
    @Bean("stu")
    Student student() {
        return new Student();
    }
}
```

* #### @ComponentScan

　　标注在类上，默认用于扫描类所在目录和所有子目录中标注了`@Component`的Bean，也可以扫描指定目录下的Bean。

```java
@ComponentScan
public class Main {
    public static void main(String[] args) {
        // 创建IOC容器并扫描Main类所在目录和所有子目录中标注了@Component的Bean，然后创建它们的实例
        ApplicationContext context = new AnnotationConfigApplicationContext(Main.class);
        Student student = context.getBean(Student.class);
    }
}
```

## 二、AOP

### 基本概念

　　AOP(Aspect Oriented Programming，面向切面编程)，指的是把业务逻辑中一些相同的代码抽取到独立的模块中，比如日志和数据校验。AOP减少了代码量，降低了业务逻辑和通用逻辑之间的耦合性，让业务逻辑变得更加清晰。

### AOP通知的简单使用

　　在Spring中使用AOP来为目标方法增加通知的步骤如下：

　　1、添加AspectJ依赖，这样就可以使用它的AOP注解

```xml
<dependency>
  <groupId>org.springframework</groupId>
  <artifactId>spring-aspects</artifactId>
  <version>5.2.3.RELEASE</version>
</dependency>
```

　　2、创建被代理接口，并在其实现类中创建目标方法

```java
public interface Person {
    void play();
}

@Component
public class PersonImpl implements Person {
    // 目标方法
    public void play() {
        System.out.println("person is playing game");
    }
}
```

　　3、创建切面类，里面定义了各种通知方法

```java
@Component
@Aspect
public class LoggingAspect {

    @Before("execution(public * com.zyg.bean.PersonImpl.play(..))")
    void logBefore() {
        System.out.println("前置通知");
    }

    @After("execution(public * com.zyg.bean.PersonImpl.play(..))")
    void logAfter() {
        System.out.println("后置通知");
    }

    @Around("execution(public * com.zyg.bean.PersonImpl.play(..))")
    void logAround(ProceedingJoinPoint pj) throws Throwable {
        System.out.println("环绕通知-前");
        pj.proceed();
        System.out.println("环绕通知-后");
    }

    @AfterReturning("execution(public * com.zyg.bean.PersonImpl.play(..))")
    void logAfterReturn() {
        System.out.println("返回后通知");
    }

    @AfterThrowing("execution(public * com.zyg.bean.PersonImpl.play(..))")
    void logAfterThrow() {
        System.out.println("异常通知");
    }
}
```

　　4、在配置类上开启AOP

```java
@Configuration
@ComponentScan
@EnableAspectJAutoProxy
public class MyConfig {
}
```

　　5、调用目标方法

```java
public static void main(String[] args) throws Exception {
    ApplicationContext context = new AnnotationConfigApplicationContext(MyConfig.class);
    Person person = context.getBean(Person.class);
    person.play();
}

打印结果：
环绕通知-前
前置通知
person is playing game
环绕通知-后
后置通知
返回后通知
```

### AOP的原理

　　AOP的底层原理是动态代理，包括JDK动态代理和CGLIB动态代理。由于JDK动态代理是基于接口的代理，因此要求目标方法必须实现接口，而CGLIB动态代理没有这个限制。可以在启动AOP时设置动态代理的类型：

```java
// 使用CGLIB动态代理
@EnableAspectJAutoProxy(proxyTargetClass = true)
public class MyConfig {
}

// 使用JDK动态代理，默认方式
@EnableAspectJAutoProxy(proxyTargetClass = false)
public class MyConfig {
}
```

　　动态代理指的是JVM会在程序运行期间动态地为目标类生成代理类的字节码，在AOP通知中，Spring会首先扫描切面类和通知方法，然后为目标类生成代理类，并在代理方法中对目标方法进行增强，比如在执行目标方法的前后执行各种通知方法。

> info "提示"
>
> JDK动态代理基于接口，生成的代理类实现了被代理接口；CGLIB动态代理基于类，生成的代理类继承了被代理类。

### AOP通知的简化

　　在`简单使用`一节中，我们使用了`execution`表达式来寻找被代理方法，这种写法比较复杂，更简单的写法是通过注解来标注被代理方法：

```java
// 自定义一个简单的注解类
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface MyLog {
    String value() default "";
}

@Component
public class PersonImpl implements Person {
    // 在被代理方法上使用注解
    @MyLog
    public void play() {
        System.out.println("person is playing game");
    }
}

@Component
@Aspect
public class LoggingAspect {
    // 通知会织入到使用了@MyLog注解的方法上
    @Before("@annotation(myLog)")
    void logBefore(MyLog myLog) {
        System.out.println("前置通知");
    }
}
```

### 声明式事务

* #### 简单使用

　　Spring中使用声明式数据库事务的步骤如下：

　　1、添加数据库驱动、数据库连接池的依赖

```xml
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>5.1.49</version>
</dependency>
<dependency>
    <groupId>com.zaxxer</groupId>
    <artifactId>HikariCP</artifactId>
    <version>2.7.1</version>
</dependency>
```

　　2、创建JDBC的配置类，并开启数据库事务

```java
@Configuration
@PropertySource("jdbc.properties")
// 开启事务
@EnableTransactionManagement
public class JdbcConfig {
    @Value("${jdbc.url}")
    private String jdbcUrl;

    @Value("${jdbc.username}")
    private String jdbcUserName;

    @Value("${jdbc.password}")
    private String jdbcPassWord;

    @Bean
    DataSource dataSource() {
        HikariConfig hikariConfig = new HikariConfig();
        hikariConfig.setJdbcUrl(jdbcUrl);
        hikariConfig.setUsername(jdbcUserName);
        hikariConfig.setPassword(jdbcPassWord);
        hikariConfig.setAutoCommit(true);
        hikariConfig.setIdleTimeout(60);
        return new HikariDataSource(hikariConfig);
    }

    @Bean
    JdbcTemplate jdbcTemplate(@Autowired DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }

    @Bean
    PlatformTransactionManager platformTransactionManager(@Autowired DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }
}
```

　　3、为方法开启事务，当方法中抛出异常时，方法中所有的数据库操作全部回滚

```java
@Repository
public class StudentDaoImpl implements StudentDao {
    @Autowired
    JdbcTemplate jdbcTemplate;

    @Transactional("platformTransactionManager")
    @Override
    public int updateStudent() {
        String sql1 = "UPDATE t_student SET age = 18 WHERE id = 1";
        jdbcTemplate.update(sql1);

        int a = 1/0;

        String sql2 = "UPDATE t_student SET age = 19 WHERE id = 2";
        jdbcTemplate.update(sql2);
        return 0;
    }
}
```

* #### 原理

　　Spring的声明式数据库事务原理也是AOP，Spring会为事务方法所在类创建代理类，并对事务方法进行增强，在执行事务方法之前，会关闭数据库的自动提交，如果事务执行的过程中发生异常，就对过程中数据库的所有操作进行回滚，如果没有发生异常，才会提交事务。

* #### 事务的传播行为

　　事务的传播行为指的是处于不同事务中的方法在相互调用时，执行期间事务的维护情况。Spring中事务存在7种传播行为，默认的传播行为是`REQUIRED `，即如果当前没有事务，则创建新的事务，如果有事务，则加入当前事务。

　　在方法上配置事务的传播行为：

```java
@Transactional(propagation = Propagation.REQUIRED)
public int updateStudent() {...}
```

* #### 指定回滚异常

　　可以指定事务在抛出哪些异常后进行回滚，默认异常是`RuntimeException`：

```java
@Transactional(rollbackFor = {RuntimeException.class, IOException.class})
public int updateStudent() {...}
```

　　建议让业务异常体系从`RuntimeException`派生，这样可以不用声明特殊异常就可以让事务生效。

* #### 事务失效的场景

　　Spring数据库事务失效的场景包括：

　　1、事务不支持非public方法、static方法；

　　2、必须调用代理对象中的代理方法，事务才会生效，比如：

```java
// 事务不生效，原因是m1()不是事务方法，因此不会生成它的代理方法
@Component
public class MyService{
    public void m1(){
        m2();
    }
 
    @Transactional
    public void m2(){
        ...
    }
}

// 事务生效
@Component
public class MyService{
    
    @Transactional
    public void m1(){
        myService.m2();
    }
 
    @Transactional
    public void m2(){
        ...
    }
}
```

　　3、事务的传播行为或者声明异常配置错误。
