---
title: 计算机组成原理学习笔记
categories: 一、计算机基础
tags: 计算机基础
layout: post
---



## 一、概论

### 计算机的层次

　　计算机程序的执行层次：

　　**虚拟机器M4**(将高级语言翻译成汇编语言) -> **虚拟机器M3**(将汇编语言翻译成机器语言) -> **操作系统** -> **传统机器M2**(用微程序解释机器指令) -> **微程序机器M1**(用硬件直接执行微指令)。

　　

　　**虚拟机器**：是将高级语言翻译成低级语言的程序，给人的感觉就像是一台翻译机器。

　　**汇编语言**：是比机器语言更高一级的语言，它的每一条指令都与机器语言的某一条语句一一对应，因此汇编语言摆脱不了实际机器的指令系统，没有通用性。

　　**编译程序与解释程序**：这两者都是将高级语言翻译成机器语言的程序，区别在于编译程序是先将高级语言的全部语句一次都翻译成机器语言，再执行机器语言，而解释程序是每翻译一条，就执行一条，即使下一次重复执行该语句时，也要重新翻译。

### 计算机的组成

　　**冯诺依曼计算机**的主要特点：

　　1、计算机由**运算器、控制器、存储器、IO设备**组成；

　　2、指令和数据以同等地位存放于存储器内，并可按地址寻访；

　　3、指令由操作码和地址码组成，操作码代表操作的性质，地址码代表操作数在存储器中的位置；

　　4、指令在存储器中按顺序存放，通常指令是顺序执行的，在特定条件下可以改变执行顺序。

　　

　　**运算器**：由**ALU**(Arithmetic Logic Unit，算数逻辑单元)、**ACC**(Accumulator，累加器)、**MQ**(Multiplier-Quotient Register，乘商寄存器)、**X**(操作数寄存器)组成。运算器的功能是完成算术与逻辑运算，并暂存中间结果。

　　**控制器**：由**CU**(控制单元)、**PC**(Program Counter，程序计数器)、**IR**(Instruction Register，指令寄存器)组成。控制器的功能是控制程序和数据的输入、运行、处理计算结果。

　　**CPU**：运算器和控制器往往集成在一个芯片上， 因此统称为CPU(中央处理器)。

　　**存储器**：存储器分为主存储器和辅助存储器，主存储器就是内存，辅助存储器就是磁盘，主存储器可以直接和CPU交换信息。

　　**IO设备**：输入设备用来把用户输入信息转换为机器能识别的信息，常见的有鼠标、键盘；输出设备用来把机器运算结果转换为人类熟知的信息形式，常见的有打印机、显示器。

　　现代计算器的三大组成部分就是**CPU+主存储器+IO设备**。

### 计算机的工作步骤

![计算机的组成](/assets/img/java/计算机的组成.png)

　　几个重要原件的介绍：

　　**存储体M**：存储体由很多**存储单元**组成，每个存储单元又包含若干个**存储元**，每个存储元只能存放一位0或1，因此每个存储单元可以存放一串二进制代码，二进制代码的位数叫做**存储字长**。主存的工作方式是按照存储单元的地址来实现对存储字各位的读、写，这种方式叫做按地址访问存储器，简称**访存**。

　　**MAR**：Memory Address Register，存储器地址寄存器，它用来存放欲访问的存储单元的地址，它的容量等于存储单元的数量。

　　**MDR**：Memory Data Register，存储器数据寄存器，它用来存放从存储单元中取出的代码或准备往存储单元中存入的代码，它的容量等于单个存储单元的容量。

　　**PC**：程序计数器，它用来存放当前欲执行指令的地址。

　　**IR**：指令寄存器，它用来存放当前的指令。

　　　　

　　计算机计算`a*x`的步骤如下：

　　1、存储体M中存放着计算`a*x`的两条程序指令：取a的值、乘以x的值，同时也存放着a和x的值；

　　2、PC中存放着第一条程序指令(即“取a的值”)的地址0，CU将PC中的指令地址发送到MAR，然后命令主存读取地址0对应的程序指令，并存入MDR，再由MDR送入IR，**此时第一个取指令的操作完成**；

　　3、CU分析IR中的指令，得到指令码(即“读操作”)和地址码(即“a”的地址)，由于是读操作，于是把地址码发送给MAR，并命令主存读取地址码对应的“a的值”，存入MDR，再由MDR送往ACC，**此时执行读数指令的操作完成**；

　　4、PC中的值自动加1，CU将新的指令地址1发送到MAR，然后命令主存读取对应的指令，先后存入MDR和IR，**此时第二个取指令的操作完成**；

　　5、CU分析IR中的指令，得到指令码(即“乘法操作”)和地址码(即“x”的地址)，于是把地址码发送给MAR，并命令主存读取地址码对应的“x的值”，先后存入MDR和MQ，然后向运算器发出乘法操作命令，完成`a*x`的计算，并把计算结果存放在ACC中，**此时执行乘法指令的操作完成**；

　　6、如果还有更多的指令，PC会继续加1，以此类推，逐条取指、分析、执行，直至打印出结果。最后执行完停机指令后就自动关机。

　　

　　什么是机器字长？

　　**机器字长**是指CPU一次能处理数据的位数，通常等于存储单元的位数(也就等于寄存器的位数)。

## 二、存储器

### 存储器的分类

　　按照存储介质分类，主要分为**半导体器件、磁性材料和光盘**等，其中半导体材料断电后所存信息也会立即消失，是一种易失性存储器。

　　按照存取方式分类，主要分为**随机存储器(Random Access Memory，RAM)、只读存储器(Read Only Memory，ROM)、串行访问存储器**。RAM的特点是任何一个存储单元的内容都可以随机存取，存取时间与存储单元的物理位置无关，主存都采用这种存储器；ROM的特点是只能读取、不能写入，通常用来存放固定不变的程序或数据；串行访问存储器的特点是在对存储单元进行访问时，需要按照物理位置的先后顺序来寻找地址，存储单位的位置不同，访问所需时间也不同，例如磁盘就是部分串行访问的存储器，在访问存储单元时，先直接指出存储器中的某个小区域(磁道)，然后再顺序寻访，故前段是直接访问，后段是串行访问。

　　按照在计算机中的作用分类，分为**主存储器、辅助存储器、缓冲存储器**。

### 存储器的层次结构

![存储器的层次](/assets/img/java/存储器的层次.png)

　　缓存-主存层次主要解决CPU和主存速度不匹配的问题，主存-辅存层次主要解决存储系统的容量问题。

### 高速缓冲存储器

　　缓存的作用：

　　由于CPU的运行速度比主存的读写速度快，为了减少CPU的等待时间，可以在CPU和主存之间加入**缓存(Cache)**，将CPU需要的数据提前写入缓存，避免了等待。由于指令和数据在主存中是连续存放的，并且有些指令和数据会多次调用，所以指令和数据在主存中的分布不是随机的，而是相对的聚簇，使得CPU在执行程序时，**访存具有相对的局部性，这称为程序访问的局部性原理**，根据这一原理，只要将CPU近期需要用到的程序和数据提前从主存送到缓存，就可以做到CPU在一定时间内只访问缓存。

　　缓存的工作原理：

　　**1、地址映射**：缓存容量小于主存，二者之间存在映射，将缓存和主存分成若干大小相同的块，缓存中的每个块对应主存中的多个块，缓存中的每个块都有一个标记，用来表示当前存放的是哪一个主存块。CPU读取数据时，会将目标数据在主存中的块地址与缓存块标记进行比较，以判断要读取的数据是否已经在缓存中。如果相同，说明缓存命中，直接从缓存中读取数据即可，如果不同，说明缓存未命中，此时要从主存读取数据，并写入缓存。如果此时缓存已满，就需要进行替换。

　　**2、替换机构**：缓存已满时，就由缓存中的替换机构按照一定的替换算法来确定移出哪个块返回主存，把新的主存块调入缓存。常用替换算法有先进先出、近期最少使用、随机等。

　　**3、缓存一致**：为了保证缓存与主存数据的一致性，主要采用两种方法，分别是写直达法和写回法。写直达法是指写操作时既写入缓存也写入主存，缺点是写入时间等于写入主存时间，增加了写入次数，降低了写入速度；写回法是指写操作时只写入缓存，只有当数据被替换时才写入主存，缓存块会增加一个标志，标志为“清”表示缓存块未被修改过，标志为“浊”表示缓存块被修改过，替换时只把标记为“浊”的缓存块写回主存。缓存与主存的一致性非常重要。

　　**两级缓存**：

　　随着集成电路逻辑密度的提高，会把CPU和缓存制作在一个芯片内，称为片内缓存，片内缓存虽然可以减少对外部总线的占用，但是容量小，此时就需要加入一个片外缓存，使用独立的数据路径连接片内缓存与主存。这就是两级缓存，片内缓存称为第一级缓存，片外缓存称为第二级缓存。

## 三、计算机的计算方法

### 无符号数和有符号数

　　真值和机器数：

　　**真值**：带`+、-`符号的数。

　　**机器数**：把符号数字化的数称为机器数。

　　

　　**原码表示法**

　　原码是机器数中最简单的一种表示形式，它用1代替`-`，用0代替`+`。为了便于区分，约定整数的符号位与数值位之间用逗号隔开，小数的符号位和数值位用小数点隔开。比如真值`+10`的原码是`0,10`，真值`-0.11`的原码是`1.11`。

　　整数原码的定义是

![整数原码定义](/assets/img/java/整数原码定义.png)

　　小数原码的定义是

![小数原码定义](/assets/img/java/小数原码定义.png)

　　(其中x为真值，n为位数)

　　原码简单明了，容易和真值转换，但是不利于加减运算。

　　

　　**补码表示法**

　　整数补码的定义是

![整数补码定义](/assets/img/java/整数补码定义.png)

　　小数补码的定义是

![小数补码定义](/assets/img/java/小数补码定义.png)

　　(其中x为真值，n为位数)

　　

　　可以发现，正数的补码等于原码，而对于负数，由原码求补码的快捷操作是：除了符号位外，每位取反，然后末位加1，简称**“求反加1”**，由补码求反码也一样。

　　假设真值是y，不论它是正负，由`[y]补`求`[-y]补`的方法是：连同符号位每位取反，末位加1。

　

　　**反码表示法**

　　反码是原码与补码互相转换时的中间过渡。

　　整数反码的定义是

![整数反码定义](/assets/img/java/整数反码定义.png)

　　小数反码的定义是

![小数反码定义](/assets/img/java/小数反码定义.png)

　　(其中x为真值，n为位数)

　　

　　**原码、补码、反码的特点**

　　1、最高位都是符号位，符号位和数值位之间用`,`(整数)或`.`(小数)隔开；

　　2、当真值为正时，原码、补码、反码相同，符号位为0，数值为和真值相同；

　　3、当真值为负时，原码、补码、反码不同，但符号位都是1，数值部分的关系是：补码是原码的求反加1，反码是原码的求反；

　　4、在原码和反码中，`0000`代表`+0`，`1000`代表`-0`，而在补码中，`0000`代表`+0`和`-0`，`1000`代表`-8`。即由于“零”在补码中只有一种表现形式，所以补码比原码和反码可以多表示一个负数。

　

　　**移码表示法**

　　移码的定义是

![移码定义](/assets/img/java/移码定义.png)

　　(其中x为真值，n为位数)

　　其实移码就是在真值上加上一个`2^n`，通过移码可以很容易地比较真值的大小。进一步观察，移码和补码仅差一个符号位，若将补码的符号位取反，即可得到该真值的移码。

### 数的定点表示和浮点表示

　　定义：

　　小数点固定在某一位置的数为定点数，采用定点数的机器叫做定点机。浮点数即小数点的位置可以浮动的数，通常，浮点数被表示成：

![浮点数的定义](/assets/img/java/浮点数的定义.png)

　　其中，S为尾数，j为阶码，r是基数，在计算机中，基数可以取2、4、8、16等。在计算机中规定尾数必须是纯小数，而为了让浮点数的精度最高，尾数的最高位还必须是1，这种浮点数称为**规格化数**。

　

　　**浮点数的表示形式与表示范围**

　　浮点数的表示形式：

![浮点数的表示形式](/assets/img/java/浮点数的表示形式.png)

　　阶码由阶符与阶码的数值部分组成，它反映了浮点数的表示范围与小数点的实际位置，尾数由数符与尾数的数值部分组成，它反映了浮点数的精度。

　　浮点数的表示范围：

![浮点数的表示范围](/assets/img/java/浮点数的表示范围.png)

　　由于浮点数的基数不可能为0，因此浮点数只能无限趋近于0而不能等于0。当浮点数阶码大于最大阶码时，称为**上溢**，此时机器停止运算；当浮点数阶码小于最小阶码时，称为**下溢**，此时溢出的绝对值很小，通常将尾数各位强置为0，按机器零处理，此时机器可以继续运行。

　

　　**浮点数的规格化**

　　为了提高浮点数的精度，其尾数必须是规格化数，如果不是，就需要通过修改阶码并同时左右移动尾数的方法，使其变成规格化数，这个过程就叫做规格化。对于基数不同的浮点数，因其规格化数的形式不同，规格化过程也不同。

　　当基数为2时，尾数最高位为1的数为规格化数。规格化时，尾数左移一位，阶码减1，尾数右移一位，阶码加1。

　　当基数为4时，尾数最高两位不全为0的数为规格化数。规格化时，尾数左移两位，阶码减1，尾数右移两位，阶码加1。

　　当基数为8时，尾数最高三位不全为0的数为规格化数。规格化时，尾数左移三位，阶码减1，尾数右移三位，阶码加1。

　　基数对浮点数的范围和精度有影响，**基数越大，浮点数的范围越大，但是精度越小**。

### <font color='red'>定点运算</font>

　　**加减法运算**

　　现代计算机都采用补码作加减法运算。补码加法的基本公式如下：

![补码加法的基本公式](/assets/img/java/补码加法的基本公式.png)

　　补码加法的过程举例：

<img src="/assets/img/java/补码加法的过程举例.png" alt="补码加法的过程举例" style="zoom:67%;" />

　　由`[A+B]补=1,0010`求出`A+B`的真值为-14，完全正确。

　　因此可以得到**补码加法的基本思想**：先分别求出两个加数的补码，然后补码相加，如果产生了进位就丢掉，得到一个新的补码，这个补码的原码就是计算结果。

　　<font color='red'>我对补码加法的理解还不够，比如我不知道为什么有时会产生进位、有时不会产生进位。限于精力，这部分内容连同后面的乘除法运算、浮点四则运算，留待以后再学习。</font>

### 进制转换

　　二进制数的表示形式：

<img src="/assets/img/java/二进制数的表示形式.png" alt="二进制数的表示形式" style="zoom:67%;" />

　　10、8、16进制也一样，只不过是把基数2换掉。二进制对计算机来说，计算、运算非常方便，但是不便于书写，为此人们常常采用八进制、十六进制，它们多被用于指令的书写、目的程序的输入或输出。使用八进制和十六进制还有一个原因，就是它们可以很方便地和二进制进行转换，八进制的一位等于二进制的三位，十六进制的一位等于二进制的四位。

　

　　**进制转换方法**

　　1、二、八、十六进制整数与十进制整数之间的转换

　　二、八、十六进制转换为十进制，可以分别采用除2、8、16取余的方法。

　　十进制转换为二、八、十六进制，可以采用权相加的方法。

　　2、二、八、十六进制小数与十进制小数之间的转换

　　二、八、十六进制转换为十进制，可以分别采用乘2、8、16取整的方法，但是小数不一定能算尽，只能算到一定精度。

　　十进制转换为二、八、十六进制，可以采用权相加的方法。

　　如果一个十进制数既有整数部分也有小数部分，可分别将整数部分和小数部分转换为其它进制，然后合并就可以得到结果。
