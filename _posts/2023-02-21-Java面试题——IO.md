---
title: Java面试题——IO&多线程
tags: Java面试题
---

## 一、IO

* ### 简述IO的继承结构

　　![IO继承结构图](/assets/img/java/IO继承结构图.png)

* ### 简述Java对象的序列化和反序列化

　　**定义**：序列化指的是把一个Java对象变成二进制内容，从而可以将对象保存到文件中，或者通过网络传输到远程。反序列化指的是把一个二进制内容变回Java对象。

　　**实现**：可以通过`ObjectOutputStream`把一个Java对象转换为字节流写入文件，通过`ObjectInputStream`从一个二进制内容中读取Java对象。

　　**Serializable**：只有实现了`Serializable`接口的对象才能被序列化。

　　**transient**：只能修饰局部变量，被修饰的变量不会被序列化。

## 二、多线程

* ### 简述Java内存模型(JMM)

　　1、所有变量都存储在主内存，每个线程都有自己的工作内存；

　　2、工作内存中保存了被该线程使用的变量的主存副本，线程对变量的所有操作都在工作内存中进行，不能直接操作主内存；

　　3、操作完成后，线程的工作内存通过缓存一致性协议将变量刷回主内存，但是刷新操作并不一定立刻发生。

* ### 简述原子性操作

　　原子性操作指的是一个操作或多个操作，要么全部执行成功，要不全都不执行。

* ### 简述volatile关键字的作用

　　volatile用来修饰变量，它的作用是：

　　1、保证共享变量对所有线程的**可见性**。如果没有volatile关键字，由于Java内存模型的存在，一个线程读取到的变量值不一定是主内存中的最新值，一个线程修改了的变量不一定会马上刷新回主内存。加了volatile之后，该变量一旦被修改就会立刻刷新回主内存，读取该变量时会去主内存中读取最新值。

　　2、**禁止指令重排**。CPU为了提高程序执行效率，允许多条指令不按照规定的顺序执行，只会保证最终结果的正确，这在单线程中是安全的，但是在多线程中是不安全的。volatile可以禁止对该变量进行指令重排，典型的应用就是双重检验锁实现单例模式时，共享变量要用volatile修饰。

* ### 简述Java线程的状态

* ### 线程的创建方式有哪些？

　　1、**继承Thread类**，重写run方法；

　　2、**实现Runnable接口**，重写run方法，然后传入Thread的构造方法；

　　3、**实现Callable接口**，重写call方法，然后传入FutureTask的构造方法，再将新对象传入Thread的构造方法。和前两种方法不同的是，这种方式可以获取call方法的返回值。

　　Runnable和Callable都是函数式接口，可以用lambda表达式简化。

* ### 什么是可重入锁？

　　可以被同一个线程重复获取的锁叫做可重入锁，比如synchronized。

* ### 什么是死锁？

　　两个线程各自持有不同的锁，然后试图获取对方手里的锁，造成了无限等待，这就是死锁。

* ### 简述ReentrantLock、ReadWriteLock、StampedLock的特点

　　**ReentantLock**：和synchronized很像，优点是可以指定获取锁的超时时间，避免长时间等待。一般情况下可以用synchronized代替。

　　**ReadWriteLock**：写的时候不允许其它线程写、读，读的时候不允许其它线程写，但是允许读。这是一种悲观读锁。

　　**StampedLock**：写的时候不允许其它线程写、读，读的时候允许其它线程写、读。这是一种乐观读锁。乐观读锁使用了`CAS`无锁方式实现线程安全，读的时候如果发现值发生了变化，会通过重试来获取新值。这种锁适用于读操作远多于写操作的场景。

* ### 线程安全的集合

* ### Atomic包装类

* ### 线程池

　　