---
title: Java多线程原理探究
tags: 多线程 Java基础
---

## 一、栈帧

　　Java多线程在运行过程中，会为每个线程分配一块独立的内存空间，叫做**线程栈**。当线程进入某个方法时，会为该方法在线程栈中创建一块空间，叫做**栈帧**，栈帧中存储着该方法的**局部变量(包括方法参数)、返回地址、锁记录(该方法持有的锁)、操作数栈**等信息，方法执行完之后，栈帧被释放。同时每个线程还拥有一个**程序计数器**，它负责记录该线程下一步需要执行的指令位置，当发生线程上下文切换时，CPU通过程序计数器来恢复线程。

![栈帧](/assets/img/java/栈帧.png)

> **上下文切换**：指的是CPU不再执行当前线程(即当前线程失去CPU时间分片)，而去执行另一个线程。频繁的上下文切换会影响性能。

## 二、线程的六种状态

　　线程的六种状态分别是：

　　1、**NEW**：新建状态。线程对象刚创建好，还未执行`start()`方法。

　　2、**RUNNABLE**：包括就绪和运行状态。就绪状态是指执行了`start()`方法，并且线程未被阻塞，正在等待获得CPU时间分片；运行状态是指线程已获得CPU时间分片，正在运行。

　　3、**BLOCKED**：阻塞状态。当线程启动后没有获取到锁，就会进入阻塞，CPU不会分配时间分片给阻塞线程，直到线程获取到锁。

　　4、**WAITING**：等待状态。当正在运行的线程主动调用`join()`或`wait()`方法后，该线程会自动放弃CPU时间分片，直到被其它线程唤醒后才会再次获取CPU时间分片。

　　5、**TIMED_WAITING**：限时等待状态。当正在运行的线程主动调用`join(long)`或`wait(long)`或`sleep(long)`方法后，该线程会自动放弃CPU时间分片，直到被其它线程唤醒，或者超过指定时间后才会再次获取CPU时间分片。

　　6、**TERMIATED**：终止状态。线程运行结束后变为终止状态。

> **BLOCKED、WAITING、TIMED_WAITING的联系与区别**：
>
> **联系**：线程在这三种状态下都会失去CPU时间分片。
>
> **区别**：失去时间分片的原因不一样。BLOCKED是因为没有获取到锁而被动地失去时间分片，当锁被释放时，BLOCKED线程就会被唤醒；而WAITING和TIMED_WAITING是线程获取到了锁，但是在线程内部执行了一些方法(`sleep()`、`join()`、`wait()`)，主动放弃了时间分片，当拥有锁的线程执行`notify()`或`notifyAll()`方法时，线程才会被唤醒。

## 三、重要方法

## 四、synchronized底层原理

* ### Java对象头

　　一个Java对象由对象头和成员变量两部分组成，其中对象头又由`Mark Word`和`Klass Word`两部分组成，`Klass Word`指向对象的类型(即Class实例)，`Mark Word`和`Synchronized`锁有关，它的结构如下图所示(64位虚拟机)：

![MarkWord结构](/assets/img/java/MarkWord结构.png)

* ### 重量级锁的原理

　　重量级锁的原理如下图所示：

![synchronized重量级锁原理](/assets/img/java/synchronized重量级锁原理.png)

　　1、每个对象都可以关联一个`Monitor`对象，当一个线程使用`synchronized`给一个对象加锁(重量级锁)后，该对象头的`Mark Word`中就被设置为指向`Monitor`的指针(即`ptr_to_heavyweight_monitor`)，锁状态变为`10`，同时`Monitor`对象中的`Owner`指向持有锁的线程地址；

　　2、当其它线程也对该对象加锁时，发现锁对象关联的`Monitor`对象中`Owner`已经指向某个线程，说明锁被占用，此时`Monitor`对象中的`EntryList`会存放这些线程的地址，同时这些线程从运行状态变为阻塞状态；

　　3、当持有锁的线程执行完毕，`Monitor`对象中的`Owner`会被清空，同时会去唤醒`EntryList`中的阻塞线程，这些线程又开始竞争锁，最终会有一个线程获取到锁，`Owner`会指向这个线程，其它线程继续阻塞。

* ### 轻量级锁的原理

　　**当多个线程使用同一个锁对象，但是对该锁对象不存在竞争行为时**，`synchronized`会使用轻量级锁，而非重量级锁。

　　轻量级锁的原理如下图所示：

![synchronized轻量级锁原理](/assets/img/java/synchronized轻量级锁原理.png)

　　1、线程给一个对象加轻量级锁时，会在线程栈内创建一个`LockRecord`(锁记录)对象，该对象内部会存储锁记录的地址、锁状态标志`00`(代表轻量级锁)、锁对象地址；

　　2、锁对象最开始处于无锁状态，它的对象头中的`Mark Word`中存放着该对象的`hashcode`、`age`、偏向锁标志、锁状态标志`01`(代表无锁)；

　　3、`LockRecord`会使用`CAS`操作和`Mark Word`交换信息，交换成功后`LockRecord`中存储着锁对象的`Mark Word`信息，而锁对象的`Mark Word`中存储着`LockRecord`的地址和锁状态标志`00`，此时加轻量级锁成功；

　　4、当一个线程多次对同一个对象加轻量级锁时(锁重入)，会创建多个锁记录，同时使用`CAS`操作交换数据，发现锁对象已经在第一次加锁时被占用了，于是交换失败，并将锁记录置为null，最终会根据null的数量来判断锁重入的层数；

　　5、当线程执行完毕，`LockRecord`会再次使用`CAS`操作和`Mark Word`交换信息，此时锁对象的`Mark Word`恢复到无锁状态`01`；

　　6、如果有线程竞争轻量级锁，轻量级锁就会**膨胀**为重量级锁，此时会为锁对象申请`Monitor`对象，锁对象的锁状态标志也会变为`10`。

* ### 重量级锁自旋优化

　　在多核CPU的条件下，会对重量级锁的竞争进行优化。当持有锁的线程没有释放锁时，未持有锁的线程会进入自旋，而不会进入阻塞状态，这意味着**未持有锁的线程不会放弃CPU的时间分片，从而减少了上下文切换带来的性能损耗**。当超过自旋次数时，线程才会进入阻塞状态。

　　在Java6之后自旋锁是自适应的，如果锁对象的上一次自旋成功了，那么认为这次自旋成功的概率会比较高，会多自旋几次，反之会少自旋甚至不自旋。

　　在Java7之后不能控制是否开启自旋功能。

* ### 偏向锁的原理

　　在Java6中引入偏向锁对轻量级锁进行了优化。轻量级锁的缺点是，当发生锁重入时，需要进行多次`CAS`操作，比较消耗性能，偏向锁的做法是：当第一次加轻量级锁时，会将线程id存放到锁对象的`Mark Word`中，之后如果发生锁重入，发现线程id相同，就表示没有竞争，无需`CAS`操作。

* ### 锁升级的过程

　　锁升级过程如下图所示：

![锁升级过程](/assets/img/java/锁升级过程.png)

　　1、锁对象的初始状态是偏向锁，`Mark Word`后三位是`101`，前面n位都是0；

　　2、当某个线程对锁对象加锁时，会将线程id填充到`Mark Word`的前n位，表示锁对象偏向该线程，后三位仍然是`101`；

　　3、如果线程释放了偏向锁，此时又有另一个线程来获取偏向锁，此时偏向锁会升级为轻量级锁，`Mark Word`的前n位会被该线程的锁记录替换，后两位变为`00`；

　　4、如果线程没有释放偏向锁或者轻量级锁，又有其它线程来获取锁，即发生锁竞争时，偏向锁或者轻量级锁会升级为重量级锁，`Mark Word`的前n位会变为`Monitor`的地址，后两位变为`10`。

## 五、wait()与notify()

* ### 等待与唤醒

　　当使用`synchronized`对锁对象加锁后，**持有锁的线程**可以通过执行`wait()/wait(long)`方法，使当前线程暂时放弃锁，等待被其它线程唤醒或者超时后自动醒来，然后重新竞争锁。持有锁的线程也可以通过执行`notify()/notifyAll()`方法，唤醒其它正在等待锁对象的线程。

　　WAITING状态的原理如下图所示：

![WAITING原理图](/assets/img/java/WAITING原理图.png)

　　1、当线程获取到锁，并执行了`wait()/wait(long)`方法，`Monitor`的`Owner`就会清空，`WaitSet`会存入线程的地址；

　　2、当持有锁的线程执行了`notifyAll()`方法，就会唤醒`WaitSet`中所有等待的线程，这些线程开始竞争锁，竞争失败的线程变为BLOCKED状态。

> **注意，只有持有锁对象的线程才能执行`wait()`和`notify()`方法，因此这两种方法必须在`synchronized`块内，通过锁对象调用。**

* ### wait()和sleep()的区别

　　`wait()`和`sleep()`的区别是：

　　1、`wait()`是锁对象中的方法，`sleep()`是线程类中的静态方法。

　　2、`wait()`需要在`synchronized`块中使用，而`sleep()`不需要。

　　3、`wait()`会使线程释放锁，而`sleep()`不会使线程释放锁。

　　它们的相同点是，都会使线程放弃时间分片。

* ### join()的原理

　　`join()`方法也是通过`wait()`与`notify()`实现的，过程是：

　　1、主线程中执行子线程，然后主线程调用子线程的`join()`方法，等待子线程执行结束；

　　2、子线程的`join()`方法被`synchronized`修饰，而`join`方法的调用者是主线程，这代表着主线程持有一个线程锁，而这个锁就是子线程对象；

　　3、`join`方法内部调用了`Object`类的`wait()`方法，使主线程进入等待状态；

　　4、当子线程执行完毕后，JVM会自动唤醒所有在子线程对象锁上等待的线程，即主线程。

## 六、interrupt

　　使用`interrupt()`方法可以打断一个线程，下面分析一下打断不同状态下的线程，会造成什么影响。对线程对象调用`isInterrupted()`方法会返回一个布尔值，用于判断打断状态，初始值是`false`，即未打断。

　　1、打断运行状态的线程，`isInterrupted()`方法会返回`true`，即已打断。

　　2、打断等待状态的线程(即调用了`sleep()`、`wait()`、`join()`方法的线程)，`isInterrupted()`方法会返回`false`，即未打断，并且会抛出`InterruptedException`。

　　**由此可知，在运行状态的线程中，我们需要通过`isInterrupted()`方法来判断线程是否被打断，从而进行下一步操作，而在等待状态的线程中，我们需要通过捕获`InterruptedException`来判断线程是否被打断**。

## 七、ReentrantLock

　　`ReentrantLock`相比于`synchronized`拥有更多的功能，比如**阻塞状态主动中断、锁超时、公平锁、多条件变量**等。

* ### 阻塞状态主动中断

　　在`synchronized`中，阻塞状态的线程在锁被释放之前会一直处于阻塞状态，而在`ReentrantLock`中，可以对处于阻塞状态的线程对象执行`interrupt()`方法来抛出异常，主动结束阻塞线程。

　　用法：

```java
Thread t1 = new Thread(() -> {
    try {
        //1、获取锁的方法是lockInterruptibly()，而非lock()
        lock.lockInterruptibly();
        System.out.println("t1线程正在执行");
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        lock.unlock();
    }
}, "t1");
t1.start();
//2、当线程阻塞时，调用interrupt()方法会使线程抛出异常，从而结束运行
t1.interrupt();
```

* ### 锁超时

　　锁超时也可以理解为阻塞状态被动中断，即在加锁的时候设置一个超时时间，线程阻塞的时间一旦超过这个时间就返回false，只有获取到锁后才返回true。

　　用法：

```java
Thread t1 = new Thread(() -> {
    try {
        //1、线程阻塞超过5s，就返回
        if (!lock.tryLock(5,TimeUnit.SECONDS)) {
            return;
        }
    } catch (InterruptedException e) {
        //2、线程被打断，也返回
        e.printStackTrace();
        return;
    }

    //3、代码执行到这里，说明线程已经获得了锁
    try {
        System.out.println("t1线程正在执行");
    }finally {
        lock.unlock();
    }
}, "t1");
t1.start();
```

* ### 公平锁

　　公平锁的意思是，多个线程在等待同一把锁时，必须按照申请锁的顺序依次获得锁，而非公平锁不保证这一点。`synchronized`是非公平锁，`ReentrantLock`默认是非公平锁，也可以手动设置为非公平锁。

　　用法：

```java
//公平锁
ReentrantLock lock = new ReentrantLock(true);
```

* ### 多条件变量

　　在`synchronized`中，条件变量指的是`	Monitor`中的`waitSet`，调用了`wait()`方法的线程会被放入`waitSet`，等待其它线程调用`notify()`方法将它们唤醒，它的局限是所有WAITING线程都使用同一个`waitSet`，即单条件变量。而在`ReentrantLock`中，可以创建多个条件变量，对应的等待和唤醒方法是`await()`和`signal()`。

　　用法：

```java
Condition c1 = lock.newCondition(); //条件变量1
Condition c2 = lock.newCondition(); //条件变量2

Thread t1 = new Thread(() -> {
    lock.lock();
    try {
        //1、线程等待，释放锁给所有线程
        c1.await();
        System.out.println("t1线程");
    } catch (InterruptedException e) {
        e.printStackTrace();
    } finally {
        lock.unlock();
    }
}, "t1");

Thread t2 = new Thread(() -> {
    lock.lock();
    try {
        System.out.println("t2线程");
        //2、唤醒在条件变量c1下等待的线程
        c1.signalAll();
    } finally {
        lock.unlock();
    }
}, "t2");
t1.start();
t2.start();
```

