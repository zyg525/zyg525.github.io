---
title: Java多线程原理探究
tags: 多线程 Java基础
---

## 一、栈帧

　　Java多线程在运行过程中，会为每个线程分配一块独立的内存空间，叫做**线程栈**。当线程进入某个方法时，会为该方法在线程栈中创建一块空间，叫做**栈帧**，栈帧中存储着该方法的**局部变量(包括方法参数)、返回地址、锁记录(该方法持有的锁)、操作数栈**等信息，方法执行完之后，栈帧被释放。同时每个线程还拥有一个**程序计数器**，它负责记录该线程下一步需要执行的指令位置，当发生线程上下文切换时，CPU通过程序计数器来恢复线程。

![栈帧](/assets/img/java/栈帧.png)

> **上下文切换**：指的是CPU不再执行当前线程(即当前线程失去CPU时间分片)，而去执行另一个线程。频繁的上下文切换会影响性能。

## 二、线程的六种状态

　　线程的六种状态分别是：

　　1、**NEW**：新建状态。线程对象刚创建好，还未执行`start()`方法。

　　2、**RUNNABLE**：包括就绪和运行状态。就绪状态是指执行了`start()`方法，并且线程未被阻塞，正在等待获得CPU时间分片；运行状态是指线程已获得CPU时间分片，正在运行。

　　3、**BLOCKED**：阻塞状态。当线程启动后没有获取到锁，就会进入阻塞，CPU不会分配时间分片给阻塞线程，直到线程获取到锁。

　　4、**WAITING**：等待状态。当正在运行的线程主动调用`join()`或`wait()`方法后，该线程会自动放弃CPU时间分片，直到被其它线程唤醒后才会再次获取CPU时间分片。

　　5、**TIMED_WAITING**：限时等待状态。当正在运行的线程主动调用`join(long)`或`wait(long)`或`sleep(long)`方法后，该线程会自动放弃CPU时间分片，直到被其它线程唤醒，或者超过指定时间后才会再次获取CPU时间分片。

　　6、**TERMIATED**：终止状态。线程运行结束后变为终止状态。

> **BLOCKED、WAITING、TIMED_WAITING的联系与区别**：
>
> **联系**：线程在这三种状态下都会失去CPU时间分片。
>
> **区别**：失去时间分片的原因不一样。BLOCKED是因为没有获取到锁而被动地失去时间分片，当锁被释放时，BLOCKED线程就会被唤醒；而WAITING和TIMED_WAITING是线程获取到了锁，但是在线程内部执行了一些方法(`sleep()`、`join()`、`wait()`)，主动放弃了时间分片，当拥有锁的线程执行`notify()`或`notifyAll()`方法时，线程才会被唤醒。

## 三、synchronized底层原理

* ### Java对象头

　　一个Java对象由对象头和成员变量两部分组成，其中对象头又由`Mark Word`和`Klass Word`两部分组成，`Klass Word`指向对象的类型(即Class实例)，`Mark Word`和`Synchronized`锁有关，它的结构如下图所示(64位虚拟机)：

![MarkWord结构](/assets/img/java/MarkWord结构.png)

* ### 重量级锁的原理

　　重量级锁的原理如下图所示：

![synchronized重量级锁原理](/assets/img/java/synchronized重量级锁原理.png)

　　1、每个对象都可以关联一个`Monitor`对象，当一个线程使用`synchronized`给一个对象加锁(重量级锁)后，该对象头的`Mark Word`中就被设置为指向`Monitor`的指针(即`ptr_to_heavyweight_monitor`)，锁状态变为`10`，同时`Monitor`对象中的`Owner`指向持有锁的线程地址；

　　2、当其它线程也对该对象加锁时，发现锁对象关联的`Monitor`对象中`Owner`已经指向某个线程，说明锁被占用，此时`Monitor`对象中的`EntryList`会存放这些线程的地址，同时这些线程从运行状态变为阻塞状态；

　　3、当持有锁的线程执行完毕，`Monitor`对象中的`Owner`会被清空，同时会去唤醒`EntryList`中的阻塞线程，这些线程又开始竞争锁，最终会有一个线程获取到锁，`Owner`会指向这个线程，其它线程继续阻塞。

* ### 轻量级锁的原理

　　**当多个线程使用同一个锁对象，但是对该锁对象不存在竞争行为时**，`synchronized`会使用轻量级锁，而非重量级锁。

　　轻量级锁的原理如下图所示：

![synchronized轻量级锁原理](/assets/img/java/synchronized轻量级锁原理.png)

　　1、线程给一个对象加轻量级锁时，会在线程栈内创建一个`LockRecord`(锁记录)对象，该对象内部会存储锁记录的地址、锁状态标志`00`(代表轻量级锁)、锁对象地址；

　　2、锁对象最开始处于无锁状态，它的对象头中的`Mark Word`中存放着该对象的`hashcode`、`age`、偏向锁标志、锁状态标志`01`(代表无锁)；

　　3、`LockRecord`会使用`CAS`操作和`Mark Word`交换信息，交换成功后`LockRecord`中存储着锁对象的`Mark Word`信息，而锁对象的`Mark Word`中存储着`LockRecord`的地址和锁状态标志`00`，此时加轻量级锁成功；

　　4、当一个线程多次对同一个对象加轻量级锁时(锁重入)，会创建多个锁记录，同时使用`CAS`操作交换数据，发现锁对象已经在第一次加锁时被占用了，于是交换失败，并将锁记录置为null，最终会根据null的数量来判断锁重入的层数；

　　5、当线程执行完毕，`LockRecord`会再次使用`CAS`操作和`Mark Word`交换信息，此时锁对象的`Mark Word`恢复到无锁状态`01`；

　　6、如果有线程竞争轻量级锁，轻量级锁就会**膨胀**为重量级锁，此时会为锁对象申请`Monitor`对象，锁对象的锁状态标志也会变为`10`。

* ### 重量级锁自旋优化

　　在多核CPU的条件下，会对重量级锁的竞争进行优化。当持有锁的线程没有释放锁时，未持有锁的线程会进入自旋，而不会进入阻塞状态，这意味着**未持有锁的线程不会放弃CPU的时间分片，从而减少了上下文切换带来的性能损耗**。当超过自旋次数时，线程才会进入阻塞状态。

　　在Java6之后自旋锁是自适应的，如果锁对象的上一次自旋成功了，那么认为这次自旋成功的概率会比较高，会多自旋几次，反之会少自旋甚至不自旋。

　　在Java7之后不能控制是否开启自旋功能。

* ### 偏向锁的原理

　　在Java6中引入偏向锁对轻量级锁进行了优化。轻量级锁的缺点是，当发生锁重入时，需要进行多次`CAS`操作，比较消耗性能，偏向锁的做法是：当第一次加轻量级锁时，会将线程id存放到锁对象的`Mark Word`中，之后如果发生锁重入，发现线程id相同，就表示没有竞争，无需`CAS`操作。

* ### 锁升级的过程

　　锁升级过程如下图所示：

![锁升级过程](/assets/img/java/锁升级过程.png)

　　1、锁对象的初始状态是偏向锁，`Mark Word`后三位是`101`，前面n位都是0；

　　2、当某个线程对锁对象加锁时，会将线程id填充到`Mark Word`的前n位，表示锁对象偏向该线程，后三位仍然是`101`；

　　3、如果线程释放了偏向锁，此时又有另一个线程来获取偏向锁，此时偏向锁会升级为轻量级锁，`Mark Word`的前n位会被该线程的锁记录替换，后两位变为`00`；

　　4、如果线程没有释放偏向锁或者轻量级锁，又有其它线程来获取锁，即发生锁竞争时，偏向锁或者轻量级锁会升级为重量级锁，`Mark Word`的前n位会变为`Monitor`的地址，后两位变为`10`。

## 四、wait()与notify()

* ### 等待与唤醒

　　当使用`synchronized`对锁对象加锁后，**持有锁的线程**可以通过执行`wait()/wait(long)`方法，使当前线程暂时放弃锁，等待被其它线程唤醒或者超时后自动醒来，然后重新竞争锁。持有锁的线程也可以通过执行`notify()/notifyAll()`方法，唤醒其它正在等待锁对象的线程。

　　WAITING状态的原理如下图所示：

![WAITING原理图](/assets/img/java/WAITING原理图.png)

　　1、当线程获取到锁，并执行了`wait()/wait(long)`方法，`Monitor`的`Owner`就会清空，`WaitSet`会存入线程的地址；

　　2、当持有锁的线程执行了`notifyAll()`方法，就会唤醒`WaitSet`中所有等待的线程，这些线程开始竞争锁，竞争失败的线程变为BLOCKED状态。

> **注意，只有持有锁对象的线程才能执行`wait()`和`notify()`方法，因此这两种方法必须在`synchronized`块内，通过锁对象调用。**

* ### wait()和sleep()的区别

　　`wait()`和`sleep()`的区别是：

　　1、`wait()`是锁对象中的方法，`sleep()`是线程类中的静态方法。

　　2、`wait()`需要在`synchronized`块中使用，而`sleep()`不需要。

　　3、`wait()`会使线程释放锁，而`sleep()`不会使线程释放锁。

　　它们的相同点是，都会使线程放弃时间分片。

* ### join()的原理

　　`join()`方法也是通过`wait()`与`notify()`实现的，过程是：

　　1、主线程中执行子线程，然后主线程调用子线程的`join()`方法，等待子线程执行结束；

　　2、子线程的`join()`方法被`synchronized`修饰，而`join`方法的调用者是主线程，这代表着主线程持有一个线程锁，而这个锁就是子线程对象；

　　3、`join`方法内部调用了`Object`类的`wait()`方法，使主线程进入等待状态；

　　4、当子线程执行完毕后，JVM会自动唤醒所有在子线程对象锁上等待的线程，即主线程。

## 五、interrupt

　　使用`interrupt()`方法可以打断一个线程，下面分析一下打断不同状态下的线程，会造成什么影响。对线程对象调用`isInterrupted()`方法会返回一个布尔值，用于判断打断状态，初始值是`false`，即未打断。

　　1、打断运行状态的线程，`isInterrupted()`方法会返回`true`，即已打断。

　　2、打断等待状态的线程(即调用了`sleep()`、`wait()`、`join()`方法的线程)，`isInterrupted()`方法会返回`false`，即未打断，并且会抛出`InterruptedException`。

　　**由此可知，在运行状态的线程中，我们需要通过`isInterrupted()`方法来判断线程是否被打断，从而进行下一步操作，而在等待状态的线程中，我们需要通过捕获`InterruptedException`来判断线程是否被打断**。

## 六、ReentrantLock

　　`ReentrantLock`相比于`synchronized`拥有更多的功能，比如**阻塞状态主动中断、锁超时、公平锁、多条件变量**等。

* ### 阻塞状态主动中断

　　在`synchronized`中，阻塞状态的线程在锁被释放之前会一直处于阻塞状态，而在`ReentrantLock`中，可以对处于阻塞状态的线程对象执行`interrupt()`方法来抛出异常，主动结束阻塞线程。

　　用法：

```java
Thread t1 = new Thread(() -> {
    try {
        //1、获取锁的方法是lockInterruptibly()，而非lock()
        lock.lockInterruptibly();
        System.out.println("t1线程正在执行");
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        lock.unlock();
    }
}, "t1");
t1.start();
//2、当线程阻塞时，调用interrupt()方法会使线程抛出异常，从而结束运行
t1.interrupt();
```

* ### 锁超时

　　锁超时也可以理解为阻塞状态被动中断，即在加锁的时候设置一个超时时间，线程阻塞的时间一旦超过这个时间就返回false，只有获取到锁后才返回true。

　　用法：

```java
Thread t1 = new Thread(() -> {
    try {
        //1、线程阻塞超过5s，就返回
        if (!lock.tryLock(5,TimeUnit.SECONDS)) {
            return;
        }
    } catch (InterruptedException e) {
        //2、线程被打断，也返回
        e.printStackTrace();
        return;
    }

    //3、代码执行到这里，说明线程已经获得了锁
    try {
        System.out.println("t1线程正在执行");
    }finally {
        lock.unlock();
    }
}, "t1");
t1.start();
```

* ### 公平锁

　　公平锁的意思是，多个线程在等待同一把锁时，必须按照申请锁的顺序依次获得锁，而非公平锁不保证这一点。`synchronized`是非公平锁，`ReentrantLock`默认是非公平锁，也可以手动设置为非公平锁。

　　用法：

```java
//公平锁
ReentrantLock lock = new ReentrantLock(true);
```

* ### 多条件变量

　　在`synchronized`中，条件变量指的是`	Monitor`中的`waitSet`，调用了`wait()`方法的线程会被放入`waitSet`，等待其它线程调用`notify()`方法将它们唤醒，它的局限是所有WAITING线程都使用同一个`waitSet`，即单条件变量。而在`ReentrantLock`中，可以创建多个条件变量，对应的等待和唤醒方法是`await()`和`signal()`。

　　用法：

```java
Condition c1 = lock.newCondition(); //条件变量1
Condition c2 = lock.newCondition(); //条件变量2

Thread t1 = new Thread(() -> {
    lock.lock();
    try {
        //1、线程等待，释放锁给所有线程
        c1.await();
        System.out.println("t1线程");
    } catch (InterruptedException e) {
        e.printStackTrace();
    } finally {
        lock.unlock();
    }
}, "t1");

Thread t2 = new Thread(() -> {
    lock.lock();
    try {
        System.out.println("t2线程");
        //2、唤醒在条件变量c1下等待的线程
        c1.signalAll();
    } finally {
        lock.unlock();
    }
}, "t2");
t1.start();
t2.start();
```

## 七、volatile

* ### 可见性与指令重排

　　**可见性**：在Java内存模型中，所有变量都存储在主内存，并且每个线程都有自己的工作内存。当线程需要频繁地读取或修改变量时，`JIT`编译器会将变量缓存到工作内存中，减少对主内存的访问，变量修改结束后再同步回主内存。同步的操作不会立即发生，这就导致了一个线程对变量的修改，对于另一个线程对变量的读取，不是立即可见的。

　　**指令重排**：CPU为了提高效率，在不影响单线程的执行结果的情况下，可能会打乱多条指令的执行顺序，在多线程的情况下，就会导致线程安全问题。

* ### volatile的原理

　　被`volatile`修饰的变量，可以保证可见性、禁止指令重排。

　　**保证可见性的原理**：`volatile`变量的读取指令之前会加入一个**读屏障**，写入指令之后会加入一个**写屏障**。读屏障可以保证在它之后的所有读操作，都加载的是主存中的值，写屏障可以保证在它之前的所有写操作，都会同步到主存中。**这就保证了如果一个线程修改了`volatile`变量后，另一个线程读取这个变量，那么读取到的一定是修改后的最新值**。

　　**禁止指令重排的原理**：读屏障还可以保证在它之后的所有操作，不会在它之前执行，写屏障还可以保证在它之前的所有操作，不会在它之后执行。**这就保证了`volatile`变量及其前后代码的有序性**。

* ### DCL单例模式

　　`DCL(Double Check Lock)`单例模式，即使用双重检验锁来实现单例模式的一种方式。它使用了`synchronized`和`volatile`来保证线程安全。

```java
public class Singleton {
    //1、volatile的作用是禁止指令重排，指令重排会导致某个线程获取到的是还未初始化的Singleton对象
    private static volatile Singleton singleton = null;
    
    //2、私有化构造方法，保证只能通过getSingleton()方法创建单例(无法防止通过反射或反序列化创建单例)
    private Singleton() {}
    
    public static Singleton getSingleton() {
        //3、第一重检验的作用是，减少加锁解锁的次数
        if(singleton == null) {
            synchronized (Singleton.class) {
                //4、第二重检验的作用是，保证多个线程只能创建一个Singleton对象
                if(singleton == null) {
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}
```

## 八、CAS

* ### 工作方式

　　`CAS(Compare And Set)`是一种使用无锁方式保证线程安全的方法。

　　它的典型用法是：

```java
//伪代码
volatile Num num = new Num(0);

public final int add(Num num, int a) {
    int result = 0;
    do {
        int old = num.getNum();
        result = old+a;
    } while(!compareAndSet(num, old, result));

    return result;
}
```

　　`CAS`操作的基本逻辑是：在一个`while`循环中对共享变量进行修改，先读取变量在内存中的值`old`，然后在这个值上进行修改，并将结果暂存起来，接下来会通过`CAS`操作来验证`old`与变量在内存中的最新值是否相等，如果相等，说明变量没有被其它线程修改，此时`CAS`操作内部会将暂存的结果赋值给共享变量，如果不相等，说明变量被其它线程修改了，就重新返回`while`循环进行重试。

　　**注意，`CAS`因为需要获取变量在内存中的最新值，所以共享变量必须是`volatile`类型。**

　　`CAS`操作会使线程不断重试，而非阻塞，避免了上下文切换造成的性能消耗，但是需要更多CPU的支持，因此适用于线程数量少、多核CPU的情况。

> `compareAndSet()`方法就是那个`CAS`操作，它的底层是`lock cmpxchg`指令(`X86`架构)，在单核和多核CPU下都能保证**`CAS`操作的原子性。`CAS`实际上就是通过其原子性保证共享变量的线程安全的**。
>
> 在Java中，`CAS`操作被封装在`sun.misc.Unsafe`类中，这个类对象只能通过反射得到，里面定义了很多`native`类型的`CAS`方法。

* ### 应用

　　`AtomicInteger`、`AtomicLong`、`AtomicBoolean`、`AtomicReference`等类都使用了`CAS`操作来保证线程安全。此外，`AtomicStampedReference`、`AtomicMarkableReference`可以解决`ABA`问题，原子数组可以保证数组内元素的线程安全，原子更新器可以保证对象中某个属性的线程安全，原子累加器可以保证数值计算的线程安全，它比`AtomicInteger`等原子类效率更高。以上这些类都是通过`CAS`来实现线程安全的。

## 九、不可变类

* ### 特点

　　**不可变类指的是，当该类的实例一旦创建完成，就不能改变其成员变量值，因此不可变对象是线程安全的**。常见的不可变类有`String`、8个基本类型的包装类(`Integer、Long、Double`等)、`BigInteger`和`BigDecimal`。

* ### 设计不可变类

　　**设计不可变类的核心思想是，使用`final`保证成员变量的引用不可变，使用`private`和深拷贝等方法隐藏成员变量的引用**。具体做法包括：

　　1、使用`final`修饰类，防止其方法被子类重写；

　　2、使用`private`修饰成员变量，防止成员变量被外界访问；

　　3、使用`final`修饰成员变量，防止成员变量的引用被修改；

　　4、使用构造方法初始化成员变量，通过深拷贝进行赋值，防止外部类获得成员变量的引用；

　　5、不提供其它修改成员变量的方法；

　　6、在`getter`方法中，返回成员变量的拷贝，而非原对象。

* ### 不可变对象的线程安全

　　**不可变对象的线程安全仅仅意味着该对象本身是共享安全的，并不意味着对该对象的所有操作都是线程安全的**，比如：

```java
static Integer a = new Integer(0);
public static void main(String[] args) throws Exception {
    for(int i=0;i<1000;i++) {
        new Thread(()->{
            a++;
        }).start();
    }
    Thread.sleep(5000);
    System.out.println(a.intValue());
}
```

　　上面的程序是线程不安全的。因为`a++`包含了多条语句，分别是：

```java
int b = a.intValue();
b = b+1;
Integer c = Integer.valueOf(b);
a = c;
```

　　`Integer.valueOf(b)`方法每次都会返回新对象，因此最终得到的`a`已经不是最开始的静态成员变量了，当然，静态成员变量仍然是`0`，没有改变。为了保证`a++`的在多线程下能得到正确的结果，我们可以使用`AtomicInteger`的`getAndIncrement()`方法。

## 十、线程池

* ### 工作原理

　　线程池的工作原理如下图所示：

![线程池的工作原理](/assets/img/java/线程池的工作原理.png)

　　阻塞队列的作用是临时存放任务，主线程负责向阻塞队列中添加新任务，线程池负责创建线程来消费这些任务。**对于消费者，当队列中有任务时，线程池中的线程会从队列中拿出这个任务，同时唤醒主线程继续向队列中添加新任务，当队列为空时，线程池中的线程会进入等待状态；对于生产者，当队列没满时，主线程会往队列中添加任务，同时唤醒线程池中的所有线程消费这个任务，当队列已满时，主线程会进入等待状态。**

* ### 自定义线程池

　　线程池的核心组件包括：**阻塞队列、任务、线程池类、线程类、拒绝策略**。

　　**1、阻塞队列**

　　阻塞队列的作用是临时存放任务，**它的特点是：它的存、取方法共用一把锁，以保证线程安全，当队列为空时，取方法阻塞，当队列已满时，存方法阻塞，存、取方法互相可以通信**。

　　**2、任务**

　　任务可以由函数式接口的实现类来表示，由主线程传入线程池来执行。

　　**3、线程池类**

　　线程池类中维护了一个阻塞队列、一个线程集合。对于主线程新提交的任务，线程池会先创建新线程来执行这些任务，一旦线程数量达到最大值，就会将新任务放入阻塞队列；创建好的线程会被放入线程集合中，同时线程会不断地从阻塞队列中取出任务来执行，除非线程被设置了超时时间，那么当获取任务超时时，就会结束线程，同时从线程集合中移除线程。

　　**4、线程类**

　　线程类中持有一个任务，它会执行当前任务，并不断地从阻塞队列中获取任务来执行，当超过限定时间，线程才会结束。

　　**5、拒绝策略**

　　当阻塞队列已满，主线程想继续往队列中添加任务时，可以执行一定的拒绝策略。常见的拒绝策略有抛异常、把任务交给主线程执行、设置超时时间执行等。

* ### JDK线程池

　　JDK线程池的核心类是`ThreadPoolExecutor`，它的构造方法是：

```java
public ThreadPoolExecutor(
    int corePoolSize,                    /*1、核心线程数量最大值*/
    int maximumPoolSize,                 /*2、总线程数量最大值，总线程数量包括了核心线程和非核心线程*/
    long keepAliveTime,                  /*3、非核心线程超时时间*/
    TimeUnit unit,                       /*4、时间单位*/
    BlockingQueue<Runnable> workQueue,   /*5、阻塞队列，用来存放等待执行的Runnable任务*/
    ThreadFactory threadFactory,         /*6、创建线程的工厂*/
    RejectedExecutionHandler handler)    /*7、拒绝策略*/
```

　　构造方法中7个参数的意义是：

　　1、当主线程开始提交任务给线程池执行时，线程池首先会创建新的线程来执行任务，这些线程被称为核心线程，核心线程一旦被创建好就会一直执行下去，不会结束；

　　2、当核心线程的数量达到`corePoolSize`后，主线程会将新的任务放到线程池的阻塞队列中，即`workQueue`，等待核心线程去消费；

　　3、当阻塞队列已满时，线程池会创建新的临时线程去执行新的任务，这些线程被称为非核心线程，非核心线程与核心线程的数量之和最大值为`maximumPoolSize`。当非核心线程等待时间超过`keepAliveTime`时，就会结束；

　　4、当阻塞队列已满，并且非核心线程数量达到上限时，就会执行拒绝策略，即`handler`。JDK线程池有四种拒绝策略，分别是`AbortPolicy`(抛出异常，新任务不再执行)、`DiscardPolicy`(不抛异常，新任务不再执行)、`DiscardOldestPolicy`(丢弃阻塞队列中最早的任务，把新任务放进阻塞队列)、`CallerRunsPolicy`(把新任务交给主线程去执行)，其中`AbortPolicy`是默认的拒绝策略。

　　5、`threadFactory`指的是线程工厂，它封装了创建新线程的方法，可以为新线程设置名字等。

* ### Executors常用线程池

　　`Executors`类为我们定义好了一些常用的线程池，通过静态方法来获取。

　　**1、固定大小线程池**

```java
ExecutorService executor = Executors.newFixedThreadPool(2);
```

　　它只有核心线程，没有非核心线程，阻塞队列是无界的，因此可以放入任意数量的任务。**这种线程池适用于任务量已知、相对耗时的任务**。

　　**2、缓冲线程池**

```java
ExecutorService executor = Executors.newCachedThreadPool();
```

　　它没有核心线程，非核心线程没有上限，超时时间是60s，阻塞队列没有容量。这意味着每提交一个任务，线程池就会创建一个非核心线程来执行任务，等待超过60s后结束线程。**这种线程池适用于任务数量比较密集、但是每个任务执行时间较短的任务**。

　　**3、单线程线程池**

```java
ExecutorService executor = Executors.newSingleThreadExecutor();
```

　　它只有一个核心线程，没有非核心线程，阻塞队列是无界的。**这种线程池可以保证始终有一个线程可以执行任务，当这个线程因为异常而结束运行时，线程池会再新建一个线程。并且单线程线程池的`corePoolSize`是不能修改的**。

* ### 线程池大小的经验公式

　　多线程适用于处理**`IO`密集型运算**，这种运算的特点是执行业务计算时会使用CPU资源，当执行`IO`操作、远程RPC调用时，CPU就会闲下来。

　　线程池中线程数量的经验公式如下：

```
线程数 = CPU核数 * ((CPU计算时间+CPU等待时间)/CPU运算时间) * 期望CPU利用率
```

## 十一、其它锁

* ### AQS

　　`AQS`指的是`AbstractQueuedSynchronizer`，它是通过Java代码来实现锁和同步器的一系列框架，`ReentrantLock`、`CountDownLatch`等都是通过`AQS`来实现的。

* ### ReentrantReadWriteLock

　　`ReentrantReadWriteLock`是读写锁，**它将锁细分为读锁和写锁，在读方法中加读锁，在写方法中加写锁，效果是多线程可以同时读，但读的时候不可以写，写的时候不可以读、写**。提高了读操作的并发量。

* ### StampedLock

　　`StampedLock`对`ReentrantReadWriteLock`作了改进，区别是`StampedLock`是在读方法中先不加锁，而是会获取锁中的`stamp`，等到读取到结果后会用这个`stamp`验证锁中最新的`stamp`，如果相同就说明读的过程中没有写入，这时就返回结果；如果不相同，说明读的过程中有写入，这时再对读操作加悲观读锁，保证能够读取到正确的结果。

　　**`StampedLock`实际上是优先采用无锁方式，保证读操作不会获取到错误的结果，如果无锁方式失效，就采用悲观锁的方式进行兜底，保证能获取到正确的结果**。

* ### Semaphore

　　**`Semaphore`可以控制线程的并发量**，创建`Semaphore`对象时会指定一个信号量，当线程调用`acquire()`方法获取锁时，如果获取到了锁，信号量就会减1，当信号量减少到0时线程就会获取锁失败，进入阻塞状态，当线程调用`release()`释放锁后，信号量会加1，并且阻塞状态的线程也会被唤醒。

* ### CountDownLatch

　　**`CountDownLatch`用于线程之间的协作**。创建`CountDownLatch`对象时会指定一个计数，每当线程调用一次`countDown()`方法，计数都会减一，当计数减少到0时，调用了`await()`方法的线程就会被唤醒。

* ### CyclicBarrier

　　**`CyclicBattier`也用于线程之间的协作**。创建`CyclicBarrier`对象时会指定一个计数，每当线程调用一次`await()`方法，计数器都会减一，同时线程进入阻塞，当计数器减少到0时，所有阻塞的线程都会被唤醒。

　　`CyclicBarrier`使用时要注意，线程数量要等于计数，如果小于计数，那么所有线程都会阻塞。

　　`CyclicBarrier`的计数归零后，会自动初始化为原值，因此可以重复使用。

> 可以看出`CountDownLatch`和`CyclicBarrier`很像，前者通过`countDown()`方法减少计数，计数归零后唤醒所有`await()`方法，后者通过`await()`方法减少计数，计数归零后唤醒所有`await()`方法。

## 十二、线程安全的集合类

　　线程安全的集合类中，单个方法都是线程安全的，意思是多个线程共享一个集合对象，并调用它的单个方法时，不会出现线程安全问题。

　　线程安全的集合类如下：

| 接口  |  非线程安全的实现类   |            线程安全的实现类            |
| :---: | :-------------------: | :------------------------------------: |
| List  |       ArrayList       |          CopyOnWriteArrayList          |
|  Map  |        HashMap        |           ConcurrentHashMap            |
|  Set  |    HashSet/TreeSet    |          CopyOnWriteArraySet           |
| Queue | ArrayDeque/LinkedList | ArrayBlockingQueue/LinkedBlockingQueue |
| Deque | ArrayDeque/LinkedList |          LinkedBlockingDeque           |

　　其中`CopyOnWriteArrayList`的原理大致是使用拷贝数组来保证共享变量的安全，允许读取时写入，提高了读写的并发性能，缺点是牺牲了读写的一致性，即读取到的数据很可能是旧值。`CopyOnWriteArraySet`只是对`CopyOnWriteArrayList`的简单封装。

　　`ConcurrentHashMap`的原理大致是使用了`CAS`等保证线程安全。

　　`LinkedBlockingQueue`使用了两把锁保证了消费者和生产者的线程安全。

　　线程安全的集合类的具体原理比较复杂，以后有时间了再作研究。(<font color='red'>TODO</font>)
