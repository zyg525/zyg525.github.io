---
title: Java多线程原理探究
tags: 多线程 Java基础
---

## 一、栈帧

　　Java多线程在运行过程中，会为每个线程分配一块独立的内存空间，叫做**线程栈**。当线程进入某个方法时，会为该方法在线程栈中创建一块空间，叫做**栈帧**，栈帧中存储着该方法的**局部变量(包括方法参数)、返回地址、锁记录(该方法持有的锁)、操作数栈**等信息，方法执行完之后，栈帧被释放。同时每个线程还拥有一个**程序计数器**，它负责记录该线程下一步需要执行的指令位置，当发生线程上下文切换时，CPU通过程序计数器来恢复线程。

![栈帧](/assets/img/java/栈帧.png)

> **上下文切换**：指的是CPU不再执行当前线程(即当前线程失去CPU时间分片)，而去执行另一个线程。频繁的上下文切换会影响性能。

## 二、线程的六种状态

　　线程的六种状态分别是：

　　1、**NEW**：新建状态。线程对象刚创建好，还未执行`start()`方法。

　　2、**RUNNABLE**：包括就绪和运行状态。就绪状态是指执行了`start()`方法，并且线程未被阻塞，正在等待获得CPU时间分片；运行状态是指线程已获得CPU时间分片，正在运行。

　　3、**BLOCKED**：阻塞状态。当线程启动后没有获取到锁，就会进入阻塞，CPU不会分配时间分片给阻塞线程，直到线程获取到锁。

　　4、**WAITING**：等待状态。当正在运行的线程主动调用`join()`或`wait()`方法后，该线程会自动放弃CPU时间分片，直到被其它线程唤醒后才会再次获取CPU时间分片。

　　5、**TIMED_WAITING**：限时等待状态。当正在运行的线程主动调用`join(long)`或`wait(long)`或`sleep(long)`方法后，该线程会自动放弃CPU时间分片，直到被其它线程唤醒，或者超过指定时间后才会再次获取CPU时间分片。

　　6、**TERMIATED**：终止状态。线程运行结束后变为终止状态。

> **BLOCKED、WAITING、TIMED_WAITING的区别**：
>
> 线程在这三种状态下都会失去CPU时间分片，但原因不一样。BLOCKED是因为没有获取到锁，被动地失去了时间分片，而WAITING和TIMED_WAITING是因为线程执行了一些方法，主动放弃了时间分片。

## 三、重要方法

## 四、synchronized底层原理

* ### Java对象头

　　一个Java对象由对象头和成员变量两部分组成，其中对象头又由`Mark Word`和`Klass Word`两部分组成，`Klass Word`指向对象的类型(即Class实例)，`Mark Word`和`Synchronized`锁有关，它的结构如下图所示(64位虚拟机)：

![MarkWord结构](/assets/img/java/MarkWord结构.png)

* ### 重量级锁的原理

　　重量级锁的原理如下图所示：

![synchronized重量级锁原理](/assets/img/java/synchronized重量级锁原理.png)

　　1、每个对象都可以关联一个`Monitor`对象，当一个线程使用`synchronized`给一个对象加锁(重量级锁)后，该对象头的`Mark Word`中就被设置为指向`Monitor`的指针(即`ptr_to_heavyweight_monitor`)，锁状态变为`10`，同时`Monitor`对象中的`Owner`指向持有锁的线程地址；

　　2、当其它线程也对该对象加锁时，发现锁对象关联的`Monitor`对象中`Owner`已经指向某个线程，说明锁被占用，此时`Monitor`对象中的`EntryList`会存放这些线程的地址，同时这些线程从运行状态变为阻塞状态；

　　3、当持有锁的线程执行完毕，`Monitor`对象中的`Owner`会被清空，同时会去唤醒`EntryList`中的阻塞线程，这些线程又开始竞争锁，最终会有一个线程获取到锁，`Owner`会指向这个线程，其它线程继续阻塞。

* ### 轻量级锁的原理

　　**当多个线程使用同一个锁对象，但是对该锁对象不存在竞争行为时**，`synchronized`会使用轻量级锁，而非重量级锁。

　　轻量级锁的原理如下图所示：

![synchronized轻量级锁原理](/assets/img/java/synchronized轻量级锁原理.png)

　　1、线程给一个对象加轻量级锁时，会在线程栈内创建一个`LockRecord`(锁记录)对象，该对象内部会存储锁记录的地址、锁状态标志`00`(代表轻量级锁)、锁对象地址；

　　2、锁对象最开始处于无锁状态，它的对象头中的`Mark Word`中存放着该对象的`hashcode`、`age`、偏向锁标志、锁状态标志`01`(代表无锁)；

　　3、`LockRecord`会使用`CAS`操作和`Mark Word`交换信息，交换成功后`LockRecord`中存储着锁对象的`Mark Word`信息，而锁对象的`Mark Word`中存储着`LockRecord`的地址和锁状态标志`00`，此时加轻量级锁成功；

　　4、当一个线程多次对同一个对象加轻量级锁时(锁重入)，会创建多个锁记录，同时使用`CAS`操作交换数据，发现锁对象已经在第一次加锁时被占用了，于是交换失败，并将锁记录置为null，最终会根据null的数量来判断锁重入的层数；

　　5、当线程执行完毕，`LockRecord`会再次使用`CAS`操作和`Mark Word`交换信息，此时锁对象的`Mark Word`恢复到无锁状态`01`；

　　6、如果有线程竞争轻量级锁，轻量级锁就会**膨胀**为重量级锁，此时会为锁对象申请`Monitor`对象，锁对象的锁状态标志也会变为`10`。

* ### 重量级锁自旋优化

　　在多核CPU的条件下，会对重量级锁的竞争进行优化。当持有锁的线程没有释放锁时，未持有锁的线程会进入自旋，而不会进入阻塞状态，这意味着**未持有锁的线程不会放弃CPU的时间分片，从而减少了上下文切换带来的性能损耗**。当超过自旋次数时，线程才会进入阻塞状态。

　　在Java6之后自旋锁是自适应的，如果锁对象的上一次自旋成功了，那么认为这次自旋成功的概率会比较高，会多自旋几次，反之会少自旋甚至不自旋。

　　在Java7之后不能控制是否开启自旋功能。

* ### 偏向锁的原理

　　在Java6中引入偏向锁对轻量级锁进行了优化。轻量级锁的缺点是，当发生锁重入时，需要进行多次`CAS`操作，比较消耗性能，偏向锁的做法是：当第一次加轻量级锁时，会将线程id存放到锁对象的`Mark Word`中，之后如果发生锁重入，发现线程id相同，就表示没有竞争，无需`CAS`操作。

* ### 锁升级的过程

　　锁升级过程如下图所示：

![锁升级过程](/assets/img/java/锁升级过程.png)

　　1、锁对象的初始状态是偏向锁，`Mark Word`后三位是`101`，前面n位都是0；

　　2、当某个线程对锁对象加锁时，会将线程id填充到`Mark Word`的前n位，表示锁对象偏向该线程，后三位仍然是`101`；

　　3、如果线程释放了偏向锁，此时又有另一个线程来获取偏向锁，此时偏向锁会升级为轻量级锁，`Mark Word`的前n位会被该线程的锁记录替换，后两位变为`00`；

　　4、如果线程没有释放偏向锁或者轻量级锁，又有其它线程来获取锁，即发生锁竞争时，偏向锁或者轻量级锁会升级为重量级锁，`Mark Word`的前n位会变为`Monitor`的地址，后两位变为`10`。
