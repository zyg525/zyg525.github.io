---
title: Java语言基础之泛型
categories: Java语言基础
tags: Java语言基础
layout: post
---



## 概述

### 定义

　　泛型是一种模板，创建对象的时候约定好参数类型，使用对象的时候必须遵循约定，否则编译不通过。

### 使用泛型

　　使用泛型的方法如下：

```java
public class Person<N, A> {
    private N name;
    private A age;

    public Person(N name, A age) {
        this.name = name;
        this.age = age;
    }
    // 注意，静态属性中的泛型和类名后面声明的泛型<N, A>没有关系
    static <R> R m1(R r) {
        return r;
    }

    public N getName() {
        return name;
    }

    public void setName(N name) {
        this.name = name;
    }

    public A getAge() {
        return age;
    }

    public void setAge(A age) {
        this.age = age;
    }
}

public static void main(String[] args) throws Exception {
    Person<String, Integer> person = new Person("张三",18);
}
```

## 泛型原理

### 类型擦除

　　Java中的泛型只存在于源码中，编译器在编译源码时，会将创建对象时指定的类型都用`Object`类型代替，我们把它叫做类型擦除。当需要访问对象中的属性时，编译器再自动将`Object`类型强转为原类型。

　　举个例子，这是Java源码：

```java
HashMap<String, String> map = new HashMap<>();
map.put("张三", "18");
String age = map.get("张三");
```

　　这是字节码反编译后的代码：

```java
HashMap<String, String> map = new HashMap();
map.put("张三", "18");
// 可以看到，编译器自动将Object类型强转为了String类型
String age = (String)map.get("张三");
```

　　所有的泛型属性，在虚拟机看来都是`Object`类型。

### 泛型的缺点

　　Java泛型的缺点有：

　　1、不支持基本类型，因为`Object`不是基本类型的父类；

　　2、无法确定泛型的具体类型，因为所有泛型在编译后都是`Object`类型；

　　3、无法实例化泛型类型，因为无法确定具体类型。

### 错误的重写

　　泛型的类型擦拭可能会导致错误的重写：

```java
public class Person<T> {
    // 类型擦除后，equals方法变成了对Object类中方法的重写，编译器会禁止这种因类型擦除导致的重写行为
    public boolean equals(T t) {
        return this == t;
    }
}
```

## 泛型通配符

　　泛型通配符的作用是限制泛型的边界，包括上界通配符`<? extends T>`、下界通配符`<? super T>`和无界通配符`<?>`。

### 上界通配符

　　上界通配符`<? extends T>`的作用是限制泛型的上边界，举个例子：

```java
class A {}
class B extends A {}
class C extends B {}
class D extends C {}
class E extends D {}


class Person<T> {
    private T type;
    
    public Person(T type) {
        this.type = type;
    }
    
    public T getType() {
        return this.type;
    }
    
    public void setType(T type) {
        this.type = type;
    }
}

public static void main(String[] args) throws Exception {
    Person<C> p1 = new Person<>(new C());
    Person<? extends A> p2 = p1;
    A type = p2.getType();
    p2.setType(new C()); //Error
}
```

　　**`<? extends A>`的意思是只能接收`A`类型或者其子类类型的对象**，因此p1能够赋值给p2。赋值后p2的类型一定是`A`类型或其子类类型，为了能安全地转型，`p2.getType()`方法的返回值类型是其泛型的上界`A`。而`p2.setType(new C())`编译失败，原因是`setType()`方法的参数是`<? extends A>`类型，理论上只要传进来的参数是`A`的子类型就可以编译通过，但由于`type`的实际类型是`C`，如果允许传进来一个`B`类型参数，虽然它是`A`的子类类型，但无法转换为实际的`C`类型，所以编译器索性禁止这种极易出现不安全转型的写法。**因此，诸如`set(<? extends T> t)`这种方法是无法通过编译的，而`<? extends T> get()`这样的方法可以通过编译，并且返回值类型是`T`类型。**

　

　　**上界通配符用于类的定义**

　　在类的定义中也可以使用上界通配符，作用是限制泛型的上界，例如：

```java
// 表示Person只接受C类型及其子类型
class Person<T extends C> {}

public static void main(String[] args) throws Exception {
    Person<E> p1 = new Person<>(new E());
    Person<B> p2 = new Person<>(new B()); // Error
    E type = p1.getType();
    p1.setType(new E());
}
```

　　在类的定义中使用上界通配符`<T extends C>`，它的意思是这个类只接受`C`类型或其子类类型的参数，**`set<T extends C>`方法可以通过编译，并且要求参数是`T`;类型或其子类类型，`<T extends C> get()`方法的返回值类型是`T`类型。**

### 下界通配符

　　下界通配符`<? super T>`的作用是限制泛型的下边界，举个例子：

```java
class A {}
class B extends A {}
class C extends B {}
class D extends C {}
class E extends D {}


class Person<T> {
    private T type;
    
    public Person(T type) {
        this.type = type;
    }
    
    public T getType() {
        return this.type;
    }
    
    public void setType(T type) {
        this.type = type;
    }
}

public static void main(String[] args) throws Exception {
    Person<C> p1 = new Person<>(new C());
    Person<? super D> p2 = p1;
    Object type = p2.getType();
    p2.setType(new E());
}
```

　　**`<? super A>`的意思是只能接收`D`类型或者其父类类型的对象**，因此p1能够赋值给p2。赋值后p2的类型一定是`D`类型或其父类类型，父类类型最高是`Object`，为了能安全地转型，`p2.getType()`方法的返回值类型就是`Object`。而`p2.setType()`方法要求参数是`<? super D>`类型，`type`的实际类型是`C`，为了保证能够安全地转型，编译器要求`setType()`方法的参数必须是`D`类型或其子类类型。**因此，诸如`set(<? super T> t)`这种方法可以通过编译，但是参数类型必须是`T`类型或它的子类类型，而`<? super T> get()`这样的方法返回值类型是`Object`类型。**

### 无界通配符

　　无界通配符`<?>`没有边界，它是所有泛型的父类类型，因此可以接收任何类型的泛型：

```java
Person<C> p1 = new Person<>(new C());
Person<?> p2 = p1;
```

　　诸如`set(<?> t)`这样的方法无法通过编译，`<?> get()`这样的方法返回的是`Object`类型。

### 三种通配符的对比

| 通配符                    | 赋值                                | set(V v)                        | V get()              |
| ------------------------- | ----------------------------------- | ------------------------------- | -------------------- |
| `<? extends T>`           | 可以接收`T`类型或其子类型的泛型对象 | 编译报错                        | 返回值是`T`类型      |
| `<? super T>`             | 可以接收`T`类型或其父类型的泛型对象 | 方法参数必须是`T`类型或其子类型 | 返回值是`Object`类型 |
| `<?>`                     | 可以接受任意类型的泛型对象          | 编译报错                        | 返回值是`Object`类型 |
| 类定义中的`<T extends C>` | 可以接收`C`类型或其子类型           | 方法参数必须是`T`类型或其子类型 | 返回值是`T`类型      |
