---
title: Java语言基础之泛型
categories: Java语言基础
tags: Java语言基础
layout: post
---



## 概述

### 定义

　　泛型是一种模板，创建对象的时候约定好参数类型，使用对象的时候必须遵循约定，否则编译不通过。

### 使用泛型

　　使用泛型的方法如下：

```java
public class Person<N, A> {
    private N name;
    private A age;

    public Person(N name, A age) {
        this.name = name;
        this.age = age;
    }
    // 注意，静态属性中的泛型和类名后面声明的泛型<N, A>没有关系
    static <R> R m1(R r) {
        return r;
    }

    public N getName() {
        return name;
    }

    public void setName(N name) {
        this.name = name;
    }

    public A getAge() {
        return age;
    }

    public void setAge(A age) {
        this.age = age;
    }
}

public static void main(String[] args) throws Exception {
    Person<String, Integer> person = new Person("张三",18);
}
```

## 泛型原理

### 类型擦除

　　Java中的泛型只存在于源码中，编译器在编译源码时，会将创建对象时指定的类型都用`Object`类型代替，我们把它叫做类型擦除。当需要访问对象中的属性时，编译器再自动将`Object`类型强转为原类型。

　　举个例子，这是Java源码：

```java
HashMap<String, String> map = new HashMap<>();
map.put("张三", "18");
String age = map.get("张三");
```

　　这是字节码反编译后的代码：

```java
HashMap<String, String> map = new HashMap();
map.put("张三", "18");
// 可以看到，编译器自动将Object类型强转为了String类型
String age = (String)map.get("张三");
```

　　所有的泛型属性，在虚拟机看来都是`Object`类型。

### 泛型的缺点

　　Java泛型的缺点有：

　　1、不支持基本类型，因为`Object`不是基本类型的父类；

　　2、无法确定泛型的具体类型，因为所有泛型在编译后都是`Object`类型；

　　3、无法实例化泛型类型，因为无法确定具体类型。

### 错误的重写

　　泛型的类型擦拭可能会导致错误的重写：

```java
public class Person<T> {
    // 类型擦除后，equals方法变成了对Object类中方法的重写，编译器会禁止这种因类型擦除导致的重写行为
    public boolean equals(T t) {
        return this == t;
    }
}
```

## 泛型通配符

### extends通配符

　　类型擦除后的默认类型是`Object`，**extends通配符可以指定类型擦除后的类型**，例如：

```java
class Person<A> {
    private A age;
    
    public Person(A age) {
        this.age = age;
    }
    
    public A getAge() {
        return this.age;
    }
    
    public void setAge(A age) {
        this.age = age;
    }
}

public static void main(String[] args) throws Exception {
    Person<Integer> p1 = new Person(18);
    Person<? extends Number> p2 = p1;
    Number age = p2.getAge();
    // 编译报错
    p2.setAge(20);
}
```

　　在上述代码中，p1对象中age被类型擦除后变成了`Object`类型，p2对象中age被类型擦除后变成了`Number`类型，它们之所以能够擦除成功，就是因为`Object`和`Number`都是`Integer`的父类，可以安全地转换类型。

　　p2调用`getAge()`方法后返回了`	Number`类型的age属性，由于age的原类型是`Integer`，因此对它进行强制转型是安全的。p2调用`setAge()`方法时编译报错，原因是`setAge()`方法要求参数是`Number`类型或者它的子类，而age的原类型是`Integer`，将`Number`类型转换成`Integer`类型是不安全的，编译器会禁止出现这样的代码。**因此，如果一个对象使用了extends通配符，它的`setter()`方法将无法使用。**

　　除了在创建对象时使用extends通配符，在定义类时也可以使用，作用也是指定类型擦拭后的类型：

```java
class Person<A extends Number> {
    private A age;
}
```

### <font color='red'>super通配符(没太看懂)</font>

　　super通配符是这样使用的：

```java
class Person<A> {
    private A age;
    
    public Person(A age) {
        this.age = age;
    }
    
    public A getAge() {
        return this.age;
    }
    
    public void setAge(A age) {
        this.age = age;
    }
}

public static void main(String[] args) throws Exception {
    Person<Number> p1 = new Person(18);
    Person<? super Integer> p2 = p1;
    Object age = p2.getAge();
    // 编译通过
    p2.setAge(20);
}
```

　　**如果一个对象使用了extends通配符，它的`setter()`方法可以使用。**

### <font color='red'>无限定通配符</font>

　　无限定通配符`<?>`。
