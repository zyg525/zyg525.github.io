---
title: JVM面试题
categories: JVM
layout: post
---



## 内存布局

### 1、介绍一下JVM的内存区域

　　JVM的内存区域主要由**Java堆、虚拟机栈、本地方法栈、程序计数器、方法区**五个部分组成，其中Java堆和方法区是所有线程共享的，虚拟机栈、本地方法栈、程序计数器是线程独立的。

　　Java堆中存放的是对象实例，它是内存回收的主要区域，也成为GC堆。

　　Java方法每次执行时都会创建一个栈帧，用来存放局部变量等数据，虚拟机栈则用来存放栈帧。

　　本地方法栈和虚拟机栈的作用类似，区别是它针对的是native方法。

　　程序计数器记录了正在执行的字节码指令的地址。

　　方法区用来存放类加载后的类型信息、静态变量、常量等。

### 2、描述一下对象的创建过程

　　**1、类加载检查**：当虚拟机执行到一个字节码new指令时，会先检查这个指令的参数能否在常量池中定位到一个类的符号引用，并且检查这个类是否已经被加载、解析、初始化，如果没有，就要先完成类加载过程；

　　**2、分配内存**：虚拟机为对象分配内存，对象所需内存大小在类加载完成后就可以确定；

　　**3、初始化零值**：虚拟机将分配好的内存初始化为零值；

　　**4、设置对象头**：对象头中存放着对象的类型、哈希码、GC分代年龄、锁状态标志等信息；

　　**5、执行构造方法**：new指令执行完后，虚拟机会执行对象的构造方法，为成员变量赋值，这时一个真正的对象就创建好了。

### 3、什么是内存泄漏、内存溢出？

　　内存泄漏指的是已经申请的内存空间无法被释放。

　　内存溢出指的是申请的内存空间超过了可用容量。

## 内存回收

### 1、怎样判断对象是否存活？

　　主流的方法是通过**可达性分析算法**来判断，可达性分析算法会从根对象开始，根据引用关系往下搜索，如果一个对象和根对象没有直接或间接的引用关系，那么这个对象就是死亡的，否则就是存活的。

### 2、哪些对象可以作为根对象？

　　常量、静态变量、局部变量等。

### 3、介绍一下强引用、软引用、弱引用、虚引用

　　这四个引用的强弱程度依次减弱。强引用就是普通的赋值引用，强引用对象不会被回收；软引用对象会在内存溢出前回收；弱引用对象会在下一次垃圾收集时回收；无法通过虚引用获取到一个对象，它的作用只是在垃圾收集时获得一个通知。

### 4、介绍一下Java堆的分代

　　为了方便回收内存，目前流行的虚拟机都把Java堆分成了新生代和老年代，新生代中存放着存活时间较短的对象，老年代中存放着存活时间较长的对象。

### 5、介绍一下垃圾收集算法

　　主要有三种垃圾收集算法：**标记-清除，标记-复制，标记-整理**。

　　标记-清除算法的缺点是，当死亡对象很多时要进行大量标记，并且会产生很多空间碎片。

　　标记-复制算法的缺点是，当存活对象很多时要进行大量复制，并且可用内存会减少一半。

　　标记-整理算法的缺点是，当存活对象很多时要进行大量移动。

### 6、简述分配内存和回收内存的过程

　　新对象优先在新生代进行分配。新生代由一块较大的Eden空间和两块大小相同、较小的Survivor空间构成，新创建的对象会优先在Eden空间和其中一块Survivor空间进行分配，如果空间不足，就会触发Minor GC，回收新生代中的死亡对象，并将存活的对象放入另一块Survivor空间，如果放不下，就会放入老年代，老年代中存放着大对象和长期存活的对象。

### 7、什么情况下出触发Full GC？

　　当老年代或方法区内存不足时会触发Full GC。

### 8、介绍一下常见的垃圾收集器

　　1、Serial + Serial Old：它们是最基础的垃圾收集器，单线程执行收集任务，采用标记-复制和标记整理算法算法。

　　2、ParNew：新生代收集器，多个收集线程并行执行任务，收集时用户程序必须暂停，采用标记-复制算法；

　　3、Parallel Scavenge + Parallel Old：新生代收集器，多个收集线程并行执行任务，收集时用户程序必须暂停，采用标记-复制和标记整理算法，它的目标是达到一个可控制的吞吐量。

　　4、CMS：老年代收集器，收集线程和用户线程并发执行，用户程序不需要暂停(大部分时间)，采用标记-清除算法。它的目标是让回收停顿时间变短，适用于对响应速度要求比较高的系统。

　　5、G1：可用回收堆内存任何区域，采用标记-清除和标记-整理算法，它的目标是在延迟可控的情况下获得尽可能高的吞吐量。