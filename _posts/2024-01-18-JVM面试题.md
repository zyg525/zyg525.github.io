---
title: JVM面试题
categories: JVM
layout: post
---



## 内存布局

### 1、介绍一下JVM的内存区域

　　JVM的内存区域主要由**Java堆、虚拟机栈、本地方法栈、程序计数器、方法区**五个部分组成，其中Java堆和方法区是所有线程共享的，虚拟机栈、本地方法栈、程序计数器是线程独立的。

　　Java堆中存放的是对象实例，它是内存回收的主要区域，也成为GC堆。

　　Java方法每次执行时都会创建一个栈帧，用来存放局部变量等数据，虚拟机栈则用来存放栈帧。

　　本地方法栈和虚拟机栈的作用类似，区别是它针对的是native方法。

　　程序计数器记录了正在执行的字节码指令的地址。

　　方法区用来存放类加载后的类型信息、静态变量、常量等。

### 2、描述一下对象的创建过程

　　**1、类加载检查**：当虚拟机执行到一个字节码new指令时，会先检查这个指令的参数能否在常量池中定位到一个类的符号引用，并且检查这个类是否已经被加载、解析、初始化，如果没有，就要先完成类加载过程；

　　**2、分配内存**：虚拟机为对象分配内存，对象所需内存大小在类加载完成后就可以确定；

　　**3、初始化零值**：虚拟机将分配好的内存初始化为零值；

　　**4、设置对象头**：对象头中存放着对象的类型、哈希码、GC分代年龄、锁状态标志等信息；

　　**5、执行构造方法**：new指令执行完后，虚拟机会执行对象的构造方法，为成员变量赋值，这时一个真正的对象就创建好了。

### 3、什么是内存泄漏、内存溢出？

　　内存泄漏指的是已经申请的内存空间无法被释放。

　　内存溢出指的是申请的内存空间超过了可用容量。

## 内存回收

### 1、怎样判断对象是否存活？

　　主流的方法是通过**可达性分析算法**来判断，可达性分析算法会从根对象开始，根据引用关系往下搜索，如果一个对象和根对象没有直接或间接的引用关系，那么这个对象就是死亡的，否则就是存活的。

### 2、哪些对象可以作为根对象？

　　常量、静态变量、局部变量等。

### 3、介绍一下强引用、软引用、弱引用、虚引用

　　这四个引用的强弱程度依次减弱。强引用就是普通的赋值引用，强引用对象不会被回收；软引用对象会在内存溢出前回收；弱引用对象会在下一次垃圾收集时回收；无法通过虚引用获取到一个对象，它的作用只是在垃圾收集时获得一个通知。

### 4、介绍一下Java堆的分代

　　为了方便回收内存，目前流行的虚拟机都把Java堆分成了新生代和老年代，新生代中存放着存活时间较短的对象，老年代中存放着存活时间较长的对象。

### 5、介绍一下垃圾收集算法

　　主要有三种垃圾收集算法：**标记-清除，标记-复制，标记-整理**。

　　标记-清除算法的缺点是，当死亡对象很多时要进行大量标记，并且会产生很多空间碎片。

　　标记-复制算法的缺点是，当存活对象很多时要进行大量复制，并且可用内存会减少一半。

　　标记-整理算法的缺点是，当存活对象很多时要进行大量移动。

### 6、简述分配内存和回收内存的过程

　　新对象优先在新生代进行分配。新生代由一块较大的Eden空间和两块大小相同、较小的Survivor空间构成，新创建的对象会优先在Eden空间和其中一块Survivor空间进行分配，如果空间不足，就会触发Minor GC，回收新生代中的死亡对象，并将存活的对象放入另一块Survivor空间，如果放不下，就会放入老年代，老年代中存放着大对象和长期存活的对象。

### 7、什么情况下出触发Full GC？

　　当老年代或方法区内存不足时会触发Full GC。

### 8、介绍一下常见的垃圾收集器

　　**1、Serial + Serial Old**：它们是最基础的垃圾收集器，单线程执行收集任务，采用标记-复制和标记整理算法算法。

　　**2、ParNew**：新生代收集器，多个收集线程并行执行任务，收集时用户程序必须暂停，采用标记-复制算法；

　　**3、Parallel Scavenge + Parallel Old**：新生代收集器，多个收集线程并行执行任务，收集时用户程序必须暂停，采用标记-复制和标记整理算法，它的目标是达到一个可控制的吞吐量。

　　**4、CMS**：老年代收集器，收集线程和用户线程并发执行，用户程序不需要暂停(大部分时间)，采用标记-清除算法。它的目标是让回收停顿时间变短，适用于对响应速度要求比较高的系统。

　　**5、G1**：可用回收堆内存任何区域，采用标记-清除和标记-整理算法，它的目标是在延迟可控的情况下获得尽可能高的吞吐量。

| 收集器            | 收集区域       | 线程数量   | 收集算法            | 特点                                         |
| ----------------- | -------------- | ---------- | ------------------- | -------------------------------------------- |
| Serial            | 新生代         | 单线程     | 标记-复制           | 最基础的收集器                               |
| Serial Old        | 老年代         | 单线程     | 标记-整理           |                                              |
| ParNew            | 新生代         | 多线程并行 | 标记-复制           | Serial的多线程并行版本                       |
| Parallel Scavenge | 新生代         | 多线程并行 | 标记-复制           | 目标是达到一个可控的吞吐量                   |
| Parallel Old      | 老年代         | 多线程并行 | 标记-整理           |                                              |
| CMS               | 老年代         | 多线程并发 | 标记-清除           | 目标是让回收停顿时间变短                     |
| G1                | 新生代和老年代 | 多线程并发 | 标记-清除、标记整理 | 目标是在延迟可控的情况下获得尽可能高的吞吐量 |

> 注：这里的多线程并行指的是会有多个线程执行回收任务，但用户线程必须暂停；多线程并发指的是回收线程和用户线程基本上可以同时执行。

## 类加载

### 1、描述一下类的生命周期

　　类的生命周期分为七个阶段：加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载。

　　**加载阶段**：获取类的二进制字节流，将静态存储结构转换为方法区的运行时数据结构，创建代表类的Class对象。

　　**验证阶段**：验证字节流，保证其符合虚拟机规范。

　　**准备阶段**：为静态变量分配内存，并初始化为零值。

　　**解析阶段**：将常量池中的符号引用解析为直接引用，直接引用和内存布局相关。

　　**初始化阶段**：为静态变量赋值，执行静态代码块，如果父类还没有初始化，会先初始化父类。

### 2、介绍一下双亲委派模型

　　Java中的类加载器主要有四种：从上往下分别是启动类加载器、扩展类加载器、应用程序类加载器、用户自定义类加载器。上层类加载器是下层类加载器的父加载器，当一个加载器收到加载类的请求时，会先将这个请求委派给父加载器去执行，每一层类加载器都是如此，如果父加载器无法加载类时，才会让子加载器去加载。

　　双亲委派模型的目的是为了避免程序中出现重复的类，保证系统的稳定。

### 3、自定义类加载器怎样破坏双亲委派模型？

　　如果想破坏双亲委派模型，就重写`ClassLoader`类中的`loadClass()`方法，如果想使用双亲委派模型，就重写`findClass()`方法。

### 4、举几个双亲委派模型被破坏的例子

　　1、JDBC会使用Java的核心类`Driver`来获取连接，这个类由启动类加载器加载，但它的实现类是由第三方厂商提供的，无法被启动类加载器加载，于是就在内部使用了线程上下文类加载器去加载，这个类加载器默认就是应用程序类加载器。这种行为破坏了双亲委派模型。

　　2、Tomcat中会部署多个Web应用，为了让不同的应用使用同一个类库，为每个Web容器都提供了单独的类加载器，应用优先使用自己的类加载器，如果加载不了才会去请求父加载器。这种行为也破坏了双亲委派模型。



