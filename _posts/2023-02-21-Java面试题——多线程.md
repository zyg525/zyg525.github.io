---
title: Java面试题——多线程
tags: Java面试题
---

## 一、基础

* ### 简述进程与线程的区别与联系

　　**联系**：都是用来实现并发任务的，进程实现了操作系统任务的并发，线程实现了进程任务的并发。

　　**区别**：

　　　　1、**进程是操作系统进行资源分配的基本单位，线程是CPU分配时间的基本单位**。一个进程内有多个线程。

　　　　2、进程拥有独立的内存空间，各个进程之间互不干扰；一个进程内的所有线程共享进程的堆内存和方法区内存，每个线程有自己的栈内存。

* ### 线程的创建方式有哪些？

　　1、**继承Thread类**，重写run方法；

　　2、**实现Runnable接口**，重写run方法，然后传入Thread的构造方法；

　　3、**实现Callable接口**，重写call方法，然后传入FutureTask的构造方法，再将新对象传入Thread的构造方法。和前两种方法不同的是，这种方式可以获取call方法的返回值。

　　Runnable和Callable都是函数式接口，可以用lambda表达式简化。

* ### 简述线程的6种状态以及转换过程

　　线程的6种状态分别是：**NEW(新建)、RUNNABLE(可运行)、BLOCKED(阻塞)、WAITING(等待)、TIMED_WAITING(超时等待)、TERMIATED(终止)**。

　　这6种状态的转换过程如下图所示：

![线程的6种状态](/assets/img/java/线程的6种状态.png)

　　各个状态之间的转换过程是：

　　1、新创建的线程处于NEW状态，当调用`start()`方法启动线程后就进入了RUNNABLE状态，更具体地说是进入了RUNNABLE状态中的**Ready(就绪)**状态，等待CPU为线程分配时间分片。

　　2、线程获取到CPU时间分片后进入RUNNABLE状态中的**Running(运行)**状态。

　　3、RUNNING状态下的线程无法获取到锁，就会进入**BLOCKED**状态，阻塞状态下的线程会失去时间分片。

　　4、BLOCKED状态下的线程获取到了锁，就会进入**Ready**状态。

　　5、RUNNING状态下的线程在执行过程中，被其它线程对象调用了`join()`方法，或者锁对象调用了`wait()`方法，都会进入**WAITING**状态，等待状态下的线程会失去时间分片，并释放锁。

　　6、WAITING状态下的线程在等待过程中，被其它线程唤醒，就会进入Ready状态。对于`join()`方法唤醒的方式就是调用线程结束，对于`wait()`方法唤醒的方式就是锁对象调用`notify()`或`notifyAll()`方法。

　　7、RUNNING状态下的线程在执行过程中，被其它线程对象调用了`join(long)`方法，或者调用了`sleep(long)`方法，或者对锁对象调用了`wait(long)`方法，都会进入**TIMED_WAITING**状态，它和WAITING状态的区别是在指定时间后会自动唤醒。

　　8、TIMED_WAITING状态下的线程在等待时间过后会自动唤醒，进入Ready状态，如果还在等待时间以内，并且锁对象调用了`notify()`或`notifyAll()`方法，也会被唤醒，进入Ready状态。

　　9、线程执行完成后就会进入TERMIATED。

> 　　**BLOCKED、WAITING、TIMED_WAITING的联系与区别：**
>
> 　　**联系**：线程在这三种状态下都会失去CPU时间分片。
>
> 　　**区别**：失去时间分片的原因不一样。BLOCKED是因为没有获取到锁而被动地失去时间分片，当锁被释放时，BLOCKED线程就会被唤醒；而WAITING和TIMED_WAITING是线程获取到了锁，但是在线程内部执行了一些方法(sleep()、join()、wait())，主动放弃了时间分片，当拥有锁的线程执行notify()或notifyAll()方法时，线程才会被唤醒。

* ### sleep()和wait()的区别是什么？

　　1、`sleep()`必须指定时间，`wait()`可以不指定时间；

　　2、`sleep()`不会释放锁，`wait()`会释放锁；

　　3、`sleep()`可以放在任何位置，`wait()`只能放在同步代码中。

* ### 什么是线程上下文切换？

　　一个CPU执行多个线程时，会给每个线程分配时间分片，线程在时间分片内占用CPU执行任务，当线程的时间分片用完后就会让出CPU，由其它线程占用。

* ### 什么是守护线程？

　　Java线程分为两种：守护线程和用户线程。它们的区别是，当所有用户线程都结束后，JVM才能退出，而守护线程是否结束并不影响JVM的退出。

* ### 介绍一下ThreadLocal

　　ThreadLocal是线程共享变量。可以把ThreadLocal看作是一个全局的`Map<Thread,Object>`，当它调用`set(Object o)`方法时，它会以当前线程对象作为key，o作为value进行存储。当它调用`get()`方法时，它会以当前线程对象为key，取出value。

　　它的原理是，多个线程共享一个ThreadLocal对象，每个线程对象中都有一个ThreadLocalMap对象，调用`set`方法实际上是以ThreadLocal对象为key、以值为value，加入线程独立的ThreadLocalMap对象；调用`get`方法实际上是以ThreadLocal对象为key，从线程独立的ThreadLocalMap对象中获取值。

## 二、JMM

* ### 简述Java内存模型(JMM)

　　1、所有变量都存储在主内存，每个线程都有自己的工作内存；

　　2、工作内存中保存了被该线程使用的变量的主存副本，线程对变量的所有操作都在工作内存中进行，不能直接操作主内存；

　　3、操作完成后，线程的工作内存通过缓存一致性协议将变量刷回主内存，但是刷新操作并不一定立刻发生。

* ### 说说你对原子性、可见性、有序性的理解？

　　**原子性**：指的是一个操作是不可分割、不可中断的，操作的过程中不会被任何因素打断。JVM使用`synchronized`保证代码块的原子性。

　　**可见性**：指的是一个线程修改了共享变量的值时，其它线程会立刻知道这个修改。JVM使用`volatile`保证共享变量的可见性。

　　**有序性**：指的是单个线程中的代码是从前往后依次执行的，多线程下可能会发生指令重排。JVM使用`synchronized`和`volatile`都可以保证多线程下的有序性。

* ### 简述volatile关键字的作用

　　volatile用来修饰变量，它的作用是：

　　1、保证共享变量对所有线程的**可见性**。如果没有volatile关键字，由于Java内存模型的存在，一个线程读取到的变量值不一定是主内存中的最新值，一个线程修改了的变量不一定会马上刷新回主内存。加了volatile之后，该变量一旦被修改就会立刻刷新回主内存，读取该变量时会去主内存中读取最新值。

　　2、**禁止指令重排**。CPU为了提高程序执行效率，允许多条指令不按照规定的顺序执行，只会保证最终结果的正确，这在单线程中是安全的，但是在多线程中是不安全的。volatile可以禁止对该变量进行指令重排，典型的应用就是双重检验锁实现单例模式时，共享变量要用volatile修饰。

## 三、锁

* ### 介绍一下synchronized重量级锁的原理

　　**`synchronized`锁实际上是一个对象，锁对象关联了一个`Monitor`对象，该对象中的`Owner`变量指向了持有锁的线程地址，`EntryList`集合中存放了正在阻塞的线程地址，`WaitSet`集合中存放了正在等待的线程地址**。当一个线程尝试获取锁时，发现`Owner`已经指向了其它线程，就会进入`EntryList`等待，直到锁被释放，`EntryList`中的所有线程都会唤醒，然后竞争锁。当持有锁的线程调用`wait`或`sleep`方法后，就会进入`WaitSet`等待，直到调用`notify`或超时后被唤醒。

* ### 介绍一下synchronized锁升级的过程

![锁升级过程](/assets/img/java/锁升级过程.png)

　　1、当只有一个线程在使用锁对象时，此时是偏向锁，对象头的`mark word`中存放的是线程id，偏向锁相当于没有锁；

　　2、当有多个线程在使用锁对象，但未发生锁竞争时，此时偏向锁升级为轻量级锁，对象头的`mark word`中存放的是锁记录，轻量级锁是通过线程栈中的锁记录对象来实现的；

　　3、当有多个线程在竞争锁时，并且超过了自旋时间或次数，轻量级锁就会升级为重量级锁，重量级锁是通过关联的`Monitor`对象实现的。

* ### 什么是CAS算法？

　　**CAS(Compare And Swap，比较并交换)是通过处理器指令来保证操作的原子性的**。CAS指令包括三个参数：共享变量的地址A、预期值B、新值C。只有当A处的值等于B时，才会将A处的值更新为C。

* ### ReentrantLock相比于synchronized的优点有哪些？

　　1、可以设置超时时间；

　　2、可以实现公平锁；

　　3、可以实现多条件变量。

* ### 什么是AQS

　　AQS指的是`AbstractQueuedSynchronizer`（抽象同步队列），它是通过Java代码来实现锁和同步器的一系列框架，`ReentrantLock、CountDownLatch`等都是通过AQS来实现的。

* ### 什么是可重入锁？

　　可以被同一个线程重复获取的锁叫做可重入锁，比如synchronized。

* ### 什么是死锁？

　　两个线程各自持有不同的锁，然后试图获取对方手里的锁，造成了无限等待，这就是死锁。

* ### 什么是公平锁和非公平锁？

　　公平锁指的是多个线程在等待同一个锁时，必须按照申请锁的顺序来依次获得锁，非公平锁不能保证这一点。

　　synchronized锁是不公平锁，ReentrantLock锁默认也是不公平锁，但可以设置为公平锁。非公平锁可以提高效率，但是有可能导致一些线程长时间得不到锁。

* ### 什么是悲观锁和乐观锁？

　　悲观锁指的是在访问共享变量时，悲观地估计有其它线程修改该变量，于是访问时加锁以确保线程安全。

　　乐观锁指的是在访问共享变量时，乐观地估计没有其它线程修改该变量，于是访问时不加锁，一般通过CAS操作确保线程安全。乐观锁适用于读操作频率远大于写操作的场景。

* ### 什么是自旋锁？

　　在悲观锁中，等待锁的线程会进入阻塞状态，阻塞状态下的线程不会占用CPU，但是挂起和恢复线程的动作会影响虚拟机性能。假如计算机有多个处理器(或者一个处理器有多个核心)，可以让两个或以上的线程并发执行，我们就可以让等待锁的线程“稍等一会”，但仍然占用CPU，看看持有锁的线程是否能很快释放锁。为了让锁等待，我们只需让线程执行一个忙循环，这就是**自旋锁**。

　　JDK中默认启用自旋锁，默认的自旋次数是**10次**。自旋锁的优点是避免了线程频繁的挂起和恢复，缺点是会占用CPU时间，自旋锁适用于锁被占用的时间很短的场景。

　　**自适应自旋锁**：锁的自旋次数不固定，而是根据上一次自旋的时间和锁拥有者的状态动态决定。

* ### 什么是锁消除？

　　锁消除指的是编译器对一些代码中要求同步，但是经过检测发现不存在共享数据竞争的锁进行消除。

* ### 什么是锁粗化？

　　频繁地对一段同步代码进行加锁解锁会消耗性能，所以虚拟机会将这段代码的锁范围扩大，这就是锁粗化。

* ### 简述ReentrantLock、ReentrantReadWriteLock、StampedLock的特点

　　**ReentantLock**：和synchronized很像，优点是可以指定获取锁的超时时间，避免长时间等待。一般情况下可以用synchronized代替。

　　**ReentrantReadWriteLock**：写的时候不允许其它线程写、读，读的时候不允许其它线程写，但是允许读。这是一种**悲观读锁**。

　　**StampedLock**：写的时候不允许其它线程写、读，读的时候允许其它线程写、读。这是一种**乐观读锁**。乐观读锁使用了`CAS`无锁方式实现线程安全，读的时候如果发现值发生了变化，会通过重试来获取新值。这种锁适用于读操作远多于写操作的场景。

* ### 介绍一下原子操作类

　　常见的原子操作类有`AtomicInteger、AtomicLong、AtomicBoolean`，它们都是通过CAS来实现数字运算的线程安全，相比于`synchronized`效率更高。

## 四、并发通信工具

* ### 介绍一下Semaphore

　　`Semaphore`是用来控制线程并发数量的工具。它维护了一个计数，线程的并发数量不能超过这个计数，超出计数的线程进入阻塞。

* ### 介绍一下CountDownLatch

　　`CountDownLatch`用于线程协作。它维护了一个计数，每当有一个线程调用它的`countDown`方法，计数减一，当计数减到0时，调用了它的`await`方法的线程就会被唤醒。

* ### 介绍一下CyclicBarrier

　　`CyclicBarrier`用于线程协作，它和`CountDownLatch`刚好相反。它也维护了一个计数，每当有一个线程调用它的`await`方法，就会进入阻塞，同时计数减一，当计数减到0时，所有阻塞的线程都会被唤醒，并且计数重置为初始值。

## 五、线程池

* ### 线程池的主要参数有哪些？

　　线程池的核心类是`ThreadPoolExecutor`，它有七个参数：

```java
public ThreadPoolExecutor(
    int corePoolSize,                    /*1、核心线程数量最大值*/
    int maximumPoolSize,                 /*2、总线程数量最大值，总线程数量包括了核心线程和非核心线程*/
    long keepAliveTime,                  /*3、非核心线程超时时间*/
    TimeUnit unit,                       /*4、时间单位*/
    BlockingQueue<Runnable> workQueue,   /*5、阻塞队列，用来存放等待执行的Runnable任务*/
    ThreadFactory threadFactory,         /*6、创建线程的工厂，可以设置线程名字*/
    RejectedExecutionHandler handler)    /*7、拒绝策略*/
```

　　线程池的工作流程是：

　　1、当任务数量不超过`corePoolSize`时，会始终创建核心线程来执行任务，并且核心线程不会结束，而是会一直尝试从阻塞队列中获取任务执行；

　　2、当任务数量超过了`corePoolSize`时，会将新任务放入阻塞队列中，等待被执行；

　　3、当阻塞队列已满时，线程池会创建非核心线程去执行新任务，核心线程与非核心线程的数量不能超过`maximumPoolSize`，当非核心线程超时仍未获取到任务时，就会结束；

　　4、当阻塞队列已满，并且线程数量超过了`maximumPoolSize`时，就会执行拒绝策略。拒绝策略有四种，分别是拒绝新任务并抛出异常、拒绝新任务但不抛出异常、丢弃队列中最早的任务、把新任务交给主线程执行。

* ### 有哪几种常见的线程池？

　　Executors类为我们定义好了一些常用的线程池，通过静态方法来获取。

　　**1、固定数量线程池**

　　只有核心线程，没有非核心线程，阻塞队列无界。适用于任务数量已知，比较耗时的任务。

```java
ExecutorService executor = Executors.newFixedThreadPool(2);
```

　　**2、缓冲线程池**

　　没有核心线程，只有非核心线程，超时时间是60秒，阻塞队列没有容量。适用于任务数量未知、耗时较短的任务。

```java
ExecutorService executor = Executors.newCachedThreadPool();
```

　　**3、单线程线程池**

　　只有一个核心线程，没有非核心线程，阻塞队列无界。它可以保证始终有一个线程在执行任务。

```java
ExecutorService executor = Executors.newSingleThreadExecutor();
```

　　**4、定时任务线程池**

　　可以定时执行任务的线程池。

```java
ExecutorService executor = Executors.newScheduledThreadPool(1);
```

* ### 怎样处理线程池异常？

　　`submit`执行线程池任务，通过`Future.get`接收异常信息。

* ### 介绍一下线程池的运行状态

　　线程池有5种运行状态：

　　1、**RUNNING**：可以接受新的任务，也可以处理阻塞队列中的任务。

　　2、**SHUTDOWN**：不再接受新的任务，但是可以处理阻塞队列中的任务。

　　3、**STOP**：不再接受新的任务，也不能处理阻塞队列中的任务，并且会中断正在执行的任务。

　　4、**TIDYING**：所有线程都终止了，有效线程数量为0。

　　5、**TERMINATED**：在执行完terminated()方法后进入该状态。

* ### 线程安全的集合类有哪些？

　　**ArrayList**

　　1、`CopyOnWriteArrayList`：它的原理是**读写分离+写时复制**，读取数据时不加锁，写入数据时会将数据复制一份，不影响原数据。缺点是读、写数据的一致性较差。

　　2、`vector`：原理是`synchronized`。

　　**Map**

　　1、`ConcurrentHashMap`：它的原理是`synchronized`和CAS。

　　2、`HashTable`：原理是`synchronized`。

　　**Set**

　　1、`CopyOnWriteArraySet`：它只是对`CopyOnWriteArrayList`的简单封装，原理相同。

　　**Queue**

　　1、`LinkedBlockingQueue`：原理是`ReentrantLock`锁。

　　2、`ArrayBlockingQueue`：原理是`ReentrantLock`锁。
