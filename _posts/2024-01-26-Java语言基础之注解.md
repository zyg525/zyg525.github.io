---
title: Java语言基础之注解
categories: 三、Java语言基础
tags: Java语言基础
layout: post
---



## 注解的原理

　　注解类的本质是接口，以下面的注解类为例：

```java
@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
public @interface Range {
    int min() default 0;
    int max() default 0;
}
```

　　这个注解类在编译后的class文件中，实际上是一个继承了`java.lang.annotation.Annotation`接口的子接口，`int min()`是一个标注了默认返回值的抽象方法。在运行阶段，虚拟机会为注解接口创建动态代理类，代理类大概是这样的：

```java
class $Proxy {
    Map map = new HashMap<String, Object>();
    
    Integer min(Integer length) {
        if(length == null) return 0;
        this.map.put("min", length);
        return length;
    }
    
    Integer max(Integer length) {
        if(length == null) return 0;
        this.map.put("max", length);
        return length;
    }
}
```

　　我们每一次在类、字段、方法上使用注解，都会创建代理类的实例，而注解中传入的参数就是代理方法的参数：

```java
// Range range1 = new $Proxy();
@Range(min = 2, max = 4)
String name = "张三";

// Range range2 = new $Proxy();
@Range(min = 2, max = 4)
String name = "李四";
```

## 元注解

### 概述

　　注解可以标注在类、接口、字段、方法上，也可以标注在注解类上，**我们把可以标注在注解类上的注解称为元注解，元注解代表了注解类本身的属性。**

### @Target元注解

　　`@Target`元注解决定了注解的作用域：

```java
// @Range只能标注在类和字段上，否则编译会报错
@Target({ElementType.TYPE, ElementType.FIELD})
public @interface Range {}
```

　　注解的作用域包括以下几种：

```java
public enum ElementType {
    // 类, 字段, 方法, 方法参数, 构造方法, 局部变量, 注解类
    TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, ANNOTATION_TYPE, PACKAGE, TYPE_USE
}
```

### @Retention元注解

　　`@Retention`元注解决定了注解的生命周期：

```java
@Retention(RetentionPolicy.RUNTIME)
public @interface Range {}
```

　　注解的生命周期包括以下几种：

```java
public enum RetentionPolicy {
    // 源码级别。只能在Java源码中使用注解，注解不会进入class文件
    SOURCE,

    // 字节码级别。只能在class文件中使用注解，注解不会被加载入内存
    CLASS,

    // 运行级别，可以在运行时使用注解，注解会和其它代码一样进入内存
    RUNTIME
}
```

　　源码级别的注解主要是给编译器用的，比如常见的`@Override`、`@Deprecation`。字节码级别的注解主要是给一些底层库使用的。而运行级别的注解是最常用的注解，在框架中大量存在。

### 其它元注解

　　使用`@Repeatable`这个元注解可以定义注解是否可重复。这个注解应用不是特别广泛。

　　使用`@Inherited`定义子类是否可继承父类定义的注解。`@Inherited`仅针对`@Target(ElementType.TYPE)`类型的注解有效，并且仅针对class的继承，对interface的继承无效。

## 获取注解

　　注解只是一个类，它本身对代码逻辑没有任何影响，我们使用注解时要先获取注解(实际上是注解实例)，然后读取它的属性，利用它的属性来实现功能。获取注解需要使用反射。

　　获取注解前，最好先判断注解在作用域是否存在，相关的方法是：

```java
class Person{
    @Range(min = 2, max = 4)
    String name = "张三";
}

public static void main(String[] args) throws Exception {
    // 判断注解在指定类上是否存在
    boolean isExists = Person.class.isAnnotationPresent(Range.class);
}
```

　　　获取注解实例和属性的方法是：

```java
public static void main(String[] args) throws Exception {
    // 获取注解实例
    Range range = Person.class.getAnnotation(Range.class);
    // 获取注解实例属性
    int min = range.min();
    int max = range.max();
}
```

## 自定义注解

　　自定义注解，实现在运行时限制字段长度：

　　注解类`@Range`：

```java
@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
public @interface Range {
    int min() default 0;
    int max() default 0;
}
```

　　使用注解的类`Person`：

```java
class Person {
    @Range(min = 2, max = 4)
    public String name = "张三123";
}
```

　　执行注解的方法：

```java
static void checkLength(Person p) throws Exception {
    // 1、获取Person实例中的所有字段
    Field[] fields = p.getClass().getFields();
    for(Field field : fields) {
        // 2、获取字段上的所有@Range注解
        Range range = field.getAnnotation(Range.class);
        if(range != null) {
            Object o = field.get(p);
            if(o instanceof String) {
                // 3、判断字段是否属于String类型
                String nameValue = (String) o;
                int length = nameValue.length();
                // 4、判断字段长度是否符合注解要求
                if(length < range.min() || length > range.max()) {
                    throw new RuntimeException("字段"+field.getName()+"长度超出范围!");
                }
            }
        }
    }
}

public static void main(String[] args) throws Exception {
    // 执行注解
    checkLength(new Person());
}
```

