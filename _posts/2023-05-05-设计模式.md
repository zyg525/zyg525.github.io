---
title: 设计模式
tags: 设计模式 Java规范
---

　　面向对象系统的设计追求的有两点：**高内聚、低耦合**。本文Java代码已上传到GitHub：<https://github.com/zyg525/design-parttern.git>。

## 一、创建型模式(creational)

* ### 工厂模式(factory)

* #### 1、静态工厂(static-factory)

　　静态工厂是最简单的工厂模式，它也叫做简单工厂。**静态工厂的核心是，将复杂对象的创建过程封装到工厂类的静态方法中，调用者通过调用这个静态方法创建对象**。

　　创建多种对象时，有两种方法：一是将所有对象的创建过程都写在一个静态方法中，然后在方法参数中传入对象类型，通过`if...else`来返回不同的对象；二是将不同对象的创建过程写在不同的静态方法中。

　　静态工厂的缺点是，当新增一种对象时，需要修改原有的静态方法，**只实现了高内聚，没有实现低耦合**。

* #### 2、工厂方法(factory-method)

　　工厂方法可以认为是对静态工厂的一种改进，**它们的区别是工厂中不再使用静态方法，而是实例方法，并且工厂类需要实现工厂接口**。

　　和静态工厂一样，创建多种对象时，也有同样的两种方法，这里不再赘述。

　　**工厂方法由于实现了工厂接口，因此当新增一种对象时，不需要修改原来的工厂方法，只需要针对新对象新增一个工厂实现类即可。实现了高内聚、低耦合**。

* #### 3、抽象工厂(abstract-factory)

　　静态工厂和工厂方法都是针对单个产品族的工厂模式。所谓产品族，就是一系列不同但存在关联的产品集合，比如苹果产品族包括苹果电脑、苹果手机，华为产品族包括华为电脑、华为手机，电脑和手机是不同的对象，苹果电脑和华为电脑也是不同的对象，但是华为电脑和华为手机可能会存在一些关联，比如华为的协同工作技术。**抽象工厂和工厂方法最主要的区别是，抽象工厂针对每个产品族都有一个工厂类，所有工厂类都实现了一个工厂接口，而工厂方法只针对一个产品族**。

　　

> **工厂模式在Java中的应用有：**
>
> 1、Spring容器用到了工厂模式，创建Bean对象的方法是`BeanFactory.getBean(Class var)`；
>
> 2、MyBatis中创建SqlSession时也用到了工厂模式，创建SqlSession对象的方法是`SqlSessionFactory.openSession()`；
>
> 3、JDBC中创建数据库连接Connection时也用到了工厂模式，创建Connection对象的方法是`DriverManager.getConnection(String url,String username,String password)`;

* ### 建造者模式(builder)

　　初始化一个对象可以通过构造方法或者setter方法实现，但是当一个对象的属性较多并且某些属性不一定需要时，如果使用构造方法初始化对象，需要定义很多构造方法，如果使用setter方法构造，由于多个set方法是非链式调用，因此很容易出错。使用建造者模式可以解决这个问题。

　　使用建造者模式的步骤是：

　　1、在对象类中创建一个静态内部类`Builder`；

　　2、在内部类中定义和外部类一样的属性，对对象中必有的属性创建构造方法，对不一定有的属性创建set方法，并返回内部类this对象；

　　3、在外部类中定义构造方法，参数是内部类对象，在构造方法中将内部类属性值复制给外部类属性；

　　4、在内部类中定义`build()方法`，在方法中调用外部类构造方法，传入内部类this对象，返回外部类对象。

　　

> **建造者模式在Java中的应用有：**
>
> 1、JDK中的StringBuilder就用到了建造者模式，可以链式调用`append`方法，并且对于不同的调用顺序创建出不同的对象。

* ### 单例模式(singleton)

　　单例模式的重点在于，在多线程环境下，保证系统中只存在一个实例。

　　单例模式有饿汉式和懒汉式两种，其中饿汉式在类加载的时候就创建了实例，懒汉式只有在调用方法后才会创建实例。还有一种枚举类写法，可以避免反射、反序列化的破解，但用的比较少。

* #### 1、饿汉式写法

　　1、在成员变量中初始化单例，并将其私有化；

　　2、私有化构造方法；

　　3、创建静态方法，作为外界获取单例的唯一方式。

* #### 2、懒汉式写法

　　懒汉式写法包括**双重检验锁和静态内部类**两种。

　　双重检验锁需要注意的地方是：**成员变量要用volatile修饰，在双重非null检验之间进行同步**。

　　静态内部类的写法是，创建一个静态内部类，在内部类中定义成员变量并初始化，在外部类中创建静态方法，返回内部类中的成员变量。**静态内部类只有在使用时才会被装载，因此可以实现饿汉式**。

　　

> **单例模式在Java中的应用有：**
>
> 1、Spring容器中的Bean默认都是单例的，即对于同一个容器，里面的Bean实例是唯一的。

* ### 原型模式(prototype)

　　根据现有对象的拷贝，创建新的对象。

## 二、结构型模式(structural)

* ### 适配器模式(adapter)

　　适配器模式用于将一种接口转换为另一种接口。

　　如果要将接口A转换为接口B，实现适配器模式的步骤是：

　　1、创建适配器类，让它实现接口B，并在成员变量中持有一个接口A的实例，通过构造方法初始化；

　　2、重写接口B的方法，在该方法中调用接口A的方法。

　　

> **适配器模式在Java中的应用有：**
>
> 1、Spring的AOP用到了适配器模式。 //TODO

* ### 桥接模式(bridge)

* ### 组合模式(composite)

* ### 装饰者模式(decorator)

　　当我们需要在运行期动态地给一个对象增加额外功能，并且不想使用继承时，可以使用装饰者模式。**装饰者模式的核心是，装饰类和被装饰类都要实现同一个接口，并且装饰类要持有一个被装饰类的引用，在构造方法中初始化这个引用，然后在方法中通过这个引用调用被装饰类的方法。**

　　**装饰者模式和代理模式的写法很像，它们的区别也很明显，代理模式往往只会写一个代理类，但装饰者模式往往有很多装饰者类，原因是代理模式要解决的问题是”代理“，而一个对象只能有一个代理，装饰者模式要解决的问题是”装饰“，一个对象很有可能被多次装饰**。

　　

> **装饰者模式在Java中的应用有：**
>
> 1、在JDK的IO中大量用到了装饰者模式，比如字符输入流`InputStreamReader`实际上是通过所持有的字节输入流`InputStream`来读取字节信息的，然后再将字节按照编码转换为字符。

* ### 外观模式(facade)

　　当你的程序中有很多子模块或子系统，而你需要为这些子模块提供一个统一的访问界面时，可以使用外观模式。外观模式体现了高内聚的设计思想。

* ### 享元模式(flyweight)

　　享元模式的作用是，尝试重复使用现有的同类对象，以节省内存。共享对象有内部状态和外部状态，内部状态共享，外部状态不共享，由客户端传入。

* ### 代理模式(proxy)

* #### 1、静态代理(static-proxy)

　　静态代理指的是代理关系在编译期就已经确定了，其写法是创建好代理类和被代理类，然后实现同一个接口，同时代理类持有一个被代理类的引用，通过这个引用来增强被代理类的方法。

* #### 2、动态代理(dynamic-proxy)

　　动态代理指的是代理关系在运行期才确定，其实现方式包括JDK动态代理和cglib动态代理，在JDK动态代理中，我们需要创建被代理类，然后创建Handler类，在这个类中写上我们要增强的逻辑，然后让JDK帮我们在运行期自动生成代理类。**因此，在动态代理中，不需要手动编写被代理类或手动编写代理关系**。

　　

> **代理模式在Java中的应用有：**
>
> 1、Spring中的AOP就用到了动态代理。

## 三、行为型模式(behavioral)

* ### 责任链模式(chain-of-responsibility)

　　责任链模式把多个处理器串成链，然后让请求在链上传递。写法是定义多个处理器类，在每个处理器类中定义`setNextHandler`方法指定下游处理器，定义`handle`方法处理请求。最终请求只能被链中的一个处理器处理。

* ### 命令模式(command)

* ### 迭代器模式(iterator)

　　迭代器模式用于顺序访问集合对象的元素，而不需要知道集合对象的底层表示。迭代器的写法是，集合类实现`Iterable`接口，并重写`iterator()`方法，这个方法中会返回一个`Iterator`对象，`Iterator`接口中定义了遍历集合元素的`hasNext()`和`next()`等方法，因此还要定义一个内部类，实现`Iterator`接口，并重写`hasNext()`和`next()`等方法，在这些方法中自定义遍历元素逻辑。遍历集合元素时，只需要调用`iterator()`方法，通过`Iterator`对象进行遍历即可，无需了解集合中元素的存储细节。

　　

> **迭代器模式在Java中的应用有：**
>
> 1、JDK的集合类中就用到了迭代器模式，比如`List`中就定义了`iterator()`方法，用于返回遍历集合的`Iterator`对象。

* ### 备忘录模式(memento)

* ### 观察者模式(observer)

　　观察者模式也叫做**发布-订阅模式**。通常会定义一个生产者和多个消费者，生产者可以添加消费者作为订阅者，生产者属性发生变化后通知所有的订阅者，生产者也可以移除某个订阅者。

　　

> **观察者模式在Java中的应用有：**
>
> 1、Spring中的监听器就用到了观察者模式； //TODO
>
> 2、各种消息中间件也都用到了观察者模式。

* ### 策略模式(strategy)

　　策略模式定义了一组算法，然后将每一个算法封装起来，使用时可以互相替换。

　　

> 策略模式在Java中的应用有：
>
> 1、Spring容器在实例化对象的时候用到了策略模式。 //TODO

* ### 状态模式(state)

* ### 模板方法模式(template-method)

　　模板方法模式的核心思想是：**父类定义骨架、子类实现细节**。模板模式的的写法是，先创建模板类，一般是一个抽象类，在模板类中定义骨架方法，即可以重复使用的方法，并将骨架方法设为final类型，禁止子类重写，然后再定义一些抽象方法，供子类重写，不同的子类有不同的实现方式，此外还可以定义一些钩子方法，所谓钩子方法就是方法体中不做任何事的方法，子类可以重写这些方法，也可以不重写，较为灵活。

　　

> 模板方法模式在Java中的应用有：
>
> 1、各种和网络连接相关的`*Template`类都用到了模板方法模式，比如`JdbcTemplate、RedisTemplate、AmqpTemplate`等，这些类会将创建连接、释放连接等公共操作抽取出来放在父类中，让子类去实现非公共操作。

* ### 访问者模式(visitor)