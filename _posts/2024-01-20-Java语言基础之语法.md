---
title: Java语言基础之语法
categories: 三、Java语言基础
tags: Java语言基础
layout: post
---



## 数据类型

### 概述

　　Java的数据类型分为基本数据类型和引用数据类型。基本数据类型包括`byte、short、char、int、long、float、double、boolean`八种，它们所占的字节数分别是`1、2、2、4、8、4、8、4`，一个字节占8位二进制。

　　基本数据类型以外的都是引用数据类型，比如通常意义上的对象。

### 基本类型的表示范围

　　如果不考虑负数，那么对于`int`类型来说，**它的范围是`[0, 2^32-1]`**，其它基本类型也是一样的算法。

　　如果考虑负数，由于计算机中用最高位表示正负号，1代表负号，0代表正号，对于`int`类型，理论范围是`[-(2^31-1), 2^31-1]`；又由于计算机使用补码表示数字，补码的特点是`+0`和`-0`的二进制形式完全一样，只需要占用一个位置，而在原码或反码中，`+0`和`-0`要占用两个位置，因此在补码中可以省出来一个位置，用于存放最小的负数。**所以`int`类型的实际范围是`[-2^31, 2^31-1]`**，对应的二进制补码是`10...00(32bits)`~`01...11(32bits)`。其它基本类型也是一样的算法。

### 浮点类型的表示

　　`float`和`double`属于浮点类型，在定义浮点类型变量时，最好在数值后面加上`f`或者`d`，以显式声明它的具体浮点类型，否则默认是`double`类型。

```java
float f = 1.2; //编译报错
double d = 1.2; //编译通过
float f = 1.2f; //规范写法
```

### 常量

　　被`final`修饰的变量就是常量，常量在定义之后就不能再赋值。常量的一个作用是避免出现**魔法数字**，比如要使用圆周率3.14，可以将它赋值给一个常量，常量名通常是大写的、有意义的，这样在程序中使用圆周率时只需要引用常量即可，避免出错。

### 运算时类型转换

　　`byte、short、char`类型变量在运算时，会先转换成`int`类型，然后再进行运算。

```java
byte a = 1, b = 2;
byte c = a+b; //编译报错，因为返回的是int类型
```

## 运算规则

　　计算机内部是通过补码进行运算的。

### 整数运算

* #### 除法和取余

　　整数之间进行除法，结果取整。

```java
int a = 10 / 3; //结果是3
```

　　整数取余：

```java
int a = 10 % 3; //结果是1
```

* #### 自增自减

　　`++i`表示先自增再赋值，`i++`表示先赋值再自增。`--i`和`i--`也是一样的。

```java
int a = 10, b = 10;
int c = a++; //c赋值为10，然后a自增为11
int d = ++b; //b自增为11，然后d赋值为11
```

* #### 移位运算

　　只有整数能进行移位运算。移位运算包括左移、右移、无符号右移。

　　左移的计算过程是，先将整数转换为二进制补码，然后将补码的数值位向左移动n位(符号位不变)，低位补0，得到一个新的补码，这个新补码对应的原码就是最终的结果。**快捷的计算方法是，无论是正数负数，左移几位就是乘以2的几次方，符号不变**。

```java
int a = 1 << 2; //结果是4
```

　　右移的计算过程是，先将整数转换为二进制补码，然后将补码的数值位向右移动n位(符号位不变)，如果是负数则高位补1，如果是正数则高位补0，得到一个新的补码，这个新补码对应的原码就是最终的结果。**快捷的计算方法是，无论是正数负数，右移几位就是除以2的几次方，符号不变**。

```java
int a = -8 >> 2; //结果是-2
```

　　无符号右移的计算过程是，先将整数转换为二进制补码，然后将补码的符号位和数值位向右移动n位，高位补0，得到一个新的补码，这个新补码对应的原码就是最终的结果，由于高位补0，所以结果肯定是正数。**快捷的计算方法是，如果是正数，那么右移几位就是除以2的几次方，如果是负数，就需要通过补码进行计算了。**

　　**无符号的意思就是，符号位不作保留，和数值位一起移动。**

```java
int a = -2 >>> 1; //结果是2^31-1，原因是符号位被移动了
```

* #### 位运算

　　只有整数能进行位运算。位运算包括按位与、按位或、按位异或、按位非。

　　**按位与(`&`)**的计算过程是，先将整数转换为二进制补码，然后对补码进行按位运算，相同位都为1则为1，否则为0(包括符号位)，得到一个新的补码，这个新补码对应的原码就是最终的结果。**快捷的计算方法是，直接用对原码进行按位计算。**

```java
int a = 6 & 2; //结果是2，(0,110)原 & (0,010)原 = (0,010)原 = 2
```

　　**按位或(`|`)**的计算过程是，先将整数转换为二进制补码，然后对补码进行按位运算，相同位都为0则为0，否则为1(包括符号位)，得到一个新的补码，这个新补码对应的原码就是最终的结果。**快捷的计算方法是，直接用对原码进行按位计算。**

```java
int a = 6 | 2; //结果是6，(0,110)原 | (0,010)原 = (0,110)原 = 6
```

　　**按位异或(`^`)**的计算过程是，先将整数转换为二进制补码，然后对补码进行按位运算，相同位都为0或都为1则为0，否则为1，得到一个新的补码，这个新补码对应的原码就是最终的结果。

```java
int a = -6 ^ 2; //结果是-8
```

　　**按位非(`~`)**的计算过程是，先将整数转换为二进制补码，然后对补码按位取反(包括符号位)，得到一个新的补码，这个新补码对应的原码就是最终的结果。**快捷的计算方法是，`~(A) = -(A+1)`。**

```java
int a = ~ 6; //结果是-7
```

### 浮点数运算

* #### 除法和取余

　　计算机无法精确表示大部分的浮点数，因此浮点数的除法、取余的结果，可能会出现误差。浮点数参加的除法是不会取整的，这一点和整数不同。

### 布尔运算

　　属于布尔运算的运算符有比较运算符`>、>=、<、<=、==、!=`，有逻辑运算符`&&、||、&、|`，有三元运算符`true?a:b`。其中`&&`和`||`也叫短路运算符，当左边的值可以确定结果时，就不再计算右边。

### 运算时的转型

　　当低精度类型和高精度类型一起参与运算时，会将低精度自动转型为高精度，然后进行运算。

　　当把低精度类型数值赋值给高精度类型变量时，会将低精度类型自动转型为高精度。

　　当把高精度类型数值赋值给低精度类型变量时，必须进行强制转型，而且可能会损失精度。

## 字符串

### 字符串的表示

　　字符串用`""`包裹，如果字符串中包含字符`"`，就需要进行转义`\`：

```java
String s = "hello \" world";
System.out.println(s); // hello " world
```

　　还有一些特殊的转义字符：

```java
\n  换行符，将光标移动到下一行
\r  回车符，将光标移动到当前行的行首
\t  制表符，对齐表格的各列
\b  退格符，在文本中后退一步或删除一个字符
\f  换页符
\'  单引号'
\"  双引号"
\\  反斜杠\
\u****  Unicode编码
```

　　Java中用Unicode编码表示字符(`char`)，比如：

```java
char c = '\u0041';
System.out.println(c); // A
```

　　在字符串中也可以用Unicode编码来表示字符：

```java
String s = "\u0041\u0042";
System.out.println(s); // AB
```

### 字符串对象的不可变性

　　字符串对象是不可变的，字符串对象创建好之后就不能再被修改，只能改变其引用。字符串对象的不可变性是由以下三点来保证的：

　　1、`String`类内部用`private final char value[]`数组来存放字符，`private`对外部隐藏了数组，`final`保证了数组的引用不会被修改。但这还不够，数组仍有可能在`String`类内部被修改。

　　2、`String`类内部的所有方法，都不能修改数组元素。

　　3、`String`类被`final`修饰，不能被继承。

### 字符串常量池

* #### 字符串常量池的作用

　　在运行时常量池中，存在一个字符串常量池，用来存放字符串常量。字符串常量池是一个哈希表，因此里面的字符串对象不会重复。字符串常量池的作用是节省内存空间。

　　观察下面的代码：

```java
String s1 = "ab";
String s2 = "ab";
System.out.println(s1 == s2); //true
```

　　s1和s2指向同一个"ab"对象，原因是当第一次创建"ab"对象时，由于这个对象不可能被修改，因此它是一个常量，会被放进字符串常量池中，当第二次创建"ab"对象时，由于这个对象还是一个常量，因此会先去字符串常量池中去寻找是否有相同的常量，如果有就返回这个常量，如果没有就创建新的对象，然后放进字符串常量池。

* #### 字符串拼接

　　字符串拼接的方式包括变量拼接和常量拼接。

　　对变量进行拼接时(包括变量和常量进行拼接)，会先创建`StringBuilder`对象，然后调用它的`append()`方法进行拼接，最后调用它的`toString()`方法创建一个新的字符串对象并返回。也就是说，变量拼接后的结果永远是新的对象。

　　对于常量拼接，会在编译期进行优化，因为常量在运行期间是不会被修改的，因此拼接后的结果在运行期也不会被修改，所以编译器干脆直接将常量进行拼接好。因此实际上，`String s = "a"+"b"`编译成字节码后就变成了`String s = "ab"`。

　　观察下面的代码：

```java
String s1 = "a";
String s2 = "b";
String s3 = "ab";
String s4 = "a" + "b";
String s5 = s1 + s2;
System.out.println(s3 == s4); //true，原因是"ab"已经在字符串常量池中存在了
System.out.println(s3 == s5); //false，原因是变量拼接后的结果永远是新对象
```

* #### intern()方法

　　`intern()`方法的作用是，主动尝试将字符串对象放入字符串常量池，如果字符串常量池中已经存在相同字符串了，那么就返回字符串常量池中的字符串对象，如果不存在，就把对象放入常量池，然后返回该对象。

　　观察下面的代码：

```java
String s1 = "a";
String s2 = "b";
String s3 = s1 + s2;
String s4 = s3.intern(); //发现字符串常量池中没有"ab"对象，就将"ab"对象放入字符串常量池，并返回该对象
String s5 = "ab"; //发现字符串常量池中已经有"ab"对象了，所以直接返回该对象
System.out.println(s3 == s4); //true
System.out.println(s3 == s5); //true
```

> 注：以上特性适用于JDK8，其它版本的JDK可能会有不同。

## 流程控制

### while和do...while循环

　　while是先判断，再循环；do...while是先执行一次循环，再判断，再循环。

### for循环

　　for循环的语法是：

```java
for(初始条件; 循环检测条件; 循环后更新计数器) {
    ...
}
```

　　执行过程是，先执行初始条件，再检测循环条件，然后执行循环体，执行完后更新计数器，再检测循环条件，不断循环，直到不满足循环条件后退出。

　　初始条件、循环条件、计数器都可以省略，视具体情况而定。

### break、continue、return中断循环

　　break直接跳出循环；continue终止本次循环，开始执行下一次循环；return直接结束方法。

### switch...case分支语句

　　switch...case的语法是：

```java
String s = "b";
switch(s) {
    case "a":
        System.out.println("a");
        break;
    case "b":
        System.out.println("b");
    case "c":
        System.out.println("c");
        break;
    default:
        System.out.println("default");
        break;
}
```

　　`switch()`中的变量必须是`byte、short、char、int`类型、它们的包装类型、String类型、Enum类型。

　　如果缺少了`break`，程序会继续往下执行，直到遇见`break`。
