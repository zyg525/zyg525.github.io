---
title: Java语言基础之常用类
categories: Java语言基础
tags: Java语言基础
layout: post
---



## String

### String常用方法

　　和String类相关的常用方法有：

|                                       | 作用                                     | 例子                                                         |
| ------------------------------------- | ---------------------------------------- | ------------------------------------------------------------ |
| `String String.valueOf(int i)`        | 将整数转换为字符串                       | `String s = String.valueOf(123);`  // s = "123"              |
| `int Integer.parseInt(String s)`      | 将字符串转换为整数                       | `int i = Integer.parseInt("123");` // i = 123                |
| `String String(char[] c)`             | 将字符数组转换为字符串                   | `String s = new String(new char[]{'h','e','l','l','o'});` // s = "hello" |
| `char[] toCharArray()`                | 将字符串转换为字符数组                   | `char[] c = "hello".toCharArray();` // c = {'h','e','l','l','o'} |
| `byte[] getBytes(String charsetName)` | 将字符串按照指定的编码格式转换为字节数组 | `byte[] b = "hello".getBytes("UTF-8");`<br />`byte[] b = "hello".getBytes("GBK");` |

### StringBuilder

* #### 用法

　　`StringBuilder`可以用来拼接字符串，它的用法是：

```java
String s = new StringBuilder("a").append("b").append("c").toString(); // String s = "abc";
```

* #### 和`+`拼接的比较

　　使用`StringBuilder`拼接比使用`+`效率更高，原因是`+`底层也是使用`StringBuilder`进行拼接的，如果在循环体中进行拼接，`+`在每次循环时都会创建新的`StringBuilder`对象，而使用`StringBuilder`进行拼接时，不需要每次都创建新的对象：

```java
String s1 = "a";
for(int i=0;i<5;i++) {
    s1 += i; //每次都要创建StringBuilder对象
}

StringBuilder sb = new StringBuilder("b");
for(int j=0;j<5;j++) {
    sb.append(j); //不需要创建StringBuilder对象
}
String s2 = sb.toString();

System.out.println(s1); // s1 = a01234
System.out.println(s2); // s2 = a01234
```

* #### 内部实现

　　`StringBuilder`内部也是使用`char`数组存放字符串的，数组默认长度是字符串长度加16，也就说预留了16个字符，这样就可以避免每次拼接时都创建新的数组，当数组容量不足时才会创建新的数组进行扩容，数组扩容后的长度是在原长度2倍的基础上加2。

* #### StringBuffer

　　`StringBuffer`是Java早期`SpringBuilder`的线程安全版本，它的所有方法都被`synchronized`修饰，因此效率比较低，除此之外两者没有区别。

* #### StringJoiner

　　Java标准库提供了一个使用分隔符对字符串进行拼接的类`StringJoiner`，它的用法是：

```java
//用法1
StringJoiner sj = new StringJoiner("+", "begin: ", " :end"); // +是分隔符，begin: 是开头， :end是结尾
String s = sj.add("1").add("2").add("3").toString(); // String s = begin: 1+2+3 :end

//用法2
StringJoiner sj = new StringJoiner("+"); // +是分隔符，没有开头和结尾
String s = sj.add("1").add("2").add("3").toString(); // String s = 1+2+3
```

## 包装类

### 概述

　　每一种基本数据类型都有对应的包装类：`Byte、Short、Integer、Long、Float、Double、Character、Boolean`。**所有包装类都是不变类**，一旦初始化就不能再修改它的值，保证包装类不变性的方法和`String`类一样。

### 自动装箱、拆箱

　　自动装箱是指基本数据类型自动转换为包装类型，自动拆箱是指包装类型自动转换为基本数据类型。

```java
Integer a = 10; // 自动装箱
int b = new Integer(20); // 自动拆箱
```

　　自动装箱、拆箱是编译器对Java代码的优化，在编译后的class文件中，实际上调用了装箱方法`Integer.valueOf()`和拆箱方法`Integer.intValue()`。

### 缓存优化

　　`Byte、Short、Integer、Long`四种包装类型会对`[-128, 127]`（即byte的范围）之间的数进行缓存优化，当使用`valueOf()`方法获取这些数字的包装类型对象时，会返回同一个对象。

```java
Integer a = 10;
Integer b = Integer.valueOf(10);
Integer c = Integer.valueOf(10);
Integer d = new Integer(10);

System.out.println(a == b); // true，都调用了valueOf()方法
System.out.println(b == c); // true，都调用了valueOf()方法
System.out.println(c == d); // false，使用new创建的永远是新对象
```

　　`Character`会对小于等于127的字符进行缓存优化。

```java
Character c1 = 'a';
Character c2 = Character.valueOf('a');
Character c3 = Character.valueOf('a');
Character c4 = new Character('a');

System.out.println(c1 == c2); // true
System.out.println(c2 == c3); // true
System.out.println(c3 == c4); // false
```

　　因为包装类存在缓存优化，因此在创建包装类对象时，**最好使用`valueOf()`方法创建**，而不是使用构造方法。但即使包装类存在缓存优化，**包装类之间进行比较时也应该使用`equals()`方法**，而不是`==`。编程的一个原则是，按照语义编程，而不是针对特定的底层实现去”优化“。

### 包装类常用方法

|                                             | 作用                                   | 例子                                                     |
| ------------------------------------------- | -------------------------------------- | -------------------------------------------------------- |
| `Integer Integer.valueOf(int i)`            | 将基本类型转换为包装类型               | `Integer integer = Integer.valueOf(20);` // integer = 20 |
| `int Integer.intValue()`                    | 将包装类型转换为基本类型               | `int i = new Integer(20).intValue();` // i = 20          |
| `int Integer.parseInt(String s, int radix)` | 将字符串按照指定进制，转换为十进制整数 | `int i = Integer.parseInt("011", 16);` // i = 17         |
| `String Integer.toBinaryString(int i)`      | 将十进制整数转换为二进制字符串         | `String s = Integer.toBinaryString(8);` // s = "1000"    |
| `String Integer.toOctalString(int i)`       | 将十进制整数转换为八进制字符串         | `String s = Integer.toOctalString(8);` // s = "10"       |
| `String Integer.toHexString(int i)`         | 将十进制整数转换为十六进制字符串       | `String s = Integer.toHexString(16);` // s = "10"        |

## 枚举类

### 枚举类的本质

　　一个简单的枚举类是这么写的：

```java
public enum Weekday {
    SUN, MON, THU;
}
```

　　在Java代码层面，枚举类简洁地让人摸不着头脑，但实际上，编译器会帮我们增加很多内容，在编译后的字节码中，枚举类是这样的：

```java
public final class Weekday extends Enum {
    public static final Weekday SUN;
    public static final Weekday MON;
    public static final Weekday TUE;
    
    // 枚举对象名称
    private final String name;
    // 枚举对象序号
    private final int ordinal;
    
    // 构造方法
    public Weekday(String name, int ordinal) {
        this.name = name;
        this.ordinal = ordinal;
    }
    
    // 获取所有枚举对象
    public static Weekday[] values() {...}
    // 获取指定名称的枚举对象
    public static Weekday[] valueOf(String name) {...}
        
    // 在静态代码块中执行构造方法，创建枚举对象并赋值给静态字段
    static {
        SUN = new Weekday("SUN", 0);
        MON = new Weekday("MON", 1);
        THU = new Weekday("TUE", 2);
    }
    
    ...
}
```

　　因此枚举类对象(`SUN、MON、THU`)实际上是`Weekday`类中的静态常量字段，每个字段都指向`Weekday`类型的不同对象。枚举类对象只能在枚举类中创建，无法通过new创建，枚举类对象一旦创建好后就不能被修改，并且同一个枚举类内不会出现两个同名的枚举对象。

### 自定义枚举属性

　　我们也可以对枚举类的属性进行定制，比如增加英文名和中文名：

```java
public enum Weekday {
    SUN("sunday", "星期天"),
    MUN("monday", "星期一"),
    TUE("tuesday", "星期二");

    private final String enName;
    private final String cnName;
    
    Weekday(String enName, String cnName) {
        this.enName = enName;
        this.cnName = cnName;
    }

    public String getEnName() {
        return enName;
    }

    public String getCnName() {
        return cnName;
    }
}
```

　　创建定制枚举类对象时，实际上执行的是`new Weekday("SUN", "sunday", "星期天")`，也就是说编译器会对代码进行优化(修改)。

## BigInteger和BigDecimal

### BigInteger

　　在Java中，由CPU原生提供的整型最大范围是64位`long`型整数。使用`long`型整数可以直接通过CPU指令进行计算，速度非常快。如果我们使用的整数范围超过了`long`型怎么办？这个时候，就只能用软件来模拟一个大整数。`java.math.BigInteger`就是用来表示任意大小的整数。`BigInteger`内部用一个`int[]`数组来模拟一个任意大的整数，对它进行运算时，要调用实例方法：

```java
BigInteger a = new BigInteger("100");
BigInteger b = new BigInteger("30");

// 加法
BigInteger c = a.add(b);
// 减法
BigInteger d = a.subtract(b);
// 乘法
BigInteger e = a.multiply(b);
// 除法，向下取整
BigInteger f = a.divide(b);
// 取余
BigInteger g = a.mod(b);
```

### BigDecimal

　　和`BigInteger`类似，`BigDecimal`可以模拟一个任意大的、精度完全准确的浮点数，对它进行运算时，也要调用实例方法：

```java
BigDecimal a = new BigDecimal("100.6524973");
// 设置精度(小数位数)，这里使用了四舍五入法进行截取
BigDecimal c = a.setScale(4, RoundingMode.HALF_UP);

BigDecimal d = new BigDecimal("30.461231");
// 加法
BigDecimal e = a.add(d);
// 减法
BigDecimal f = a.subtract(d);
// 乘法
BigDecimal g = a.multiply(d);
// 除法，当除不尽时，要指定结果精度和截取的方法
BigDecimal h = a.divide(d, 3, RoundingMode.DOWN);
// 除法并取余，i[0]存放除法结果，i[1]存放取余结果
BigDecimal[] i = a.divideAndRemainder(d);

BigDecimal g = new BigDecimal("100.0");
BigDecimal k = new BigDecimal("100");
// 使用equals()比较是否相等时，如果精度不同就不相等，因此不推荐使用
boolean b1 = g.equals(k);
// 推荐使用compareTo比较大小，返回值为0时表示相等，为1时表示g大于k，为-1时表示g小于k
int b2 = g.compareTo(k);
```

