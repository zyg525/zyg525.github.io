---
title: JVM学习笔记
categories: JVM
layout: post
---



## 前端编译与优化

### 前端编译与优化的作用

　　前端编译的作用是把Java文件编译成class文件，优化的作用是提高程序员的编码效率。

　

### 前端编译过程

　　1、准备过程：初始化插入式注解处理器；

　　2、解析与填充符号表过程：词法语法分析，填充符号表；

　　3、插入式注解处理器的注解处理过程：插入式注解处理器的执行阶段；

　　4、分析与字节码生成过程：标注检查，数据流及控制流分析，解语法糖，字节码生成。

## 后端编译与优化

### 后端编译与优化的作用

　　后端编译的作用是把class文件翻译成本地机器码，优化的作用是让生成的机器码执行效率更高。

　

### 解释器和即时编译器

　　JVM通过**解释器**执行代码，当某段代码执行频率很高时，在运行时JVM会把这部分代码通过**即时编译器**翻译成本地机器码，并进行优化。解释器的特点是启动快、执行过程慢，即时编译器的特点是编译过程慢，但是执行机器码的速度很快，编译的过程比较消耗内存。一般两者一起工作，当程序启动后解释器首先发挥作用，随着时间推移，即时编译器逐渐发挥作用，把越来越多的代码翻译成本地机器码。

　

### 客户端编译器和服务端编译器

　　HotSpot虚拟机中内置了两个即时编译器，分别称为客户端编译器和服务端编译器，或者称为C1编译器和C2编译器，二者搭配使用的方式叫做“混合模式(Mixed Mode)”。C2编译器比C1编译器的编译过程更加复杂、更加激进。

　

### 编译对象与触发条件

　　即时编译器会将热点代码编译成机器码，热点代码分为两类：被多次调用的方法和被多次执行的循环体。

　　判断热点代码的方法叫做”热点探测“，主流的探测方法有：基于采样的热点探测和基于计数器的热点探测。

　

### 提前编译器

　　提前编译是指在代码运行之前就编译成机器码。

　

### 编译优化技术

　　编译优化的作用是让生成的机器码执行效率更高。常见的编译优化技术有：

　　1、**方法内联**：将目标方法中的代码复制到发起调用的方法内，避免发生真实的方法调用。

　　2、**逃逸分析**：一个对象在作用域内(可能是方法，也可能是线程)被定义，但是可能会被其它作用域访问到，称为逃逸。根据对象不同的逃逸程度，可以采取不同的优化方式。

　　　　常见的优化方式有：

　　　　**栈上分配**：堆内存线程共享，栈内存线程独立，如果一个对象不会逃逸出线程，那么可以给它在栈上分配内存，从而大大减轻垃圾收集系统的压力。

　　　　**标量替换**：如果一个对象不会被外部访问，那么在运行时可能不会创建这个对象，而是创建它的成员变量，即将对象拆分。

　　　　**同步消除**：如果一个变量不会逃逸出线程，那么对它的同步措施就可以消除掉。

　　　　**公共子表达式消除**：如果一个表达式在之前已经被计算过了，并且表达式中的所有变量值都没有修改过，那么对于这种表达式不需要再计算，只需要用前面的计算结果代替该表达式。

　　　　**数组边界检查**：为了避免数组越界，在运行期会对数组进行边界检查，频繁的检查很消耗性能，因此可以在后端编译时，根据条件来取消边界检查，比如数组在循环体中被访问，并且判断出循环变量的取值范围不超过数组长度，即不会出现数组越界，此时就可以取消边界检查。

　　　

## 类加载

### 类加载的七个阶段

　　加载->验证->准备->解析->初始化->使用->卸载。

### 加载

　　1、通过类的全限定名来获取定义此类的二进制字节流；

　　2、将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构；

　　3、在堆内存中生成一个代表这个类的Class对象，作为方法区这个类的各种数据的访问入口。

### 验证

　　1、文件格式验证。验证字节流是否符合Class文件格式的规范；

　　2、元数据验证。对字节码描述的信息进行语义分析，保证其符合规范，比如除了Object外的所有类都应该有父类；

　　3、字节码验证。通过数据流和控制流分析，保证程序语义合法，比如把一个对象赋值给一个不相干类型的引用是不合法的；

　　4、符号引用验证。检查该类是否缺少它依赖的某些外部类、方法、字段。

### 准备

　　为静态变量分配内存并设置初始值，这里的初始值指的是默认值，一般是0。

### 解析

　　将常量池中的符号引用替换为直接引用。符号引用用一组字符描述、定位目标，它与虚拟机实现的内存布局无关，而直接引用可以直接指向目标在内存中的位置，它与内存布局直接相关。

　　解析的目标包括类、接口、字段、类方法、接口方法。

### 初始化

　　初始化就是执行类构造器`<clinit>()`方法的过程，`<clinit>()`是由编译器自动收集类中的所有静态变量的赋值动作和静态代码块中的语句合并产生的，收集的顺序和在源文件中定义的顺序一致。**因此初始化实际上就是给静态变量赋值和执行静态代码块的过程**。

　　初始化的过程是：

　　1、当虚拟机启动时，会先初始化主类(即包含`main()`方法的类)；

　　2、使用new关键字实例化对象时，会初始化对象类型；

　　3、访问一个类的静态变量时，会初始化该类(被final修饰的静态变量不算，因为在编译器已经把结果放入了常量池中)；

　　4、调用一个类的静态方法时，会初始化该类；

　　5、使用反射调用某个类型时，会初始化该类；

　　6、如果当前正在初始化类的父类还没有初始化，那么会先初始化父类；

　　7、JDK8中新加入的接口`default()`方法，会在实现类初始化之前初始化；

　　8、对于接口，实现类的初始化不会触发其接口的初始化，接口的初始化不会触发其父接口的初始化；

　　9、如果多个线程去初始化同一个类，那么只有一个线程会去执行，其它线程会阻塞。

## 类加载器

　　“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作是在Java虚拟机的外部实现的，其目的是让应用程序自己决定如何去获取所需的类，实现这个动作的代码叫做类加载器。

　　对于任意一个类，必须由这个类和加载它的类加载器一起确立其在虚拟机中的唯一性，如果两个类来源于同一个class文件，但是由不同的类加载器加载，那这两个类必定不相等。

### 双亲委派模型

* #### 双亲委派模型的架构

　　自JDK1.2以来，Java一直保持着**三层类加载器、双亲委派**的类加载架构。

　　第一层类加载器是**启动类加载器**，它由C++实现，无法被Java程序直接引用。它负责加载存放在`<JAVA_HOME>\lib`目录中，或者是被`-Xbootclasspath`参数指定的路径中存放的，而且能被虚拟机识别的类库。启动类加载器也叫做**引导类加载器**。

　　第二层类加载器是**扩展类加载器**，它由Java实现，位于`sun.misc.Launcher$ExtClassLoader`。它负责加载`<JAVA_HOME>\lib\ext`目录中，或者是被`java.ext.dirs`系统变量所指定的路径中所有的类库。

　　第三层加载器是**应用程序类加载器**，它由Java实现，位于`sun.misc.Launcher$AppClassLoader`。它负责加载用户类路径(ClassPath)上的所有类库。如果程序中没有自己定义的类加载器，那么一般它就是程序默认的类加载器。程序类加载器也叫做**系统类加载器**。

　　双亲委派模型的架构是，扩展类加载器的父类加载器是启动类加载器，应用程序类加载器的父类加载器是扩展类加载器，用户自定义加载器的父类加载器是应用程序类加载器。

* #### 双亲委派模型的工作过程

　　双亲委派模型的工作过程是，如果一个类加载器收到了类加载的请求，它首先会将这个请求委派给父类加载器去执行，每一层的类加载器都是如此，因此所有的加载请求最后都会传送给启动类加载器，只有当父类加载器无法完成加载请求(即在它的搜索范围中没有找到目标类)时，子类加载器才会去尝试加载。

 　　因为类的唯一性是由class文件和类加载器共同决定的，如果由各个类加载器自行去加载类，就会导致同一个class文件加载出了不同的类，**双亲委派模型解决了这个问题，保证了虚拟机中类的唯一性**。

　　实现双亲委派的代码很简单，全部集中在`java.lang.ClassLoader`的`loadCLass()`方法中。

* #### 破坏双亲委派模型

　　双亲委派模型有三次较大规模被破坏的情况。

　　第一次是在双亲委派模型出现之前，这时类加载器的概念和抽象类`java.lang.ClassLoader`已经存在，用户自定类加载器是通过重写`ClassLoader`中的`loadCLass()`方法实现的，所以称为第一次破坏。后面引入了双亲委派模型，为了不影响旧代码，在`ClassLoader`中新增了一个`findClass()`方法，用户自定义类加载器如果要使用双亲委派模型，就要重写这个方法，如果不想使用双亲委派模型，就要重写`loadClass()`方法。

　　第二次是为了解决基础类型调用用户类型的问题，在双亲委派模型中，基础类型主要由启动类加载器来加载，而用户类型由应用程序类加载器或者自定义加载器来加载，在SPI(Service Provider Interface，服务提供者接口)中，**往往是在基础类型中调用用户类型，这是一种由父类加载器去请求子类加载器的行为**，JDBC就是一个例子。

　　第三次是为了解决代码热部署的问题。

* #### <font color='red'>破坏双亲委派模型的案例</font>

　　<font color='red'>案例1：JDBC(还需要整个类加载的过程)</font>

　　JDBC创建连接的代码是：

```java
Connection conn = DriverManager.getConnection()
```

　　`DriverManager`是一个基础类型，由启动类加载器加载，而`DriverManager`内部又会去加载`Driver`的具体实现类，这些实现类是由第三方厂商提供的，启动类加载器无法加载这些实现类，因此`DriverManager`内部使用了线程上下文类加载器(实际上是AppClassLoader)来加载这些实现类。

　

　　<font color='red'>案例2：Tomcat(还需要看tomcat源码，了解应用的类加载器到底是什么)</font>

　　由于Web服务器上会部署多个应用程序，如果它们使用同一个类库和同一个类加载器，那么只能同时加载一个类到虚拟机，这显然无法支持多个应用。Tomcat的解决办法是，为每个应用程序提供单独的类加载器，每个应用优先使用这个类加载器，只有当无法加载时才会去使用父类加载器，正好和双亲委派模型相反。

* #### <font color='red'>自定义类加载器</font>

　　如果自定义类加载器不想要继承双亲委派模型，那么就要重写`loadClass()`方法，如果想要继承双亲委派模型，就要重写`findClass()`方法。

　　<font color='red'>待办：自定义一个类加载器。</font>

## 运行时栈帧结构

### 栈与栈帧

* #### 概述

　　Javac编译器输出的字节码指令流，基本上是一种**基于栈的指令集架构**，与之相对应的是基于寄存器的指令集，最典型的就是x86的二地址指令集，即主流PC机中物理硬件直接支持的指令集架构。**基于栈的指令集的主要优点是可移植**(不受硬件约束)、**代码更加紧凑、编译器实现更加简单**等，**缺点是理论上执行速度会慢一点**，这里的执行速度主要局限在解释器层面，如果通过即时编译器编译成机器指令，就与指令集架构没有关系了，另外基于栈架构的**指令数量会比较多，**因为出栈入栈操作本身就产生了大量的指令，并且由于栈实现在内存中，**频繁的栈访问也就意味着频繁的内存访问**，对处理器来说，内存始终是执行速度的瓶颈。

　　**栈**是先进后出的数据结构，一个栈里面有多个**栈帧**。Java虚拟机以方法为最基本的执行单元，每执行一次方法就会生成一个栈帧，栈帧中存放着方法的**局部变量表、操作数栈、返回地址**等信息。

* #### 栈帧的组成

　　**局部变量表**：局部变量表中存放着方法参数和方法局部变量。局部变量表的最大容量在编译后就已经确定，以变量槽为最小单位，对于实例方法，第0个变量槽中存放的是所属对象的实例引用(即`this`)。

　　**操作数栈**：操作数栈的作用有两个，一是进行算术运算，二是当调用其它方法时，通过操作数栈来传递方法参数。操作数栈的最大深度在编译后就已经确定。

　　**返回地址**：当方法退出时，会将返回值传递给方法调用者，这时就需要用返回地址来定位调用者。

* #### 基于栈的解释器执行过程

　　代码：

```java
public int calc() {
    int a = 100;
    int b = 200;
    int c = 300;
    return (a+b)*c;
}
```

　　代码对应的字节码：

<img src="./../assets/img/java/基于栈的解释器执行过程.png" alt="基于栈的解释器执行过程" style="zoom: 80%;" />

　　执行过程：

　　PC-0：执行偏移地址为0的指令，将操作数100压入操作栈的栈顶；

　　PC-2：执行偏移地址为2的指令，将栈顶的100出栈并存放到局部变量表的1号变量槽中。后面的PC-3到PC-10都是同样的操作，对应的是代码中的三个赋值操作；

　　PC-11：将1号变量槽中的整形值100复制到操作栈顶；

　　PC-12：将2号变量槽中的整形值200复制到操作栈顶；

　　PC-13：将操作栈中头两个栈顶元素出栈，做整形加法，然后把结果300重新入栈；

　　PC-14：将3号变量槽中的整形值300复制到操作栈顶；

　　PC-15：将操作栈中头两个栈顶元素出栈，做整形乘法，然后把结果90000重新入栈；

　　PC-16：结束方法执行，并把操作栈顶的整形值返回给方法调用者。

### 虚方法与非虚方法

　　**非虚方法**指的是，**一个方法在运行之前就有了确定的版本，并且在运行期间不会改变**，换句话说，这个方法在运行之前就已经确定好要执行哪段具体代码了。符合这个要求的方法主要包括**静态方法、私有方法、构造方法、父类方法、final方法**，这些方法的一个共同点是都不可能通过继承或其它方式重写出其它版本，因此在类加载阶段就可以把方法的符号引用解析为直接引用。

　　非虚方法以外的方法都是**虚方法**。

### 重载与重写的实质

* #### 重载

　　重载指的是在一个类中，多个方法的方法名相同，参数列表不同。**当调用重载方法时，只能通过参数来判断最终要调用哪一个重载方法，而判断的依据是参数的静态类型，而非实际类型**。举个例子，在下面的代码中，`Human human = new Man(); `中的`Human`是静态类型，而`Man`是实际类型，**静态类型在编译期是可知的，而实际类型在编译期是不可知的**。

```java
public class Test {
    static class Human {
    }

    static class Man extends Human {
    }

    void sayHello(Human human) {
        System.out.println("Hello,human!");
    }

    void sayHello(Man man) {
        System.out.println("Hello,man!");
    }

    public static void main(String[] args) throws Exception {

        Human human = new Man();
        Test test = new Test();
        test.sayHello(human); //静态分派
        test.sayHello(new Man()); //动态分派
    }
}

打印结果：
Hello,human!
Hello,man!
```

　　所有依赖静态类型来决定方法执行版本的分派动作，都称为**静态分派**，静态分派最典型的表现就是方法重载。

* #### 重写

　　重写指的是子类继承父类，同时定义一个方法名、方法参数、返回值类型都与父类方法相同(也可以存在继承关系)的方法。当调用重写方法时，会根据运行期的实际类型来选择方法版本，并且如果在当前类型中没有找到目标方法，就会从下往上依次在父类中查找，如果找到了就会执行。下面是一个重写的典型例子：

```java
public class Test {
    static class Father {
        int money = 10;

        public Father() {
            money = 20;
            showMoney();
        }
        void showMoney() {
            System.out.println("I am father,I have $"+money);
        }
    }

    static class Son extends Father {
        int money = 30;

        public Son() {
            money = 40;
            showMoney();
        }
        @Override
        void showMoney() {
            System.out.println("I am son,I have $"+money);
        }
    }

    public static void main(String[] args) throws Exception {

        Father man = new Son(); //动态分派
        System.out.println(man.money); //访问字段属于静态分配
    }
}

打印结果：
I am son,I have $0
I am son,I have $40
20
```

　　在上面的代码中，执行父类构造方法时，调用的是子类中的重写方法，这说明方法分配的依据是实际类型，这叫做**动态分派**。另外，访问字段的依据是静态类型，属于静态分派。