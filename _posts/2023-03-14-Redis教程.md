---
title: Redis教程
tags: 其它
layout: post
categories: 十五、其它
---



## 一、安装Redis

　　**Redis是一个基于内存实现的key-value型非关系(NoSQL)数据库，由C语言编写**。Redis 用来缓存一些经常被访问的热点数据、或者需要耗费大量资源的内容，但是不适合存储较大的数据。

* ### 通过Docker安装Redis

　　1、下载Redis7镜像

```shell
docker pull redis:7
```

　　2、启动Redis服务

```shell
docker run -p 6379:6379 --name redis \
-v /mydata/redis/data:/data \
--restart=always \
-d redis:7 redis-server
```

　　3、连接Redis客户端

```shell
docker exec -it redis redis-cli
```

* ### 通过配置文件启动Redis

　　1、下载`redis.conf`配置文件并上传到服务器指定目录，这里上传到`/mydata/redis/config`目录下

　　2、挂载数据文件和配置文件，并通过配置文件启动

```shell
docker run -p 6379:6379 --name redis \
-v /mydata/redis/data:/data \
-v /mydata/redis/config/redis.conf:/config/redis.conf \
--restart=always \
-d redis:7 redis-server /config/redis.conf
```

## 二、Redis的5种常用数据类型

　　Redis用key-value存储数据，key一般是string类型，value有5种常用数据类型：**string、list、hash、set、zet**。

* ### key

　　关于key的一些常用命令如下：

　　1、判断key是否存在，存在返回1，不存在返回0

```shell
redis> EXISTS key1
```

　　2、查询与指定pattern匹配的key

```shell
redis> KEYS key*
```

　　3、修改key的名称

```shell
redis> RENAME key1 key2
```

　　4、删除key

```shell
redis> DEL key1
```

　　5、设置key的过期时间，以秒为单位

```shell
redis> EXPIRE key1 60
```

　　6、查询key剩余的过期时间(以秒为单位)，如果已经过期返回-2，如果永不过期返回-1

```shell
redis> TTL key1
```

* ### string

　　string是Redis中最简单的一种数据类型，它的常用命令如下：

　　1、为指定key设置value

```shell
redis> SET key1 value1
```

　　2、批量为key设置value

```shell
redis> MSET key1 value1 key2 value2 key3 value3
```

　　3、获取指定key的value

```shell
redis> GET key1
```

　　4、批量获取key的value

```shell
redis> MGET key1 key2 key3
```

　　5、为指定key设置value，并返回旧值

```shell
redis> GETSET key1 value2
```

　　6、获取指定key的value的长度

```shell
redis> STRLEN key1
```

　　7、截取指定key的value并返回，字符串索引从0开始，最后一个字符的索引可以用-1表示，倒数第二个索引可以用-2表示，以此类推

```shell
redis> GETRANGE key1 0 1
```

　　8、从指定索引处开始，用指定的字符串替换指定key的value

```shell
redis> SETRANGE key1 0 value3
```

* ### list

　　list相当于Java中的LinkedList，是一个链表，所以它增删快、查询慢。list可以实现**数组、双端队列**的功能。

　　list的常用命令如下：

　　1、从队列左边添加元素(string类型)

```shell
redis> LPUSH list1 element1 element2 element3
```

　　2、从队列右边添加元素

```shell
redis> RPUSH list1 element1 element2 element3
```

　　3、从队列左边开始，向第一个和指定元素相同的元素之前/之后插入新元素

```shell
redis> LINSERT list1 BEFORE targetElement newElement
redis> LINSERT list1 AFTER targetElement newElement
```

　　4、从队列左边开始，修改指定索引处的元素值，索引从0开始

```shell
redis> LSET list1 0 element4
```

　　5、从队列左边开始，获取指定索引处的元素

```shell
redis> LINDEX list1 0
```

　　6、从队列左边开始，获取指定索引范围内的元素

```shell
redis> LRANGE list1 0 -1
```

　　7、从队列左边开始，移除n个和指定元素相同的元素，n=0时代表全部移除

```shell
redis> LREM list1 2 element1
```

　　8、获取队列长度

```shell
redis> LLEN list1
```

　　9、从队列左边开始，弹出第一个元素

```shell
redis> LPOP list1
```

　　10、从队列右边开始，弹出第一个元素

```shell
redis> RPOP list1
```

　　11、从队列左边开始，弹出第一个元素，如果队列中没有元素，队列会进入阻塞状态，直到获取到元素，或者超出指定等待时间(单位是秒)

```shell
redis> BLPOP list1 60
```

　　12、从队列右边开始，弹出第一个元素，如果队列中没有元素，队列会进入阻塞状态，直到获取到元素，或者超出指定等待时间(单位是秒)

```shell
redis> BRPOP list1 60
```

* ### hash

　　Redis中的hash有点类似于Java中的Map，都是可以存储key-value对的集合，并且key不能重复。不同的地方在于hash的存储方式，它的key和value是相邻的两个元素，并且hash优先使用`ziplist`进行存储，`ziplist`是有序的，当超过大小限制后会使用`hashtable`进行存储，`hashtable`是无序的。

　　hash的常用命令如下：

　　1、添加或修改hash中的key-value对

```shell
redis> HSET hash1 key1 value1
```

　　2、获取key关联的value

```shell
redis> HGET hash1 key1
```

　　3、批量添加或修改hash中的key-value对

```shell
redis> HMSET hash1 key1 value1 key2 value2 key3 value3
```

　　4、批量获取key关联的value

```shell
redis> HMGET hash1 key1 key2 key3
```

　　5、删除一个或多个key-value对

```shell
redis> HDEL hash1 key1 key2 key3
```

　　6、获取hash中的所有key-value对

```shell
redis> HGETALL hash1
```

　　7、获取hash中的所有key

```shell
redis> HKEYS hash1
```

　　8、获取hash中的所有value

```shell
redis> HVALS hash1
```

　　9、判断hash中key是否存在

```shell
redis> HEXISTS hash1 key1
```

　　10、获取hash中key的数量

```shell
redis> HLEN hash1
```

* ### set

　　set用于存放不重复的元素，这一点和Java中的HashSet是一样的。它的增删、查询的时间复杂度都是O(1)。set可以实现**自动去重**。

　　set的常用命令如下：

　　1、向set中添加一个或多个元素，并自动去重

```shell
redis> SADD set1 element1 element2 element3
```

　　2、获取set中的所有元素

```shell
redis> SMEMBERS set1
```

　　3、判断元素是否存在于set中

```shell
redis> SISMEMBER set1 element1
```

　　4、获取set中元素的个数

```shell
redis> SCARD set1
```

　　5、移除set中的指定元素

```shell
redis> SREM set1 element1
```

　　6、求多个set之间的差集，这里的差集=前面的set-后面的set。可以将结果保存到指定set中

```shell
redis> SDIFF set1 set2 set3
redis> SDIFFSTORE targetSet set1 set2 set3
```

　　7、求多个set之间的交集，可以将结果保存到指定set中

```shell
redis> SINTER set1 set2 set3
redis> SINTERSTORE targetSet set1 set2 set3
```

　　8、求多个set之间的并集，可以将结果保存到指定set中

```shell
redis> SUNION set1 set2 set3
redis> SUNIONSTORE targetSet set1 set2 set3
```

* ### zset

　　zset也用来存放不重复元素，它和set的区别是，每个元素都关联了一个double类型的score(分数)，根据score的大小来决定元素的排列顺序，score越小越靠前。

　　zset的常用命令如下：

　　1、向zset中添加一个或多个元素，并自动去重

```shell
redis> ZADD zset1 1.2 element1 1.3 element2 1.1 element3
```

　　2、获取zset中指定索引范围内的元素

```shell
redis> ZRANGE zset1 0 -1
```

　　3、获取zset中指定score范围内的元素

```shell
redis> ZRANGEBYSCORE zset1 1.05 1.15
```

　　4、获取zset中指定score范围内的元素个数

```shell
redis> ZCARD zset1 1.05 1.15
```

　　5、移除zset中的一个或多个元素

```shell
redis> ZREM zset1 element1 element2
```

## 三、HyperLoglog基数统计

　　HyperLoglog是Redis-2.8.9中新增的数据类型，它用来存放**不重复元素的个数(基数)**，因为去重不够精确(0.81%的误差)，所以适用于对精度要求不是很高的大批量统计。

　　HyperLoglog的常用命令如下：

　　1、添加元素到HyperLoglog中

```shell
redis> PFADD pfset1 a b c a
```

　　2、获取HyperLoglog中不重复元素的个数

```shell
redis> PFCOUNT pfset1
```

　　3、将多个HyperLoglog合并为一个

```shell
redis> PFMERGE targetPfset pfset1 pfset2
```

## 四、GEO地理位置

　　GEO是Redis-3.2中新增的数据类型，它用来存放地理位置，底层用zset实现，看起来也很像zset，经纬度相当于score，位置名称相当于key。

　　GEO的常用命令如下：

　　1、添加地理位置到GEO集合中

```shell
redis> GEOADD city 116.20 39.56 beijing 120.52 30.40 shanghai
```

　　2、删除指定的地理位置

```shell
redis> ZREM city beijing
```

　　3、计算两个地理位置之间的距离，可以指定单位，m-米、km-千米、mi-英里、ft英尺

```shell
redis> GEODIST city beijing shanghai
```

　　4、以指定的经纬度或地理位置名称为中心，计算所有GEO集合中与中心之间的距离不超过指定距离的所有元素

```shell
redis> GEORADIUS city 116.20 39.56 1500 km WITHCOORD WITHDIST
redis> GEORADIUS city beijing 1500 km WITHCOORD WITHDIST
```

## 五、布隆过滤器

　　布隆过滤器是Redis-4.0版本提供的新功能，它的作用是可以判断过滤器中是否存在某个元素，实现**去重**功能。布隆过滤器的原理是，用k个不同的哈希算法去计算元素的哈希值，然后将哈希值对应的索引置为1，这样就可以保证相同的元素对应的索引相同，但是不能保证不同的元素对应的索引不同(哈希冲突)。相比于set，布隆过滤器的去重效率更高，但是不能存放或删除元素，只能判断元素是否存在。

　　通过Docker安装布隆过滤器的步骤是：

　　1、下载`redislabs/rebloom`镜像，它包含了Redis和布隆过滤器

```shell
docker pull redislabs/rebloom:latest
```

　　2、运行`redislabs/rebloom`容器

```shell
docker run -d -p 6379:6379 \
-v /mydata/redis-redisbloom/data:/data \
--name redis-redisbloom \
--restart=always \
redislabs/rebloom:latest
```

　　3、连接Redis客户端

```shell
docker exec -it redis-redisbloom redis-cli
```



　　布隆过滤器的常用命令如下：

　　1、(批量)添加元素到过滤器

```shell
redis> bf.add filter1 a
redis> bf.madd filter1 a b c
```

　　2、(批量)判断过滤器是否存在指定元素

```shell
redis> bf.exists a
redis> bf.mexists a b c
```

　　3、设置布隆过滤器参数值

```shell
redis> bf.reserve
```

## 六、发布订阅

　　Redis的PubSub模块是它的发布订阅模块，发布订阅实现了消息多播功能。客户端之间通过channel来传递消息，一个客户端可以订阅任意个channel。

　　PubSub中的常用命令如下：

　　1、客户端订阅一个或多个channel，执行该命令后客户端会进入等待接收消息的阻塞状态

```shell
redis> SUBSCRIBE channel1 channel2
```

　　2、客户端向某个channel发布消息

```shell
redis> PUBLISH channel1 hello
```

　　3、订阅符合指定pattern的channel

```shell
redis> SUBSCRIBE channel1* channel2*
```

　　4、退订符合指定pattern的channel

```shell
redis> UNSUBSCRIBE channel1* channel2*
```

　　5、获取所有在线的channel

```shell
redis> PUBSUB channels
```

　　6、获取客户端订阅的所有pattern的数量

```shell
redis> PUBSUB NUMPAT
```

　　7、返回指定channel的订阅者数量

```shell
redis> PUBSUB NUMSUB channel1
```

## 七、Redis事务

　　Redis事务的特点是：

　　**1、单条命令的执行是原子性的；**

　　**2、事务不支持回滚，即事务不是原子性的。**原因是Redis是一款基于内存的存储系统，其内部结构比较简单，若支持回滚机制，会让其变得冗余，并且损耗性能。

　　Redis事务分为三个阶段：**开始事务 -> 命令入队 -> 执行事务**。事务的常用命令如下：

```shell
redis> MULTI #开启一个事务
redis> SET name jack #命令入队
QUEUED
redis> SET age 18
QUQUED
redis> EXEC #执行队列中的所有命令
```

　　在执行`EXEC`命令时，会跳过队列中执行失败的命令，其它命令依然可以执行成功。开启一个事务后，也可以取消事务：

```shell
redis> MULTI #开启一个事务
redis> SET name jack #命令入队
QUEUED
redis> SET age 18
QUQUED
redis> DISCARD #取消事务
```



　　如何保证Redis事务的线程安全呢？可以通过**乐观锁**(CAS)来实现。假如多个客户端同时修改一个Redis共享变量，我们可以先监视这个变量，然后开启事务，当在事务中访问共享变量时，如果发现变量被修改，则事务不会执行。

```shell
redis> WATCH age #监视共享变量age
redis> MULTI #开启事务
redis> SET age 19
QUEUED
redis> EXEC #假如age的值发生了变化，那么EXEC命令不会执行
(nil)
redis> UNWATCH #取消监视
```

## 八、Redis数据持久化

　　Redis是一个基于内存的数据库，它会将数据全部存放在内存中，如果服务器突然宕机会导致数据丢失，因此需要有一种持久化机制将内存数据保存到本地磁盘中。Redis提供了两种持久化机制：**RDB和AOF**，当服务器恢复时，会通过磁盘中的持久化文件恢复数据。

* ### RDB

　　RDB(Redis DataBase)，即将数据作为数据库文件保存在本地，它是默认的持久化机制。RDB会将数据保存在dump.rdb这个二进制文件中。

　　RDB有2种触发策略：**手动触发、自动触发**。

　　1、**手动触发策略**

　　可以通过**SAVE**命令手动触发RDB持久化：

```shell
redis> SET name tom
redis> SAVE
```

　　假如持久化时间很长，SAVE命令会阻塞当前客户端，导致无法执行其它操作。更好的方法是执行**BGSAVE**命令，在后台执行持久化：

```shell
redis> SET name tom
redis> BGSAVE
```

　　2、**自动触发策略**

　　自动触发策略指的是在指定时间内、数据被修改了指定次数，就会触发RDB持久化，可以在`redis.conf`中进行配置，多个策略只能有一个生效：

```conf
save 60 1 #60秒内只要有1次修改，就会触发RDB持久化
```

* ### AOF

　　AOF(Append Only File)，即追加模式，服务器执行修改命令之前，如果命令有效，就会将命令写入`appendonly.aof`文件，然后再执行命令，当恢复数据时，只需要把文件中的所有命令重新执行一遍。AOF默认关闭，需要在`redis.conf`中开启：

```conf
appendonly yes
```

　　

　　**AOF重写**

　　当`appendonly.aof`越来越大时，需要对它进行”瘦身“，这个过程叫做AOF重写。如果需要手动重写，执行下面的命令即可：

```shell
redis> BGREWRITEAOF
```

　　也可以在`redis.conf`中配置自动重写策略：

```conf
auto-aof-rewrite-percentage 100 #当aof文件增量大于100%时触发重写
auto-aof-rewrite-min-size 64mb #当aof文件增量大于64MB时触发重写
```



　　**AOF触发策略**

　　服务器宕机时，丢失命令的数量取决于命令被写入aof文件的时间，越早把数据写入文件，丢失的数据就越少。Redis为AOF提供了3种触发策略：

　　1、**always**：每执行一次命令，就把命令写入aof文件。优点是不会丢失任何数据，缺点是执行速度太慢。

　　2、**everysec**：默认策略，每秒向aof文件中写入一次命令。最多会丢失一秒内的数据。

　　3、**no**：由操作系统决定何时向aof文件写入命令。这种策略不安全。

　　可以在`redis.conf`文件中配置AOF触发策略：

```conf
appendfsync always
appendfsync everysec
appendfsync no
```

* ### RDB和AOF的对比

|                |                             RDB                              |                             AOF                              |
| :------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|  **备份速度**  |  RDB是全量备份，每次备份整个数据库，因此**备份速度比较慢**   |  AOF是增量备份，每次只备份新的命令，因此**备份速度比较快**   |
|  **恢复速度**  |            RDB将数据保存为二进制，**恢复速度快**             |           AOF使用文本格式还原数据，**恢复速度慢**            |
| **数据安全性** | RDB的备份速度慢，宕机前最后一次备份过程中可能会丢失较多数据，**安全性低** | AOF的备份速度快，使用everysec策略可以保证最多丢失一秒的数据，**安全性高** |

　　当数据量比较大、对数据完整性要求不高时，推荐使用RDB，否则推荐使用AOF。

## 九、主从模式和哨兵模式

* ### 主从模式

　　**主从模式(Master-Slave)**是一种常见的软件架构，主节点和从节点部署在不同的服务器上，当主节点写入数据时，同时也会将数据同步到从节点。通常主节点负责写入数据，从节点负责读取数据。

　　Redis的主从模式架构图如下：

![Redis主从模式](/assets/img/java/Redis的主从模式.png)

　　主从模式的缺点是，当主节点发生故障，需要手动将一个从节点切换为主节点，切换的过程中服务不可用。Redis对此的解决方案是使用哨兵模式。

* ### 哨兵模式

　　哨兵模式是对主从模式的一种改进，它通过sentinel(哨兵)集群对Redis集群中的主节点和从节点进行监控，一旦发现主节点不可用，就会自动选举出一个从节点作为主节点。因此**哨兵模式可以自动切换主从节点**。

　　哨兵模式的结构图如下：

![Redis哨兵模式](/assets/img/java/哨兵模式.png)

* ### Docker配置主从模式和哨兵模式

　　<font color='red'>待补充。</font>

## 十、Redis分布式锁

　　Java锁(如synchronized)只能对单体应用生效，因为Java锁本质上是一个共享实例，它不能跨应用共享，因此如果要在集群环境下实现线程同步，就要求我们提供一个可以跨应用的锁，Redis分布式锁就是其中一种。

　　获取、释放Redis分布式锁的命令如下：

```shell
redis> SET lock 1 EX 60 NX #只有当lock键不存在时才能执行该命令，成功则返回1，代表成功获取到lock锁，锁过期时间是60s
redis> DEL lock #删除lock键，代表释放lock锁
```

　　<font color='red'>分布式锁远不止于此，待补充。</font>

## 十一、Redis缓存问题

　　Redis一般用作缓存和其它数据库搭配使用，把热点数据缓存起来，用户查询数据时优先访问Redis，以减轻后端数据库的压力。

　　请求缓存的过程如下：

![请求Redis缓存的过程](/assets/img/java/请求Redis缓存的过程.png){:height="70%" width="70%"}

　　请求缓存时，可能会出现下面几个问题。

* ### 缓存穿透

　　缓存穿透指的是用户请求的数据在缓存中和数据库中都不存在，导致频繁地绕过缓存访问数据库，增大了数据库压力。

　　解决办法：

　　1、对于数据库中不存在的数据，在缓存中将它的值设为null；

　　2、使用布隆过滤器。用户查询数据之前会先查询布隆过滤器，如果过滤器中不存在该数据，会直接拒绝请求；

　　3、接口增加校验。

* ### 缓存击穿

　　缓存击穿指的是用户请求的某条数据在缓存中不存在，但是在数据库中存在。出现这种情况的原因一般是key的缓存时间到期，大量的并发请求进入后端数据库，会导致数据库压力过大。

　　解决办法：

　　1、设置热点数据永不过期；

　　2、使用分布式锁。当用户查询数据时，首先去查询缓存，如果缓存中没有，就通过分布式锁进行加锁，各进程依次去查询后端数据库；

　　3、设置接口熔断、降级。

* ### 缓存雪崩

　　缓存雪崩指的是缓存中大量key同时过期，而查询量太大，导致数据库压力过大。

　　解决办法：

　　1、设置热点数据永不过期；

　　2、为缓存的key设置随机过期时间。
