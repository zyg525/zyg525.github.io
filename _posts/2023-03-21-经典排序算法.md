---
title: 经典排序算法
tags: 数据结构
---

## 排序算法

* ### 选择排序

　　在每轮循环中，选出最小的元素，放到第i个位置上。

```java
//选择排序
static int[] selectionSort(int[] arr) {
    int len = arr.length;
    for (int i=0;i<len;i++) {
        int minIndex = i;
        for (int j=i;j<len;j++) {
            if(arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        swap(arr,i,minIndex);
    }
    return arr;
}
```

* ### 冒泡排序

　　通过交换相邻元素，在每轮循环中，将最大的元素放到数组末尾。

```java
//冒泡排序
static int[] bubbleSort(int[] arr) {
    int len = arr.length;
    for(int i=0;i<len;i++) {
        for(int j=0;j<len-1;j++) {
            if(arr[j] > arr[j+1]) {
                swap(arr,j,j+1);
            }
        }
    }
    return arr;
}
```

* ### 插入排序

　　将第i个元素插入到0到i-1的有序队列中，保证新的队列有序。

```java
//插入排序
static int[] insertionSort(int[] arr) {
    int len = arr.length;
    for(int i=1;i<len;i++) {
        for(int j=i;j>0;j--) {
            if(arr[j] < arr[j-1]) {
                swap(arr,j,j-1);
            }else {
                break;
            }
        }
    }
    return arr;
}
```

* ### 希尔排序

　　在插入排序的基础上，引入步长h，h一般取len/2或len/3。

```java
//希尔排序
static int[] shellSort(int[] arr) {
    int len = arr.length;
    int h = len/2;
    while (h>0) {
        for (int i=h;i<len;i+=h) {
            for(int j=i;j>=h;j-=h) {
                if(arr[j] < arr[j-h]) {
                    swap(arr,j,j-h);
                }else {
                    break;
                }
            }
        }
        h = h/2;
    }
    return arr;
}
```

* ### 归并排序

　　递归+合并。递归算法将数组切分为多个子队列，合并算法将两个有序队列合并为一个有序队列。

```java
//归并排序
static int[] mergeSort(int[] arr,int left,int right) {
    if(left >= right) return null;
    int mid = (left+right)/2;

    mergeSort(arr,left,mid);
    mergeSort(arr,mid+1,right);

    merge(arr, left, mid, right);
    return arr;
}

//合并算法
static void merge(int[] arr,int left,int mid,int right) {
    int[] tmp = Arrays.copyOf(arr,arr.length);
    int i=left,j=mid+1;
    for(int k=left;k<=right;k++){
        if(i>mid){
            arr[k] = tmp[j++];
        }else if(j>right){
            arr[k] = tmp[i++];
        }else if(tmp[i] < tmp[j]){
            arr[k] = tmp[i++];
        }else{
            arr[k] = tmp[j++];
        }
    }
}
```

* ### 快速排序

　　递归+切分。切分算法的作用是找到一个切分元素，该元素大于它左边的所有元素、小于它右边的所有元素，递归算法的作用是对所有元素进行切分。

```java
//快速排序
static int[] fastSort(int[] arr,int left,int right) {
    if(left>=right) return null;
    int partition = partition(arr, left, right);
    fastSort(arr,left,partition-1);
    fastSort(arr,partition+1,right);
    return arr;
}

//切分算法
static int partition(int[] arr,int left,int right) {
    int p = arr[left];
    int i = left, j = right+1;
    while (true) {
        while (p > arr[++i]){
            if(i==right) break;
        }
        while (p < arr[--j]){
            if(j==left) break;
        }
        if(i>=j) break;
        swap(arr,i,j);
    }
    swap(arr,left,j);
    return j;
}
```

## 查找算法

* ### 二分法查找

　　前提条件是数组有序。

```java
//二分法查找
static int binarySearch(int[] arr,int target) {
    int len = arr.length;
    int i=0,j=len-1;
    while (i<=j) {
        int mid = (i+j)/2;
        if(target<arr[mid]) {
            j = mid-1;
        }else if(target>arr[mid]) {
            i = mid+1;
        }else{
            return mid;
        }
    }
    return -1;
}
```

* ### 插值查找

　　在二分法查找的基础上，将mid改为`mid=i+(j-i)*(target-arr[i])/(arr[j]-arr[i])`。

```java
//二分法查找
static int binarySearch(int[] arr,int target) {
    int len = arr.length;
    int i=0,j=len-1;
    while (i<=j) {
        int mid = i+(j-i)*(target-arr[i])/(arr[j]-arr[i]);
        if(target<arr[mid]) {
            j = mid-1;
        }else if(target>arr[mid]) {
            i = mid+1;
        }else{
            return mid;
        }
    }
    return -1;
}
```

