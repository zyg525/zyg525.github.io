---
title: Redis-Java最佳实践
tags: Redis
---

## 一、Redis客户端

　　1、**Jedis**：以Redis命令作为方法名称，学习成本低。缺点是线程不安全，多线程环境下需要使用连接池。

　　2、**Lettuce**：基于Netty实现，支持同步、异步、响应式编程，线程安全。支持Redis集群、哨兵、管道模式。

　　3、**Redission**：基于Redis实现的分布式Java数据结构集合，包括Map、Queue、Lock等强大功能。

## 二、SpringDataRedis

* ### 简介

　　Spring中对Redis的集成模块，包括对Redis客户端的集成。它的特点是：

　　1、提供了RedisTemplate统一API来操作Redis；

　　2、支持基于JDK、JSON、字符串、Spring对象的序列化与反序列化。

　　3、......

* ### 使用

　　1、SpringDataRedis的起步依赖是：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

　　它默认集成了Lettuce。

　　此外，还需要连接池依赖：

```xml
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-pool2</artifactId>
</dependency>
```

　　2、配置文件

```yml
spring:
  redis:
    host: 192.168.154.130
    port: 6379
    password:
    lettuce:
      pool:
        max-active: 10
        max-idle: 10
        min-idle: 1
        time-between-eviction-runs: 10s
```

　　3、自定义配置类

```java
@Configuration
public class RedisConfig {
    @Bean
    RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory) {
        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>();
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        return redisTemplate;
    }
}
```

* ### 序列化与反序列化

　　SpringDataRedis默认使用JDK的序列化器，它的缺点是可读性差、占用空间大。更好的方式是用字符串进行存储，为此提供了两种序列化器StringRedisSerializer和GenericJackson2JsonRedisSerializer。

　　StringRedisSerializer实现序列化的方式比较简单，就是按照一定的编码格式，将字符串对象转换为字节流，它只能序列化String对象。GenericJackson2JsonRedisSerializer可以序列化其它Java对象，它会将对象先自动转换为JSON格式的字符串，然后再转换为字节流，它的缺点是转换后的JSON字符串会携带对象类型信息，需要额外的存储开销。

　　因此**对于String对象的序列化可以通过StringRedisSerializer实现**，**对于一般对象的序列化**，可以通过GenericJackson2JsonRedisSerializer实现，**也可以先手动将对象转换为JSON字符串，然后通过StringRedisSerializer将JSON字符串转换为字节流**，手动转换的优点是可以省略对象类型信息，节省存储空间，缺点是增加了代码成本，比如反序列化时需要手动将JSON转换为对应类型。

　　因此，SpringDataRedis序列化的最佳方法是：

```java
@SpringBootTest
class RedisTest {

    //1、使用StringRedisTemplate，它的序列化器都是StringRedisSerializer
    @Autowired
    StringRedisTemplate stringRedisTemplate;

    @Test
    public void test1() {
        Student student = new Student(1, "张三", 18);
        //2、手动将对象转换为JSON字符串
        String jsonStr = JSON.toJSONString(student);
        //3、将JSON字符串转换为字节流写入Redis
        stringRedisTemplate.opsForValue().set("student",jsonStr);

        //4、从Redis中读取字节流并解码为字符串
        String studentStr = stringRedisTemplate.opsForValue().get("student");
        //5、手动将JSON字符串转换为对象
        Student stu = JSON.parseObject(studentStr, Student.class);
        System.out.println(stu);
    }
}
```

## 三、Redis数据类型

　　Redis中key是string类型，value可以是string、list、hash、set、zet等类型。

* ### string

　　string类型非常简单，它的使用方法是：

```java
ValueOperations<String, String> vo = stringRedisTemplate.opsForValue();
vo.set("name", "张三");
String name = vo.get("name");
```

* ### list

　　list相当于双端队列，它的使用方法是：

```java
ListOperations<String, String> lo = stringRedisTemplate.opsForList();
String key = "names";
//从队列左边添加元素
lo.leftPush(key,"张三");
lo.leftPush(key,"李四");
lo.leftPush(key,"王五");
//获取第一个元素
String name1 = lo.index(key, 0);
//获取所有元素
List<String> list = lo.range(key, 0, -1);
//从队列右边弹出元素
String name2 = lo.rightPop(key);
```

* ### hash

　　hash相当于Java中的map，它适用于存储对象属性，使用方法是：

```java
HashOperations<String, String, Object> ho = stringRedisTemplate.opsForHash();
String key = "student1";
Student student1 = new Student(1, "张三", 18);
//将对象属性转换为string类型的键值对，存入Map
Map<String, Object> map = BeanUtil.beanToMap(student1,new HashMap<>(),
        CopyOptions.create()
                .setIgnoreNullValue(true)
                .setFieldValueEditor((fieldName,fieldValue)->fieldValue.toString()));
//将Map中的属性存入hash
ho.putAll(key,map);

//从hash中读取属性
Map<String, Object> objectMap = ho.entries(key);
//将属性转换为对象
Student student = BeanUtil.mapToBean(objectMap, Student.class, true, new CopyOptions());
```

* ### set

　　set相当于Java中的set，它可以对元素进行去重，使用方法是：

```java
SetOperations<String, String> so = stringRedisTemplate.opsForSet();
String key = "names";
String[] names = {"张三","李四","王五","张三"};
//向set中添加元素
so.add(key, names);

//获取set中的元素
Set<String> names2 = so.members(key);
```

* ### zset

　　zset相当于有序的set，每个元素都携带一个score，根据score从小到大进行排序，zset的使用方法是：

```java
ZSetOperations<String, String> zso = stringRedisTemplate.opsForZSet();
String key = "names";
//向zset中添加元素，并指定每个元素的score
zso.add(key,"张三",0.1);
zso.add(key,"李四",0.3);
zso.add(key,"王五",0.2);

//获取zset中所有元素
Set<String> names = zso.range(key, 0, -1);
```

* ### HyperLoglog

　　HyperLoglog用于统计不重复元素的个数(有误差)，使用方法是：

```java
HyperLogLogOperations<String, String> hlo = stringRedisTemplate.opsForHyperLogLog();
String key1 = "names1";
String key2 = "names2";
String[] names1 = {"张三","李四","王五","张三"};
String[] names2 = {"赵六","jack","王五","张三"};
hlo.add(key1,names1);
hlo.add(key2,names2);

//统计key1、key2中不重复元素的个数
Long size = hlo.size(key1,key2);
```

## 四、基于Redis实现短信验证登录

　　业务流程如下图所示：

![基于Redis实现短信验证登录](/assets/img/java/基于Redis实现短信验证登录.png)

　　业务流程主要包括三部分：

　　1、发送验证码；

　　2、使用验证码登录或注册；

　　3、使用Token实现免登录。

* ### 发送验证码

　　业务流程是：

　　1、用户输入手机号，点击发送验证码；

　　2、后端验证手机号格式，然后生成验证码，并将手机号作为key、验证码作为value保存到Redis中，同时设置验证码有效期；

　　3、后端调用第三方短信接口，将验证码发送给用户。

* ### 使用验证码登录或注册

　　业务流程是：

　　1、用户输入手机号和验证码，点击登录/注册；

　　2、后端验证手机号格式，然后从Redis中查询手机号对应的验证码，如果Redis中不存在验证码，或者Redis中的验证码与用户输入的验证码不匹配，说明验证码错误，拒绝请求；

　　3、验证码如果正确，就通过手机号去后端数据库查询用户信息，如果用户存在，则生成随机token字符串，然后将token字符串作为key、用户信息作为value保存到Redis中，同时设置token有效期，如果用户不存在，则创建新用户并添加到后端数据库，然后进行同样的操作；

　　4、返回token给前端，前端负责将token保存到浏览器缓存中。

* ### 使用Token实现免登录

　　1、定义两个拦截器，拦截器1会拦截所有路径，拦截器2只拦截需要用户登录的路径；

　　2、用户向后端发送请求，同时携带`Authorization`请求头，它的值是Token；

　　3、请求到达拦截器1后，首先获取到Token，然后从Redis中查询Token对应的用户信息，不管Token或者用户信息是否存在，都会去刷新Token的有效期，然后将用户信息存入ThreadLocal，最后放行；

　　4、如果用户想访问的路径不需要登录，则不会被进入拦截器2，如果需要登录，则会进入拦截器2；

　　5、请求到达拦截器2后，会从ThreadLocal中获取到用户信息，如果用户信息为空，说明Token失效，请求，如果用户信息不为空，说明Token有效，放行。

　

　　代码地址：<https://github.com/zyg525/learn-redis/tree/master/auth-code>
