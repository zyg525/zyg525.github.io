---
title: Redis-Java最佳实践
tags: Redis
layout: post
---

## 一、Redis客户端

　　1、**Jedis**：以Redis命令作为方法名称，学习成本低。缺点是线程不安全，多线程环境下需要使用连接池。

　　2、**Lettuce**：基于Netty实现，支持同步、异步、响应式编程，线程安全。支持Redis集群、哨兵、管道模式。

　　3、**Redission**：基于Redis实现的分布式Java数据结构集合，包括Map、Queue、Lock等强大功能。

## 二、SpringDataRedis

* ### 简介

　　Spring中对Redis的集成模块，包括对Redis客户端的集成。它的特点是：

　　1、提供了RedisTemplate统一API来操作Redis；

　　2、支持基于JDK、JSON、字符串、Spring对象的序列化与反序列化。

　　3、......

* ### 使用

　　1、SpringDataRedis的起步依赖是：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

　　它默认集成了Lettuce。

　　此外，还需要连接池依赖：

```xml
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-pool2</artifactId>
</dependency>
```

　　2、配置文件

```yml
spring:
  redis:
    host: 192.168.154.130
    port: 6379
    password:
    lettuce:
      pool:
        max-active: 10
        max-idle: 10
        min-idle: 1
        time-between-eviction-runs: 10s
```

　　3、自定义配置类

```java
@Configuration
public class RedisConfig {
    @Bean
    RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory) {
        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>();
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        return redisTemplate;
    }
}
```

* ### 序列化与反序列化

　　SpringDataRedis默认使用JDK的序列化器，它的缺点是可读性差、占用空间大。更好的方式是用字符串进行存储，为此提供了两种序列化器StringRedisSerializer和GenericJackson2JsonRedisSerializer。

　　StringRedisSerializer实现序列化的方式比较简单，就是按照一定的编码格式，将字符串对象转换为字节流，它只能序列化String对象。GenericJackson2JsonRedisSerializer可以序列化其它Java对象，它会将对象先自动转换为JSON格式的字符串，然后再转换为字节流，它的缺点是转换后的JSON字符串会携带对象类型信息，需要额外的存储开销。

　　因此**对于String对象的序列化可以通过StringRedisSerializer实现**，**对于一般对象的序列化**，可以通过GenericJackson2JsonRedisSerializer实现，**也可以先手动将对象转换为JSON字符串，然后通过StringRedisSerializer将JSON字符串转换为字节流**，手动转换的优点是可以省略对象类型信息，节省存储空间，缺点是增加了代码成本，比如反序列化时需要手动将JSON转换为对应类型。

　　因此，SpringDataRedis序列化的最佳方法是：

```java
@SpringBootTest
class RedisTest {

    //1、使用StringRedisTemplate，它的序列化器都是StringRedisSerializer
    @Autowired
    StringRedisTemplate stringRedisTemplate;

    @Test
    public void test1() {
        Student student = new Student(1, "张三", 18);
        //2、手动将对象转换为JSON字符串
        String jsonStr = JSON.toJSONString(student);
        //3、将JSON字符串转换为字节流写入Redis
        stringRedisTemplate.opsForValue().set("student",jsonStr);

        //4、从Redis中读取字节流并解码为字符串
        String studentStr = stringRedisTemplate.opsForValue().get("student");
        //5、手动将JSON字符串转换为对象
        Student stu = JSON.parseObject(studentStr, Student.class);
        System.out.println(stu);
    }
}
```

## 三、Redis数据类型

　　Redis中key是string类型，value可以是string、list、hash、set、zet等类型。

* ### string

　　string类型非常简单，它的使用方法是：

```java
ValueOperations<String, String> vo = stringRedisTemplate.opsForValue();
vo.set("name", "张三");
String name = vo.get("name");
```

* ### list

　　list相当于双端队列，它的使用方法是：

```java
ListOperations<String, String> lo = stringRedisTemplate.opsForList();
String key = "names";
//从队列左边添加元素
lo.leftPush(key,"张三");
lo.leftPush(key,"李四");
lo.leftPush(key,"王五");
//获取第一个元素
String name1 = lo.index(key, 0);
//获取所有元素
List<String> list = lo.range(key, 0, -1);
//从队列右边弹出元素
String name2 = lo.rightPop(key);
```

* ### hash

　　hash相当于Java中的map，它适用于存储对象属性，使用方法是：

```java
HashOperations<String, String, Object> ho = stringRedisTemplate.opsForHash();
String key = "student1";
Student student1 = new Student(1, "张三", 18);
//将对象属性转换为string类型的键值对，存入Map
Map<String, Object> map = BeanUtil.beanToMap(student1,new HashMap<>(),
        CopyOptions.create()
                .setIgnoreNullValue(true)
                .setFieldValueEditor((fieldName,fieldValue)->fieldValue.toString()));
//将Map中的属性存入hash
ho.putAll(key,map);

//从hash中读取属性
Map<String, Object> objectMap = ho.entries(key);
//将属性转换为对象
Student student = BeanUtil.mapToBean(objectMap, Student.class, true, new CopyOptions());
```

* ### set

　　set相当于Java中的set，它可以对元素进行去重，使用方法是：

```java
SetOperations<String, String> so = stringRedisTemplate.opsForSet();
String key = "names";
String[] names = {"张三","李四","王五","张三"};
//向set中添加元素
so.add(key, names);

//获取set中的元素
Set<String> names2 = so.members(key);
```

* ### zset

　　zset相当于有序的set，每个元素都携带一个score，根据score从小到大进行排序，zset的使用方法是：

```java
ZSetOperations<String, String> zso = stringRedisTemplate.opsForZSet();
String key = "names";
//向zset中添加元素，并指定每个元素的score
zso.add(key,"张三",0.1);
zso.add(key,"李四",0.3);
zso.add(key,"王五",0.2);

//获取zset中所有元素
Set<String> names = zso.range(key, 0, -1);
```

* ### HyperLoglog

　　HyperLoglog用于统计不重复元素的个数(有误差)，使用方法是：

```java
HyperLogLogOperations<String, String> hlo = stringRedisTemplate.opsForHyperLogLog();
String key1 = "names1";
String key2 = "names2";
String[] names1 = {"张三","李四","王五","张三"};
String[] names2 = {"赵六","jack","王五","张三"};
hlo.add(key1,names1);
hlo.add(key2,names2);

//统计key1、key2中不重复元素的个数
Long size = hlo.size(key1,key2);
```

## 四、基于Redis实现短信验证登录

　　业务流程如下图所示：

![基于Redis实现短信验证登录](/assets/img/java/基于Redis实现短信验证登录.png)

　　业务流程主要包括三部分：

　　1、发送验证码；

　　2、使用验证码登录或注册；

　　3、使用Token实现免登录。

* ### 发送验证码

　　业务流程是：

　　1、用户输入手机号，点击发送验证码；

　　2、后端验证手机号格式，然后生成验证码，并将手机号作为key、验证码作为value保存到Redis中，同时设置验证码有效期；

　　3、后端调用第三方短信接口，将验证码发送给用户。

* ### 使用验证码登录或注册

　　业务流程是：

　　1、用户输入手机号和验证码，点击登录/注册；

　　2、后端验证手机号格式，然后从Redis中查询手机号对应的验证码，如果Redis中不存在验证码，或者Redis中的验证码与用户输入的验证码不匹配，说明验证码错误，拒绝请求；

　　3、验证码如果正确，就通过手机号去后端数据库查询用户信息，如果用户存在，则生成随机token字符串，然后将token字符串作为key、用户信息作为value保存到Redis中，同时设置token有效期，如果用户不存在，则创建新用户并添加到后端数据库，然后进行同样的操作；

　　4、返回token给前端，前端负责将token保存到浏览器缓存中。

* ### 使用Token实现免登录

　　1、定义两个拦截器，拦截器1会拦截所有路径，拦截器2只拦截需要用户登录的路径；拦截器1的作用是刷新token的有效期，拦截器2的作用是拦截token过期的请求，放行token未过期的请求；

　　2、用户向后端发送请求，同时携带`Authorization`请求头，它的值是Token；

　　3、请求到达拦截器1后，首先获取到Token，然后从Redis中查询Token对应的用户信息，不管Token或者用户信息是否存在，都会去刷新Token的有效期，然后将用户信息存入ThreadLocal，最后放行；

　　4、如果用户想访问的路径不需要登录，则不会被进入拦截器2，如果需要登录，则会进入拦截器2；

　　5、请求到达拦截器2后，会从ThreadLocal中获取到用户信息，如果用户信息为空，说明Token失效，请求，如果用户信息不为空，说明Token有效，放行。

　

　　代码地址：<https://github.com/zyg525/learn-redis>

## 五、基于Redis实现商户缓存

* ### 缓存更新策略

　　Redis的缓存更新策略有三种：

　　1、**内存淘汰**：Redis内存不足时自动淘汰部分数据，下次查询时更新缓存；

　　2、**超时剔除**：给缓存数据添加超时时间，到期后自动删除缓存，下次查询时更新缓存；

　　3、**主动更新**：编写业务逻辑，在更新数据库的同时更新缓存。

　　对于低一致性需求，比如缓存数据变化的概率很小时，可以使用内存淘汰策略；**对于高一致性需求，应采取主动更新策略，并以超时剔除为兜底方案**。

　

　　主动更新策略的三个问题：

　　**1、更新数据库时更新缓存还是删除缓存？**

　　答：更新数据库时应删除缓存，等到下一次查询时再重建缓存，这样可以避免很多无效的重建操作。

　　**2、如何保证数据库操作和缓存操作同时成功或失败？**

　　答：对于单体系统，可以将两个操作放在一个事务中；对于分布式系统，需要使用TCC等分布式事务方案。

　　**3、应该先更新数据库还是先删除缓存？**

　　答：应该先更新数据库。因为更新数据库的操作更加耗时，如果先删除缓存，会导致数据库与缓存不一致的概率大大增加。

* ### 缓存穿透的解决办法

　　缓存穿透指的是用户请求的数据在缓存中和数据库中都不存在，导致频繁地绕过缓存访问数据库，增大了数据库压力。

　　常见解决办法有：

　　1、对于数据库中不存在的数据，**在Redis中缓存NULL值**。优点是实现简单，缺点是占用额外内存，并且可能造成数据库与缓存短期不一致(可以通过减少key的过期时间进行改善)。

　　2、在用户与缓存之间添加**布隆过滤器**。优点是内存占用少，缺点是实现复杂、存在误判可能。

　

　　通过缓存NULL值解决缓存穿透的流程如下图所示：

![缓存穿透解决流程](/assets/img/java/缓存穿透解决流程.png)

　　更新时：

　　1、先更新后端数据库，再删除缓存。

　　查询时：

　　1、先查询缓存，如果缓存中存在，或者查询到空字符串，则直接返回，不再查询后端数据库；

　　2、如果缓存中不存在，则查询后端数据库；

　　3、如果后端数据库中不存在，则将空字符串写入Redis缓存，并返回信息；

　　4、如果后端数据库中存在，则将数据写入Redis缓存，并返回信息。

* ### 缓存击穿的解决办法

　　缓存击穿指的是用户请求的某条数据在缓存中不存在，但是在数据库中存在。出现这种情况的原因一般是key的缓存时间到期，大量的并发请求进入后端数据库，会导致数据库压力过大。

　　常见解决办法有：

　　1、设置热点数据永不过期；

　　2、**互斥锁**。查询缓存未命中后，使用互斥锁保证只有一个线程可以访问后端数据库、重建缓存，其它线程等待锁释放后才能进行查询。它的优点是数据库和缓存的一致性较高，缺点是并发性能太低，可能会出现死锁。

　　3、**逻辑过期**。缓存数据不设置TTL，而是新增一个`expire`属性，将过期时间写入这个字段。这样一方面可以保证缓存数据永不物理过期，另一方面可以实现缓存自动更新的功能。具体实现方法是，当第一个线程查询缓存发现缓存已经过期时，在它的内部新开一个独立线程异步去访问后端数据库、更新缓存，同时使用互斥锁保证只有这一个线程可以访问数据库，第一个线程以及其它后续线程都还是返回过期的的缓存数据。它的优点是并发性能较高，缺点是数据库和缓存的一致性较低，容易读取到过期数据。

* #### 1、互斥锁

　　使用互斥锁解决缓存击穿的流程如下图所示：

![基于互斥锁解决缓存击穿](/assets/img/java/基于互斥锁解决缓存击穿.png)

　　1、查询缓存，如果命中了或得到空字符串，返回；

　　2、如果没有命中缓存，则尝试获取互斥锁，互斥锁通过Redis实现；

　　3、如果没有获取到锁，则当前线程进入休眠，休眠结束后递归执行当前方法进行重新查询；

　　4、如果获取到锁，则当前线程开始查询后端数据库，并重建缓存，最后释放锁，并返回结果。

* #### 2、逻辑过期

　　使用逻辑过期解决缓存击穿的流程如下图所示：

![基于逻辑过期解决缓存击穿](/assets/img/java/基于逻辑过期解决缓存击穿.png)

　　1、查询缓存，如果没有命中，返回；

　　2、如果命中了，就判断逻辑过期时间是否过期；

　　3、如果逻辑过期时间没有过期，就返回数据；

　　4、如果逻辑过期时间过期了，就需要更新缓存。具体做法是先尝试获取互斥锁，如果获取到了互斥锁，就新开一个独立线程，在线程中查询后端数据库、更新缓存，最后释放锁。独立线程以外的其它线程不需要等待独立线程结束，直接返回过期数据。

　

　　代码地址：<https://github.com/zyg525/learn-redis> 

## 六、基于Redis生成唯一ID

　　Redis唯一ID的结构如下图所示：

![Redis唯一ID的结构](/assets/img/java/Redis唯一ID的结构.png)

　　**时间戳**：时间戳部分的生成方式是，指定一个时刻，然后用当前时间减去该时刻，保证时间戳部分是自增的。

　　**序列号**：序列号部分的生成方式是，通过Redis的`INCR`命令对一个key所对应的value进行自增。一个key最多可以生成2^32个序列号，如果达到上限，由于时间戳部分一直在变化，可以在每天(或每月)创建新的key，对序列号部分进行重置。

　　时间戳和序列号生成好之后，需要进行合并，方法是时间戳左移32位，然后对序列号进行逻辑与(`|`)运算。合并后的数字就是唯一ID。

　

　　代码地址：<https://github.com/zyg525/learn-redis> 
