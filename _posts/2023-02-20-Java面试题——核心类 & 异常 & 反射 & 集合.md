---
title: Java面试题——核心类 & 异常 & 反射 & 集合
tags: Java面试题
---



## 一、核心类

* ### 介绍一下String类型的不可变性

　　String是一个特殊的引用类型，它被设计为不可变的。String类用char[]数组存放字符串（新版JDK使用byte[]数组），String类的不可变性是由两个方法实现的：

　　1、用private final修饰char[]数组，保证数组引用不会指向其它对象；

　　2、String类中不定义任何修改char[]数组的方法，保证数组中的元素不被修改。当要修改字符串时，比如拼接或截取时，操作的是原字符串的拷贝，而非原字符串。

* ### ==和equals()的区别是什么？

　　**==**：如果变量是基本数据类型，==比较的是变量的值是否相等；如果变量是引用类型，==比较的是变量所指向的地址是否相同。

　　**equals()**：equals()是Object类中定义的方法，该方法内部使用了==，比较的是变量指向的地址，但是通过重写的方式可以让它比较变量的内容，比如String类就重写了equals()方法，比较的是两个字符串的值是否相等。

* ### StringBuffer和StringBuilder的异同？

　　**<font color='red'>相同点</font>**：都可以提高拼接字符串的效率。使用`+`拼接字符串时，每次都要创建新的char[]数组和String对象，浪费内存，影响GC效率。而StringBuffer和StringBuilder是一个可变对象，可以预分配缓冲区(默认16)，这样就避免了频繁地创建临时对象，提高了效率。

　　**不同点**：StringBuffer是线程安全的，StringBuilder是线程不安全的。因为StringBuffer的所有操作字符串的方法都加了synchronized关键字。

* ### 介绍一下自动装箱、自动拆箱、缓存优化

　　Java为每一种基本数据类型都提供了对应的包装类，Java编译器可以帮我们在基本类型和包装类型之间自动转型。比如将基本类型int赋值给包装类型Integer引用时，会自动调用`Integer.valueOf()`方法，返回包装类型，这叫做**自动装箱**，将包装类型Integer赋值给基本类型int引用时，会自动调用`Integer.intValue()`方法，返回基本类型，这叫做**自动拆箱**。

　　自动装箱时，整数包装类会对`[-128,127]`之间的数返回同一个包装类实例，这就是包装类的**缓存优化**。

## 二、异常

* ### 简述异常的分类

　　Java异常包括**Error**和**Exception**，Error指的是程序无法处理的异常，比如`堆、栈溢出`，而Exception指的是程序可以处理的异常。这两种异常都继承自**Throwable**。

　　Exception又分为**检查异常**(Checked)和**不受检查异常**(No-Checked，也叫运行时异常RuntimeException)，检查异常指的是必须手动捕获或抛出的异常，否则就会编译报错，比如`IOException`、`SQLException`、`FileNotFoundException`等，不受检查异常可以不进行处理，比如`NullPointerException`、`ClassCastException`、`IllegalArgumentException`、`IndexOutOfBoundsException`等。

* ### throw和throws的区别是什么？

　　throw用于方法体内部，用来主动抛出一个异常对象；throws用于方法声明上，代表该方法可能会抛出的异常列表。

* ### final、finally、finalize的区别是什么？

　　final用于声明类、方法、变量，分别表示类不能被继承、方法不能被重写、变量不能被修改。

　　finally是异常处理的一部分，在try/catch语句中，finally语句块最终一定会被执行。

　　<font color='red'>finalize是Object类的一个方法，当垃圾回收器准备回收对象占用空间时，会首先调用finalize方法，并在下一次垃圾回收动作发生时真正回收对象占用的内存。</font>

## 三、反射

* ### 简述Java的Class对象和反射机制

　　`JVM`每加载一个class，就会为其创建一个Class类型的实例，并关联起来。这个Class类型指的是一个名为Class的class。因此，每个Class实例都指向了一个数据类型，它包含了该类型的所有完整信息。

　　Java的反射机制指的是在运行期可以获取到一个类的成员变量、成员方法、构造方法，还可以构造出该类的实例、调用该实例的属性和方法。可以通过以下类调用反射API：Class、Field、Method、Construct。

## 四、集合

* ### 简述List

　　List(接口)**和数组的行为几乎完全相同**，有索引，可以存放重复元素。List有两种实现方式：`ArrayList`和`LinkedList`。`ArrayList`的底层由数组实现，因此查询、修改比较快，增删比较慢，`LinkedList`的底层由链表实现，因此查询、修改比较慢，增删比较快。

* ### 简述Map

　　Map(接口)用来存放**键值对**，其中键是不能重复的，它的实现方式有：`HashMap、TreeMap、HashTable`等。

　　`HashMap`使用哈希表存放键值对，键值对的存放地址是不可预测的，因此存放顺序和遍历顺序不一定是一致的。`HashMap`要求key的数据类型正确实现`equlas()`方法和`hashcode()`方法，原因是正确的`equals()`方法可以保证key不重复，正确的`hashcode()`方法可以尽量避免哈希冲突。

　　`TreeMap`使用树形结构(红黑树)存放键值对，所以它不需要key的数据类型正确实现`hashcode()`方法。`TreeMap`可以对key进行排序，要求key的数据类型必须实现Comparable接口，并正确重写`compareTo`方法。因为底层数据结构的差异，导致`TreeMap`的查询、修改、增删效率都不如`HashMap`。

　　`HashTable`是`HashMap`的重量级实现，它不允许key为null，但`HashMap`允许最多一个key为null。`HashTable`是线程安全的(通过synchronized实现)。

* ### 简述Set

　　Set(接口)用来存储**不重复的元素集合**，相当于Map中的key，它的实现方式有：`HashSet、TreeSet`。`HashSet`是对`HashMap`的简单封装，`TreeSet`是对`TreeMap`的简单封装，`TreeSet`中的元素都是排好序的。

* ### 简述Queue

　　Queue(接口)是一个实现了先进先出的有序表。它的实现方式有：`LinkedList、PriorityQueue、Deque`(接口)。

　　`LinkedList`不但实现了List接口，还实现了Queue接口，当它作为Queue接口的实现类时，它就是一个实现了**先进先出**的队列，只能在队首添加元素，在队尾获取元素。

　　`PriorityQueue`实现了**优先队列**，它的队尾元素一定是优先级最高的，优先级通过元素所属类型的`compareTo`方法决定，因此要求该元素所属类型正确实现Comparable类。

　　`Deque`(接口)继承了Queue接口，它实现了**双端队列**，双端队列允许两头都进、两头都出。`Deque`的实现方式主要有：`ArrayDeque`和`LinkedList`。

* ### 线程安全的集合类有哪些？

　　1、**Vector**：线程安全版`ArrayList`，通过synchronized实现。

　　2、**HashTable**：线程安全版`HashMap`，通过synchronized实现。

　　3、**Stack**：线程安全版栈，通过synchronized实现。

　　4、**JUC**包(`java/util/concurrent`)中的线程安全集合类。