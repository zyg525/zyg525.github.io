---
title: Java面试题——MySQL
tags: Java面试题
---

## 基础

* ### 1、char和varchar都表示字符串，它们的区别是什么？

　　1、char长度固定，varchar长度不固定；

　　2、char因为长度固定，所以存取快，但是需要更多存储空间。同理，varchar存取慢，但是可以节省存储空间；

　　3、char最多可以存放约`2^8`个字符，varchar最多可以存放约`2^16`个字符。

　　综上，当字符串长度固定时，建议使用char，否则使用varchar。

* ### 2、TIMESTAMP和DATETIME都表示时间，它们的区别是什么？

　　1、DATETIME的日期范围更大。DATETIME的范围是`1000-01-01 00:00:00.000000` 到 `9999-12-31 23:59:59.999999`，而TIMESTAMP的范围是`1970-01-01 00:00:01.000000 UTC `到 `2038-01-09 03:14:07.999999 UTC`；

　　2、DATETIME占用8字节，TIMESTAMP占用4字节；

　　3、DATETIME只支持存储时使用的时区，一旦数据存储进去，查询时其表现形式不再改变，而TIMESTAMP支持多个时区，查询时数据的表现形式会随着系统时区的变化而变化；

　　4、DATETIME默认为空，TIMESTAMP默认为当前时间。

* ### 3、应该用什么类型存储货币？

　　应该用decimal类型存储货币，而非double或float，因为double和float是用二进制存储的，不能准确地存储一个数值。

* ### 4、delete、truncate、drop的区别是什么？

|              | delete   | truncate | drop             |
| ------------ | -------- | -------- | ---------------- |
| **命令分类** | DML      | DDL      | DDL              |
| **删除对象** | 部分数据 | 所有数据 | 所有数据、表结构 |
| **能否回滚** | 可以     | 不可以   | 不可以           |

* ### 5、where、group by、order by的顺序是什么？

　　顺序是：**先where(分组前过滤)，再group by(分组)，然后having(分组后过滤)，最后order(排序)**。

```sql
SELECT grade,AVG(score) FROM t_student
WHERE id>0
GROUP BY grade
HAVING AVG(score)>90
ORDER BY grade;
```

## 索引

* ### 1、MySQL中有几种索引？

　　MySQL中有四种索引，分别是：**主键索引、唯一索引、普通索引、联合索引**。

* ### 2、为什么使用索引可以提高查询效率？

　　如果不使用索引，查询时会进行全表扫描，会把表中数据从头到尾遍历一遍。使用了索引之后，会用一种特殊的数据结构重新组织要查询的字段，通过这个新的组织结构就可以提高查询效率，相当于给一本书加上了目录。

* ### 3、介绍一下MySQL索引的数据结构

　　MySQL的默认存储引擎是InnoDB，它使用B+树结构的索引。在InnoDB中B+树一般为1-3层，可以满足千万级的数据存储。

* ### 4、B+树相比于其它数据结构的优点是什么？

　　**普通二叉树**：极端情况下，普通二叉树会退化为链表，相当于全表扫描。

　　**红黑树**：红黑树是一种自平衡的二叉树，它的缺点是每个结点最多有2个子结点，当数据量很大时，树的高度会变高，这意味着对磁盘进行IO操作的次数会变多，自然会降低性能。

　　**B树**：B树不但是平衡的，而且一个结点可以有多个子结点，这样就降低了树的高度。但是B树中的每个结点不但保存着关键字，还保存着关键字对应的行数据，而每个结点的容量是有上限的，这就导致结点中存储的关键字的数量其实并不多，树的高度还是不低，磁盘IO的频率还是不低。

　　**B+树**：B+树是对B树的改进，它的非叶子结点只存放关键字，不存放行数据，只有叶子结点上存放了所有的关键字和行数据，这就保证了每个非叶子结点可以存放更多的关键字，树的高度大大降低了，IO次数也大大减少了。并且B+树的叶子结点构成了有序的双向链表，可以直接通过遍历叶子结点来对关键字进行排序。

* ### 5、聚集索引和非聚集索引的区别是什么？

　　1、聚集索引的叶子结点存放的是关键字和对应的行数据，而非聚集索引的叶子结点存放的是关键字和对应的主键，要获得完整的行数据，需要去主键索引(聚集索引)中去查询，这个过程叫做回表。

　　2、一个表中只能有一个聚集索引，但可以有多个非聚集索引。

* ### 6、什么是回表和覆盖索引？

　　回表指的是先去非聚集索引中查询出关键字对应的主键，然后去聚集索引中查询出主键对应的行数据。

　　覆盖索引主要应用于联合索引，即要查询的数据已经包含在非聚集索引的叶子结点上了，不需要再去查询聚集索引。

* ### 7、什么是最左前缀匹配规则？

　　对于联合索引，查询的时候只有先匹配了索引定义中左边的字段，才能匹配其右边的字段。如果在查询条件中绕过了其中的某个字段，那么右边的所有字段都不会走索引。

## SQL优化

* ### 1、SQL优化的方式有哪些？

　　可以从这几个方面优化SQL：**索引优化、JOIN优化、分页优化**。

* ### 2、索引优化包括哪些？

　　**主键优化**

　　1、**主键长度应尽量小**。原因是辅助索引中的叶子结点存放了主键，如果辅助索引很多，那么主键将占用大量空间。

　　2、插入数据时，应该**按照主键顺序插入**。原因是主索引树叶子结点上的主键是顺序排列的，如果乱序插入，为了保证有序性，会导致页分裂，降低性能。

　　3、在业务操作时，尽量**避免对主键的修改**。

　　**排序优化**

　　1、尽量**根据排序字段建立索引**。原因是索引树叶子结点本身就是有序的。

　　2、对于多个字段排序，建立联合索引时要保证各个字段的排序方式和`order by`中的**排序方式一致**。

　　3、对于多个字段排序，**要使用覆盖索引**。如果发生回表查询，则索引排序失效。

　　**分组优化**

　　1、尽量**根据分组字段建立索引**。

　　2、多个分组字段要满足最左前缀匹配规则。

　　**update优化**

　　尽量**为更新条件中的字段建立索引**。因为InnoDB的行锁针对的是索引，如果更新条件中的字段没有索引、或者索引失效，那么行锁会升级为表锁，使并发性能降低。

　　**使用覆盖索引**

　　尽量使用覆盖索引。因为这样可以避免回表查询。

* ### 3、JOIN优化包括哪些？

　　**JOIN代替子查询**

　　尽量用JOIN代替子查询，因为子查询是嵌套查询，会创建临时表，占用资源。

　　**小表驱动大表**

　　尽量用小表去驱动大表，比如`left join`查询时，就是用左边的表去驱动右边的表。关联的时候，会先遍历驱动表，然后再去连接被驱动表。

* ### 4、怎样进行分页优化？

　　通过**覆盖索引+子查询**的方式进行分页优化。具体做法是，先在子查询中查出分页范围内的覆盖索引，然后用覆盖索引的值去查询行数据。原因是如果分页查询时没有使用覆盖索引，会先查询出所有行数据，然后再从这些数据里获取分页范围内的数据，如果使用了覆盖索引，则会先获取分页范围内的覆盖索引，然后用覆盖索引获取行数据。

```sql
SELECT a.* FROM t_user a, (SELECT name FROM t_user ORDER BY name LIMIT 100000,10) b WHERE a.name = b.name;
```

* ### 5、索引失效的场景有哪些？

　　**违反了最左前缀匹配规则**

　　对于联合索引，当索引最左边的字段在查询条件中不存在时，索引失效；当索引中间的某个字段在查询条件中不存在时，该字段右边的索引失效。

　　**在索引列上进行了函数运算**

　　如果在索引列上进行了函数运算，索引会失效。

　　**模糊前缀匹配**

　　在进行模糊匹配时，如果使用了模糊前缀匹配(`'%xxx'`)，那么索引会失效。

　　**or失效**

　　查询条件中，or左右两边的字段只要有一个没有索引，那么两边的索引都会失效。

　　**数据分布影响**

　　如果MySQL评估走全表扫描比走索引还快，那么索引失效。

* ### 6、索引的设计原则有哪些？

　　1、针对数据量大、查询频率高的表建立索引；

　　2、针对`WHERE、ORDER BY 、GROUP BY`后面的字段建立索引；

　　3、优先建立唯一索引、联合索引、前缀索引。

* ### 7、怎么看执行计划？

　　执行计划中有几个比较重要的字段：

　　1、**type**：表示访问类型。性能从从优到差分别为`system > const > ref > index_merge > range> index > ALL`。分别代表`查询系统表 > 查询主键或唯一索引 > 查询一个普通索引 > 查询多个普通索引 > 范围查询索引 > 遍历索引树进行全部读取 > 全表扫描`。

　　2、**possible_keys**：表示可能用到的索引列；

　　3、**key**：表示实际用到的索引列；

　　4、**key_len**：表示实际用到的索引列的长度；

　　5、**rows**：表示查询时扫描的行数，行数越少，性能越高。

## 事务

* ### 1、MySQL事务的四大特性(ACID)是什么？

　　1、**原子性（Atomicity）**：事务作为整体被执行，事务中的操作要么全部成功，要么全部失败。

　　2、**一致性（Consistency）**：事务开始前和事务完成后，数据是一致的。

　　3、**隔离性（Isolation）**：事务并发执行时，之间是互不干扰的。

　　4、**持久性（Durability）**：事务完成后，对数据库的更改，会持久地保存在数据库中。

* ### 2、事务的隔离级别有哪些？

　　1、**Read Uncommitted（读未提交）**：可能会出现**脏读**，即一个事务可能会读取到另一个事务没有提交的数据。

　　2、**Read Committed（读已提交）**：是**Oracle默认的隔离级别**。可能会出现**不可重复读**，即一个事务中两次读取数据，在这之间有另一个事务修改了数据，两次读取的数据将不一致。

　　3、**Repeatable Read（可重复读）**：是**MySQL默认的隔离级别**。可能会出现**幻读**，即一个事务中两次读取数据，在这之间有另一个事务修改了数据，两次读取到的都将是旧数据。

　　4、**Serializable（串行化）**：所有事物串行执行，不会出现脏读、不可重复读、幻读的现象，但是并发性能低。
