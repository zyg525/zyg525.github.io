---
title: Java语言基础之多线程
categories: Java语言基础
tags: Java语言基础
layout: post
---





## 一、多线程基础

### 进程与线程

　　我们把操作系统中的任务叫做进程，把每个进程内部的子任务叫做线程。进程是操作系统分配资源的基本单位，而线程是CPU分配时间片的基本单位。每个进程所拥有的内存空间是独立的，而一个进程内的每个线程既拥有独立的内存空间，比如栈内存，也共享内存空间，比如堆内存和方法区。

### 创建新线程

　　Java中创建新线程的方法包括继承`Thread`类和实现`Runnable`接口两种方式。实际上这两种方式只是在代码层面不同，底层都是通过JVM调用本地方法，然后再调用重写的`run()`方法实现的。

```java
// 继承Thread类并重写run()方法
Thread t1 = new Thread(){
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName());
    }
};
// 启动线程
t1.start();

// 实现Runnable接口并重写run()方法
Thread t2 = new Thread(()->{
    System.out.println(Thread.currentThread().getName());
});
// 启动线程
t2.start();
```

### 线程的六种状态

　　Java线程有六种状态，可以看到在`Thread`类中有一个内部枚举类`State`，里面就包含了这六种状态：

```java
public enum State {
    NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED;
}
```

　　这六种状态之间的转换关系如下图所示：

<img src="../assets/img/java/线程的6种状态.png" alt="线程的6种状态" style="zoom:80%;" />

　　线程的六种状态之间的转换过程是：

　　1、新创建的线程处于**`NEW`**状态；

　　2、线程对象执行了`start()`方法后处于`Ready`状态，如果线程获取到了CPU时间分片，那么就会进入`Running`状态，`Ready`和`Running`统称为**`RUNNABLE`**状态；

　　3、`Running`状态的线程如果获取不到锁，就会进入**`BLOCKED`**状态；如果`BLOCKED`状态下的线程获取到了锁，就会恢复到`Ready`状态；

　　4、`Running`状态的线程如果调用了`join()`、`wait()`方法，就会进入**`WAITING`**状态；如果`WAITING`状态下的线程被`notify()`、`notifyAll()`唤醒，就会恢复到`Ready`状态；

　　5、`Running`状态的线程如果调用了`sleep(long time)`、`join(long time)`、`wait(long time)`方法，就会进入**`TIMED_WAITING`**状态；如果`TIMED_WAITING`状态下的线程被`notify()`、`notifyAll()`唤醒，或者超时，就会恢复到`Ready`状态；

　　6、线程执行结束后会进入**`TERMIATED`**状态。

### 守护线程

　　守护线程是指为其他线程服务的线程。在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。

　　将一个线程标记为守护线程的方法是：

```java
Thread t1 = new Thread(()->{
    try {
        Thread.sleep(100000l);
    } catch (InterruptedException e) {
        throw new RuntimeException(e);
    }
});

// 将线程标记为守护线程，如果没有这一句，JVM需要很久才能结束运行
t1.setDaemon(true);
t1.start();
```

## 二、synchronized

### 基本使用

　　Java中可以使用`synchronized`关键字将一个对象变成锁，加锁的代码块只能同时被一个线程执行。

　　`synchronized`可以用来修饰代码块，此时需要显式指定一个共享对象作为锁：

```java
Object lock = new Object();
synchronized(lock) {
    // 同步代码块
}
```

　　也可以用`synchronized`修饰实例方法，此时锁对象实际上是`this`：

```java
public synchronized void add(int n) {
    count += n;
}
```

　　还可以用`synchronized`修饰静态方法，此时锁对象实际上是类的`Class`实例：

```java
public static synchronized void add(int n) {
    count += n;
}
```

### wait()和notify()

* #### 作用

　　`wait()`和`notify()`的底层是本地方法。

　　在一个`Running`状态的线程中，如果对`synchronized`锁对象调用了`wait()`方法，会释放锁，让当前线程变成`WAITING`状态。

　　在一个`Running`状态的线程中，如果对`synchronized`锁对象调用了`notify()`方法，会让等待该锁的随机一个线程变成`Ready`状态；如果调用的是`notifyAll()`方法，会让等待该锁的所有线程变成`Ready`状态。

> info "注意！"
>
> `wait()`和`notify()`的使用范围是`sunchronized`语句块内，调用者是`synchronized`锁对象。

* #### 实现阻塞队列

　　**阻塞队列的特点是，当队列为空时，获取队列元素的线程会进入WAITING状态，当队列不为空时会恢复运行；当队列已满时，添加队列元素的线程会进入WAITING状态，当队列未满时会恢复运行。**阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。

　　使用`wait()`和`notifyAll()`可以实现一个简单的阻塞队列：

```java
public class Test {
    static Queue<String> taskQueue = new LinkedList<>();
    
    // 生产者
    static synchronized void provide(String task) throws Exception {
        // 当队列已满时，生产线程进入WAITING状态，同时唤醒消费线程
        while (taskQueue.size() >= 5) {
            Test.class.notifyAll();
            Test.class.wait();
        }
        taskQueue.add(task);
        System.out.println("provide-"+task);
        Test.class.notifyAll();
    }

    // 消费者
    static synchronized String consume() throws Exception {
        // 当队列为空时，消费线程进行WAITING状态，同时唤醒生产线程
        while (taskQueue.isEmpty()) {
            Test.class.wait();
        }
        String task = taskQueue.poll();
        System.out.println("consume"+task);
        Test.class.notifyAll();
        return task;
    }
}
```

* #### wait(long timeout)

　　`wait()`的作用是让当前线程无限期等待，直到被唤醒。而`wait(long timeout)`的作用是让当前线程等待一段时间，如果超过时间还没有被唤醒，就自动恢复运行。

### sleep(long timeout)

　　`sleep(long timeout)`方法是`Thread`类中的静态方法，它是一个本地方法，作用是让当前线程暂停执行一段时间，和`wait()`方法不同的是，`sleep(long timeout)`不会让当前线程释放锁。

### join()

* #### 作用

　　`join()`方法可以让线程B等待线程A执行结束后再执行，具体用法如下：

```java
Thread tA = new Thread(()->{
    System.out.println("tA");
    try {
        Thread.sleep(2000);
    } catch (InterruptedException e) {
        throw new RuntimeException(e);
    }
});

Thread tB = new Thread(()->{
    try {
        tA.join();
        System.out.println("tB");
    } catch (InterruptedException e) {
        throw new RuntimeException(e);
    }
});

t1.start();
t2.start();
```

* #### 原理

　　`join()`方法的原理是，在线程B的内部增加了一个`synchronized`代码块，锁对象是线程A的对象，当线程B运行到`synchronized`块中时，会不断检测线程A是否已经死亡，如果还没有死亡，就会调用锁对象的`wait()`方法，从而使线程B进入WAITING状态。如果线程A结束运行，JVM会自动调用线程A对象的`notifyAll()`方法，唤醒正在等待的线程B，使线程B恢复运行。

　　`join()`方法实际上相当于：

```java
synchronized(tA) {
    while(tA.isAlive()) {
        tA.wait();
    }
}
```

* #### join(long timeout)

　　`join(long timeout)`的作用是让线程A等待线程B一段时间，如果超过时间后线程B还没有结束，那么线程A会停止等待，恢复执行。

### interrupt()

　　使用`interrupt()`方法可以打断一个线程，下面分析一下打断不同状态下的线程，会造成什么影响。对线程对象调用`isInterrupted()`方法会返回一个布尔值，用于判断打断状态，初始值是false，即未打断。

　　1、打断运行状态的线程，`isInterrupted()`方法会返回true，即已打断。

　　2、打断等待状态的线程(即调用了`sleep()、wait()、join()`方法的线程)，`isInterrupted()`方法会返回false，即未打断，并且会抛出`InterruptedException`。

　　**由此可知，在运行状态的线程中，我们需要通过`isInterrupted()`方法来判断线程是否被打断，而在等待状态的线程中，我们需要通过是否抛出了`InterruptedException`来判断线程是否被打断。**

### synchronized锁升级过程

　　`synchronized`锁升级的过程如下图所示：

<img src="../assets/img/java/锁升级过程.png" style="zoom:80%;" />

　　1、锁对象的初始状态是偏向锁；

　　2、当出现多个线程使用同一个锁对象，但是没有发生竞争时，偏向锁升级为轻量级锁；

　　3、当出现锁竞争时，轻量级锁升级为重量级锁。

### 自旋锁

　　在多核CPU的场景下，为了避免出现频繁的线程上下文切换，竞争锁失败的线程不会直接进入阻塞状态，而是会先进入空循环，也叫做自旋。当循环超过一定次数时，才会进入阻塞状态。

　　在JDK6之后引入了**自适应自旋锁**，如果在上一次自旋中成功获取到了锁，那么JVM会认为当前自旋中也很有可能获取到锁，于是就会增加自旋次数，反之会减少次数。

　　在JDK7之后不能控制是否开启自旋功能。

## 三、虚拟机级别的其它同步方式

### volatile

* #### Java内存模型

　　线程之间共享主内存，每个线程也有自己的工作内存，线程访问共享变量时，实际上访问的是变量在工作内存中的副本，当副本变量被修改后，会更新回主内存，但更新的时间是不确定的。

* #### 可见性

　　可见性指的是，一个线程修改了共享变量的值，其它线程会立刻得到最新的值。由于Java内存模型的原因，普通的共享变量不具有可见性，**而被`volatile`修饰的共享变量具有可见性，共享变量被修改后会立刻更新到主内存，访问共享变量时会去主内存中获取最新值。**

　　在下面的代码中，`flag`是一个普通的共享变量，t2线程修改了它的值，t1线程有可能获取不到修改后的新值，导致一直循环下去：

```java
static class VolatileTest {
    boolean flag = false;

    Thread t1 = new Thread(()->{
        while (!flag) {}
    });

    Thread t2 = new Thread(()->{
        flag = true;
    });

    void startTest() {
        t1.start();
        t2.start();
    }
}

public static void main(String[] args) throws Exception {
    // 测试50次，提高出现死循环的概率
    for(int i=0;i<50;i++) {
        VolatileTest volatileTest = new VolatileTest();
        volatileTest.startTest();
    }
}


```

　　如果给`flag`加上`volatile`关键字，t1线程会始终得到共享变量的最新值，不会再出现死循环。

* #### 有序性

　　指令重排指的是，CPU为了提高效率，有可能会打乱指令的顺序，只要保证最终的结果不变，这种做法在单线程下是安全的，但是在多线程下是不安全的。**`volatile`关键字可以禁止指令重排，保证了共享变量的有序性。**

　　`volatile`保证共享变量有序性的一个典型例子是单例模式的双重检验锁(DCL)写法：

```java
class Singleton {
    private static volatile Singleton singleton = null;

    private Singleton() {}

    public static Singleton getSingleton() {
        // 位置一
        if(singleton == null) {
            synchronized (Singleton.class) {
                if(singleton == null) {
                    // 位置二
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}
```

　　对于`Singleton singleton = new Singleton()`这句代码来说，它的字节码指令大概分为三步：

　　1、给对象分配内存空间；

　　2、执行构造方法进行初始化；

　　3、把对象赋值给singleton变量。

　　第2、3步可能会发生指令重排，即singleton变量可能会指向一个没有初始化的对象。当线程A执行到代码中的位置二时，发生了指令重排，并且还没来得及执行第3步的初始化指令，此时线程B执行到了代码中的位置一，发现singleton不等于null，最终返回一个没有被初始化的对象。

> info "注意"
>
> `volatile`是通过读写屏障来实现共享变量的可见性和有序性的。

### CAS

* #### 原理

　　CAS是一种使用无锁方式保证共享变量的线程安全的方法。

　　CAS的伪代码如下所示：

```java
// 共享变量
volatile Num num = new Num(0);

// 自增1
public final int incrementAndGet(Num num) {
    int result = 0;
    do {
        int n = num.getNum();
        result = n + 1;
    } while(!compareAndSet(num, n, result));

    return result;
}
```

　　CAS的核心逻辑是：**通过`compareAndSet()`方法保证在计算的过程中，共享变量的值没有被其它线程所修改，`compareAndSet()`方法是一个原子操作**。由于CAS操作要求获取共享变量的最新值，因此必须用`volatile`修饰。

　　CAS会使线程不断重试，避免了频繁的线程上下文切换，适用于多核CPU、线程数量较少的情况。

* #### <font color='red'>应用(验证使用)</font>

　　在Java中，CAS被封装在`sun.misc.Unsafe`类中，这个类对象只能通过反射得到，里面定义了很多native类型的CAS方法。`AtomicInteger、AtomicLong、AtomicBoolean、AtomicReference`等类都使用了CAS操作来保证线程安全。此外，`AtomicStampedReference、AtomicMarkableReference`可以解决ABA问题，原子数组可以保证数组内元素的线程安全，原子更新器可以保证对象中某个属性的线程安全，原子累加器可以保证数值计算的线程安全，它比`AtomicInteger`等原子类效率更高。以上这些类都是通过CAS来实现线程安全的。
