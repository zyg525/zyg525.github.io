---
title: Java语言基础之反射
categories: Java语言基础
tags: Java语言基础
layout: post
---



## 概述

### 反射的定义

　　反射是指计算机程序在运行时可以访问、检测、修改它本身状态或行为的一种能力。

　　正常情况下，在Java中，如果要访问一个对象(或类)的字段或调用它的方法，那么这个类在编译期就必须存在，比如：

```java
import org.example.Person;

public class Main {
    Person p = new Person();
}
```

　　如果去掉`import org.example.Person `，编译会报错。但是反射没有这个要求，即使这个类在编译期不存在，程序在运行期间仍可以通过反射来访问这个类的属性，比如：

```java
public class Main {
    // 如果org.example.Person存在，那么这个字段的实际类型就是Person
    Object p = Class.forName("org.example.Person");
}
```

### 反射的优缺点

　　优点：增加了程序的灵活性。

　　缺点：

　　　　1、性能比较低，因为虚拟机无法对动态代码进行优化；

　　　　2、可以绕过一些限制来访问属性，降低了程序安全性，比如可以访问`private`属性。

## Class类型

### 定义

　　虚拟机每加载一种class，就会为该class创建一个`Class`类型的实例，并关联起来，这个`Class`类型的实例包含了该class的所有信息。

### 获取Class实例的方法

　　方法1：通过目标class的静态变量`class`获得：

```java
Class cls = String.class;
```

　　方法2：通过实例方法`getClass()`获得：

```java
Class cls = new String().getClass();
```

　　方法3：通过`Class`类中的`forName()`静态方法获得：

```java
Class cls = Class.forName("java.lang.String");
```

　　每个class的`Class`实例在虚拟机中都是唯一的，因此上面三种方法获得的实例是同一个。

## 使用反射调用构造方法

### 调用public无参构造方法

　　可以使用`Class`实例中的`newInstance()`方法来调用class中`public`类型的无参构造方法：

```java
class Person {
    public Person() {...}
}

public static void main(String[] args) throws Exception {
    Class cls = Class.forName("org.example.Person");
    // 调用无参构造方法
    Person p = (Person) cls.newInstance();
}
```

### 调用其它构造方法

　　如果构造方法不是`public`类型，或者构造方法有参数，就需要先获取`Constructor`实例，然后通过这个实例调用构造方法：

```java
class Person {
    private Person(String name, int age) {...}
}

public static void main(String[] args) throws Exception {
    Class cls = Class.forName("org.example.Person");
    // 获取Constructor实例
    Constructor con = cls.getDeclaredConstructor(String.class, int.class);
    // 允许访问私有属性
    con.setAccessible(true);
    // 调用有参构造方法
    Person p = (Person) con.newInstance("张三", 18);
}
```

> info "注"
>
> 如果想要访问被禁止访问的属性，需要调用`setAccessible(true)`方法。

## 使用反射访问字段

### 访问字段描述信息

　　`Field`实例中包含了一个字段的描述信息：

```java
class Person {
    public String name = "张三";
}

public static void main(String[] args) throws Exception {
    Class cls = Class.forName("org.example.Person");
    // 获取Field实例
    Field name = cls.getDeclaredField("name");
    // 获取字段类型
    Class type = name.getType();
    // 获取字段其它描述信息
    int modifiers = name.getModifiers();
}
```

### 获取实例中字段的值

　　通过`Field`中的`get()`方法，可以获取实例中字段的值：

```java
class Person {
    public String name = "张三";
}

public static void main(String[] args) throws Exception {
    Class cls = Class.forName("org.example.Person");
    Field name = cls.getDeclaredField("name");
    // 获取实例中字段的值
    String value = (String) name.get(new Person());
}
```

### 为实例中的字段赋值

　　通过`Filed`中的`set()`方法，可以为实例中的字段赋值：

```java
class Person {
    public String name = "张三";
}

public static void main(String[] args) throws Exception {
    Class cls = Class.forName("org.example.Person");
    Field name = cls.getDeclaredField("name");
    // 为实例中的字段赋值
    Person p = new Person();
    name.set(p, "李四");
}
```

## 使用反射访问方法

### 访问方法描述信息

　　`Method`实例中包含了一个方法的描述信息：

```java
class Person {
    public void m1(String name, int age) {...}
}

public static void main(String[] args) throws Exception {
    Class cls = Class.forName("org.example.Person");
    // 获取Method实例
    Method m1 = cls.getDeclaredMethod("m1", String.class, int.class);
    // 获取方法返回值类型
    Class type = m1.getReturnType();
    // 获取方法其它描述信息
    int modifiers = m1.getModifiers();
}
```

### 调用方法

　　可以通过`Method`中的`invoke()`方法来调用方法：

```java
class Person {
    public void m1(String name, int age) {...}
}

public static void main(String[] args) throws Exception {
    Class cls = Class.forName("org.example.Person");
    Method m1 = cls.getDeclaredMethod("m1", String.class, int.class);
    // 调用Person实例的m1()方法
    m1.invoke(new Person(), "李四", 20);
}
```

　　当调用静态方法时，可以把`invoke()`方法参数中的实例换成null。

### 支持动态分派

　　使用反射调用对象的实例方法时，以对象的实际类型为准：

```java
class Person {
    public void m1(String name, int age) {...}
}

class Student extends Person {
    @Override
    public void m1(String name, int age) {...}
}

public static void main(String[] args) throws Exception {
    Class cls = Class.forName("org.example.Person");
    Method m1 = cls.getDeclaredMethod("m1", String.class, int.class);
    // 调用的是实际类型Student中的方法，符合动态分派
    Person p = new Student();
    m1.invoke(p, "李四", 20);
}
```

## 获取继承关系

### 获取父类、接口

　　使用反射获取一个类的父类、接口：

```java
public static void main(String[] args) throws Exception {
    Class cls = Class.forName("org.example.Person");
    // 获取直接父类
    Class superClass = cls.getSuperclass();
    // 获取所有实现的接口
    Class[] interfaces = cls.getInterfaces();
}
```

### 判断继承关系

　　可以使用`instanceof`关键字判断一个实例是否属于某一类型或它的子类：

```java
System.out.println(new String() instanceof Object); // true
```

　　也可以使用`Class`实例中的`isAssignableFrom()`方法来判断：

```java
System.out.println(Object.class.isAssignableFrom(String.class)); // true，注意Class实例顺序不同
```

### 动态代理

　　正常情况下，要实例化一个接口，都要先编写接口的实现类，然后再实例化这个实现类。但通过反射我们可以在运行期间动态地生成接口的实例，而不需要手动编写实现类，这就是JDK的动态代理。

　　实现动态代理有三个步骤：1、定义重写方法；2、创建接口实例；3、调用实例方法。

```java
interface Person {
    String getNameAndAge(String name, int age);
    void printNameAndAge(String name, int age);
}

public static void main(String[] args) throws Exception {
    
    // 1、handler中定义了重写方法
    InvocationHandler handler = new InvocationHandler() {
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            String methodName = method.getName();
            if(methodName.equals("getNameAndAge")) {
                return ""+ args[0] + args[1];
            } else if (methodName.equals("printNameAndAge")) {
                System.out.println("姓名："+args[0]+" 年龄："+args[1]);
            }

            return null;
        };
    };

    // 2、创建接口实例
    Person p = (Person) Proxy.newProxyInstance(
            Person.class.getClassLoader(),
            new Class[]{Person.class},
            handler
    );

    // 3、调用实例方法
    String result = p.getNameAndAge("张三", 18);
    p.printNameAndAge("李四", 19);

}
```

