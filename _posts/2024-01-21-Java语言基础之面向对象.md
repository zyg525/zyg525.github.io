---
title: Java语言基础之面向对象
categories: 三、Java语言基础
tags: Java语言基础
layout: post
---



## 类

### 定义类

　　一个`.java`文件中可以定义多个class，但是有且只能有一个class和文件同名。在编译时，`.java`文件中的每个class都会编译出独立的`.class`文件。

### 访问权限修饰符

　　访问权限修饰符可以用来修饰类、字段、方法，范围从大到小分别是`public、protected、默认、private`。

|           | 概述                       | 修饰类                         | 修饰字段或方法                                               |
| --------- | -------------------------- | ------------------------------ | ------------------------------------------------------------ |
| public    | **包外访问、继承权限**     | 可以被同一项目下的所有类访问到 | 可以被同一项目下的所有类访问到；<br />可以被同一项目下的所有子类继承。 |
| protected | **包内访问、包外继承权限** | 不可以修饰类                   | 可以被同一个包内的所有类访问到；<br />可以被同一项目下的所有子类继承。 |
| 默认      | **包内访问、包内继承权限** | 可以被同一包内的所有类访问到   | 可以被同一个包内的所有类访问到；<br />可以被同一包内的所有子类继承。 |
| private   | **本类访问权限**           | 不可以修饰类                   | 只能在本类中被访问到                                         |

### 内部类

　　如果一个类定义在另一个类的内部，那么这个类就是内部类。内部类分为普通内部类、静态内部类、匿名内部类、局部内部类。

* #### 普通内部类

　　定义：

```java
public class Outer {
    class Inner {}
}
```

　　创建对象：

```java
Inner inner = new Outer().new Inner();
```

* #### 静态内部类

　　定义：

```java
public class Outer {
    static class Inner {}
}
```

　　创建对象：

```java
Inner inner = new Outer.Inner();
```

* #### 匿名内部类

　　匿名内部类通常用于不关心类名、只关心实例的情况，比如下面的代码：

```java
Runnable r = new Runnable() {
    @Override
    public void run() {...}
};
```

　　Runnable是一个接口，我们想创建Runnable类型的一个实例，理论上需要先创建它的实现类，然后通过实现类创建对象，但是为了节省工作量，Java允许我们直接重写接口的方法，得到一个没有名字的内部类，然后实例化它。这就是匿名内部类。

* #### 局部内部类

　　局部内部类是定义在代码块或方法中的类。

## 字段和方法

### 静态字段、实例字段

　　静态字段和类绑定，类的所有实例共享静态字段。静态字段的访问方法是`类名.静态字段名`。

　　实例字段和实例绑定，类的每个实例都有独立的实例字段。实例字段的访问方式是`实例.实例字段名`。

　　由于接口属于类，但不能实例化，所以接口中可以定义静态字段，但不能定义实例字段。

### 静态方法、实例方法

　　静态方法和类绑定，类的所有实例共享静态方法。静态方法的访问方式是`类名.静态方法名`。

　　实例方法和实例绑定，类的每个实例都有独立的实例方法。实例方法的访问方式是`实例.实例方法名`。

　　由于静态方法和类绑定，而非实例，因此静态方法中不能访问实例字段，比如指向当前实例的`this`变量。

### this关键字

　　每个实例中存在一个指向当前实例的`this`变量。`this`的一个作用是，当实例方法中存在一个和实例字段相同的局部字段时，可以用`this`作为区分。

```java
class Person {
    private String name;
    public void setName(String name) {
        this.name = name;
    }
}
```

### 方法参数绑定

　　方法参数包括基本类型参数和引用类型参数，基本类型参数绑定的方式是**值复制**，引用类型参数绑定的方式是**引用复制**。

　　基本类型参数绑定：

```java
static void m1(int a) {
    a++;
}

public static void main(String[] args) {
    int a = 1;
    m1(a);
    System.out.println("a="+a); // a=1，a没有被修改说明是值复制
}
```

　　引用类型参数绑定：

```java
static class Person {
    public int age = 18;
}

static void m2(Person p) {
    p.age = 19;
}

public static void main(String[] args) {
    Person p = new Person();
    m2(p);
    System.out.println("age="+p.age); // age=19，age被修改了说明是引用复制，两个引用指向同一个对象
}
```

### 构造方法

　　构造方法的作用是在虚拟机为实例分配内存并初始化零值后，给实例字段赋值。构造方法没有返回值(也没有void)，调用构造方法的方式是：

```java
Person p = new Person("张三", 18);
```

　　如果类中没有显式定义任何构造方法，编译器会自动生成一个无参构造方法，如果有自定义的构造方法，编译器就不会自动生成无参构造方法，要是想用无参构造方法就需要自己定义。

　　在一个构造方法内部可以通过`this`来调用其它构造方法：

```java
public Person(String name) {
    this(name, 18);
}
```

## 面向对象

### 对象的组成

　　Java是面向对象的语言，它将现实世界映射到了Java对象中。

　　Java语言中定义了各种概念：**类、抽象类、接口、实例、字段、方法、抽象方法**。其中类是对象的模板，实例是具体的对象，字段是类或对象中的属性，方法是类或对象的具体行为，抽象类和接口中的抽象方法则是对象行为的模板。

### 面向对象的三大特征

　　面向对象的三大特征是：**封装、继承、多态**。

　　封装是指将对象的属性私有化，同时提供一些可以访问属性的方法给外界。

　　继承是指在现有类的基础上创建其它类，子类可以继承父类的属性，还可以定义自己的属性，继承实现了代码复用。

　　多态是指在一个变量指向的对象类型在编译期是不确定的，在运行期才能确定。在Java中实现多态的方法有继承父类和实现接口。

### 创建对象的顺序

　　创建对象时，代码的执行顺序是：

　　1、执行父类静态代码块、给父类静态字段赋值(按照声明顺序执行)；

　　2、执行子类静态代码块、给子类静态字段赋值(按照声明顺序执行)；

　　3、执行父类局部代码块、给父类实例字段赋值(按照声明顺序执行)、执行父类构造方法；

　　4、执行子类局部代码块、给子类实例字段赋值(按照声明顺序执行)、执行子类构造方法。

　　其中，静态代码块和静态字段赋值只会在类加载的时候执行一次，而局部代码块、实例字段赋值、构造方法会在每次实例化的时候执行。

### 重载和重写

　　方法重载指的是在一个类里面，多个方法的方法名相同，但参数不同(与返回值无关)。

　　方法重写指的是子类中定义了一个与父类方法的方法名、参数都完全相同的方法，而且子类方法的返回值类型必须等于父类方法的返回值类型或者其子类，子类方法的访问权限必须大于等于父类的访问权限，子类方法抛出的异常范围必须小于等于父类方法抛出的异常。

### 继承

* #### 概述

　　Java使用`extends`关键字来实现继承，子类可以继承父类的非`private`字段和方法。

　　所有类都继承了Object类，Object没有父类。

　　一个子类只能有一个父类，而一个父类可以有多个子类。

* #### super关键字

　　**super指向父类实例。**

　　super关键字用于调用父类构造方法。在所有子类的构造方法中，必须在第一行调用父类构造方法，这也很好理解，有了父类对象才会有子类对象。如果没有显式调用父类构造方法，编译器会自动调用父类的无参构造方法，即在第一行加上一句`super();`，如果父类没有无参构造方法，就必须在第一行显式调用父类的其它构造方法。

```java
class Student extends Person {
    public Student(String name, int age) {
        super(name, age); // 这里调用了Person的构造方法
    }
}
```

　　还可以在子类中用super调用父类的其它方法：

```java
static class Student extends Person {
    public void m1() {
        super.m2(); // 在子类中调用父类的m2()方法
    }
}
```

* #### 向上转型和向下转型

　　向上转型是指父类引用指向子类对象：

```java
Person p = new Student();
```

　　向下转型是指子类引用指向父类对象，需要强制转型，并且可能会转型失败：

```java
Stduent s = (Student)new Person();
```

　　**对于向上转型，在访问重写方法时，依据的是实际类型(子类类型)，在访问字段时，依据的是静态类型(父类类型)。**前者属于动态分派，后者属于静态分派。

```java
static class Person {
    public int age = 18;

    public void m1() {
        System.out.println("Person");
    }
}

static class Student extends Person {
    public int age = 19;

    @Override
    public void m1() {
        System.out.println("Student");
    }
}

public static void main(String[] args) {
    Person p = new Student(); // 父类引用指向子类对象
    p.m1(); // Student，实际调用的是子类的m1()方法
    System.out.println(p.age); // 18，实际访问的是父类的age字段。要尽量避免子类字段和父类字段同名
}
```

* #### final关键字

　　被final修饰的类不能被继承，修饰的方法不能被重写，修饰的变量不能被修改(引用类型变量不能修改其指向)。

* #### instanceof关键字

　　instanceof用于判断实例是否属于某一类型或它的子类型。

### 抽象类和接口

　　抽象类除了可以定义抽象方法外，其它和普通类没有区别。抽象方法不能是`private`类型。

　　接口中可以有字段和非抽象方法，但字段必须是`public final static`类型，非抽象方法必须是`public default`类型，抽象方法必须是`public abstact`类型。除了`default`修饰符，其它都可以省略。

　　抽象类和接口的异同：

| 相同点                                                       | 不同点                                                       |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1、都不能被实例化；<br />2、都可以没有抽象方法；<br />3、抽象类的子类和接口的实现类都必须实现它们的抽象方法。 | **1、抽象类的作用是将行为规范与具体行为分离，但是还保留了一部分具体行为，而接口的作用也是将行为规范与具体行为分离，但是几乎不保留具体行为，因此接口比抽象类更加抽象、纯粹；**<br />2、一个类只可以继承一个抽象类，但是可以实现多个接口。 |

