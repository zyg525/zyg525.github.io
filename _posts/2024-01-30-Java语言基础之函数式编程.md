---
title: Java语言基础之函数式编程
categories: Java语言基础
tags: Java语言基础
layout: post
---



## Lambda表达式

　　Lambda表达式是JDK8的新特性。它允许将方法作为参数，传递给另一个方法。如果想把一个方法变成Lambda表达式，那么这个方法必须和函数式接口中的抽象方法的签名、返回值类型一样，函数式接口指的是只有一个抽象方法的接口。

　　Lambda表达式的写法：

```java
public static void main(String[] args) throws Exception {

    String[] array = new String[]{"a","c","d","z","f"};
    // 传统的匿名内部类写法
    Arrays.sort(array, new Comparator<String>() {
        @Override
        public int compare(String s1, String s2) {
            return s1.compareTo(s2);
        }
    });

    // Lambda表达式写法
    Arrays.sort(array, (s1, s2)->{
        return s1.compareTo(s2);
    });

    // Lambda表达式简化写法
    Arrays.sort(array, (s1, s2)->s1.compareTo(s2));
}
```

　　在上面的代码中，`Arrays.sort()`方法的签名是：

```java
public static <T> void sort(T[] a, Comparator<? super T> c) {...}
```

　　方法中第二个参数的类型是`Comparator`，它是一个函数式接口，它的抽象方法是：

```java
int compare(T o1, T o2);
```

　　该方法的特点是有两个相同类型的参数，返回一个int值，并且`Arrays.sort()`中第一个参数的元素类型是`String`，编译器会根据这些信息推断出Lambda表达式中的参数类型是`String`、返回值类型是`int`，所以在编写代码时可以省略这些信息。

## 方法引用

### 概述

　　Lambda表达式主要用于重写一个函数式接口中的抽象方法，然后将新方法作为参数使用，如果一个方法本来就存在，虽然也可以用Lambda表达式来将其作为参数使用，但还有更简单的写法，这就是方法引用。方法引用，顾名思义，就是一个方法的引用。

　　以上面的代码为例，还有更简单的写法：
```java
Arrays.sort(array, String::compareTo);
```

　　`String::compareTo`就是一个方法引用，它引用了`String`类中的`compareTo()`方法，这个方法的签名是：

```java
public int compareTo(String anotherString) {...}
```

　　该方法实际上有两个参数：`String this`和`String anotherString`，方法返回值是`int`类型，因此符合`Comparator`接口中的抽象方法的签名，所以可以用方法引用代替Lambda表达式。

### 方法引用分类

　　方法引用可以分为：**静态方法引用、普通实例方法引用、特殊实例方法引用、构造方法引用**。

```java
static int m1(String s1, String s2) {
    return s1.compareTo(s2);
}

int m2(String s1, String s2) {
    return s1.compareTo(s2);
}
public static void main(String[] args) throws Exception {

    String[] array = new String[]{"a","c","d","z","f"};
    // 静态方法引用
    Arrays.sort(array, Test::m1);
    // 普通实例方法引用
    Arrays.sort(array, new Test()::m2);

}
```

　　这里的特殊实例方法指的是概述中介绍的那种方法，即需要加上隐含的this参数后方法签名才能一致，这种实例方法的引用方式是`类名::方法名`。除此之外的实例方法都是普通实例方法，它们的引用方式是`实例::方法名`。

　　构造方法的引用方式是`构造方法名::new`，引用构造方法时要求构造方法的参数和返回类型都和函数式接口中的方法一致(构造方法默认返回当前实例`this`)，下面是引用构造方法的例子：

```java
// 函数式接口
interface InterFaceA<T> {
    T create(int a);
}

class Dog{
    private int age;
    // 要引用的构造方法
    public Dog(int age) {
        this.age = age;
    }

    public int getAge() {
        return age;
    }
}

public class Test {
    // 接收构造方法
    static Dog m1(InterFaceA i) {
        return (Dog) i.create(10);
    }

    public static void main(String[] args) throws Exception {
        // 引用构造方法创建对象
        Dog dog = m1(Dog::new);
        System.out.println(dog.getAge());
    }
}
```

## Stream

### 概述

　　`Stream`是JDK8的新特性，它的作用是存放Java对象，类似于`List`。**`Stream`和`List`的区别是，`List`中存放的是真实的对象，而`Stream`中存放的是生成对象的算法，只有在访问对象时才会真正创建对象。**

### 基本用法

* #### 存放有限序列

　　`Stream`也可以像`List`一样，存放真实的对象。比如可以基于数组或`Collection`创建`Stream`：

|                                      | 作用                                                   | 例子                                                         |
| ------------------------------------ | ------------------------------------------------------ | ------------------------------------------------------------ |
| `Stream<T> Stream.of(T... values)`   | 创建一个有限的`Stream`                                 | `Stream<String> stream = Stream.of("a","b","c");`            |
| `Stream<T> Arrays.stream(T[] array)` | 将数组转换为`Stream`                                   | `Stream<String> stream = Arrays.stream(new String[]{"a", "b", "c"});` |
| `Stream<T> List.stream()`            | 将`List`转换为`Stream`。实际上`Set`、`Queue`也可以转换 | `Stream<String> stream = list.stream();`                     |

　　可以使用`forEach()`方法打印`Stream`中的元素。

* #### 存放无限序列

　　`Stream`常用于存放一个无限的对象序列，即存放生成对象的算法，只有当访问对象时才会真正创建对象。`Stream`是基于`Supplier`函数式接口来存放算法的，接口中的抽象方法是`T get()`，没有参数，只有返回值。

　　存放无限序列的一个简单例子：

```java
Stream<Integer> stream = Stream.generate(() -> 1)
                .limit(5);
stream.forEach(System.out::println);
```

　　在这个例子中，首先调用`generate()`方法存放了一个生成对象的简单算法，然后调用`limit()`方法限制了序列中对象的个数，此时`Stream`中还没有创建对象，只有在调用`forEach()`方法访问对象时才会创建。

* #### 基本类型的Stream

　　由于泛型不支持基本数据类型，所以`Stream`中不能直接存放基本类型，只能存放包装类型，但这会导致频繁的装箱拆箱。为了提高效率，`Stream`提供了`IntStream`、`LongStream`和`DoubleStream`这三种使用基本类型的`Stream`，它们的使用方法和范型`Stream`没有大的区别：

```java
IntStream stream = IntStream.generate(() -> 1)
                .limit(5);
stream.forEach(System.out::println);
```

### map()转换

　　`Stream.map()`是`Stream`最常用的一个转换方法，它把一个`Stream`转换为另一个`Stream`，实际上就是通过修改算法来改变`Stream`中存放的元素。`map()`方法的参数是一个函数式接口方法`R apply(T t);`，参数是一种类型，返回值是另一种类型。

　　使用`map()`的一个例子：

```java
Stream<String> stream = Arrays.stream(new String[]{"a", "b", "c"});
       // 先将字符串转换为大写
stream.map(s -> s.toUpperCase())
       // 再将字符串转换为字符
      .map(s -> s.charAt(0))
       // 再将字符转化为ASCII码
      .map(c -> (int)c)
       // 打印结果是65 66 67
      .forEach(System.out::println);
```

### filter()过滤

　　`Stream.filter()`是`Stream`的另一个常用转换方法。所谓`filter()`操作，就是对一个`Stream`的所有元素一一进行测试，不满足条件的就被“滤掉”了，剩下的满足条件的元素就构成了一个新的`Stream`。`filter()`方法的参数是一个函数式接口方法`boolean test(T t);`，它接收一个参数，返回布尔值。

　　使用`filter()`的一个例子：

```java
Stream<Integer> stream = Arrays.stream(new Integer[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10});
        // 先过滤掉偶数 
stream.filter(i -> i%2==1)
        // 再过滤掉大于5的数
       .filter(i -> i<=5)
        // 打印结果是 1 3 5
       .forEach(System.out::println);
```

### reduce()聚合

　　`map()`和`filter()`都是`Stream`的转换方法，而`Stream.reduce()`则是`Stream`的一个聚合方法，它可以把一个`Stream`的所有元素按照聚合函数聚合成一个结果。`reduce()`方法的参数包括一个对象和一个函数式接口方法`R apply(T t, U u);`，这个方法接收两个参数，返回一个对象。`reduce()`方法的实际功能是将它的第一个参数作为初始值，与`Stream`中的第一个元素进行计算，计算的结果又作为第一个参数和后面的元素进行计算，最终计算出一个结果。

　　使用`reduce()`的一个例子：

```java
Stream<Integer> stream = Arrays.stream(new Integer[]{1, 2, 3});
// 求出所有元素的和
Integer res = stream.reduce(0, (acc, n) -> acc + n);
```

### 转换为集合

* #### ArrayList

```java
Stream<String> stream = Stream.of("a", "b", "c");
A<String> list = stream.collect(Collectors.toList());
```

* #### 数组

```java
Stream<String> stream = Stream.of("a", "b", "c");
String[] array = stream.toArray(String[]::new);
```

* #### HashMap

```java
Stream<String> stream = Stream.of("a=A","b=B","c=C");
Map<String, String> map = stream.collect(Collectors.toMap(
        // 这是key
        s -> s.substring(0, s.indexOf('=')),
        // 这是value
        s -> s.substring(s.indexOf('=') + 1)
));
```

* #### 分组转换

```java
Stream<String> stream = Stream.of("abcd","ccdb","dbca","acce","babs","ddls","ccld","asys");
// 将元素按照首字母分组，相同一组的放入同一个List，最后再将各个List放入Map
Map<String, List<String>> map = stream.collect(
        Collectors.groupingBy(s -> s.substring(0, 1), 
        Collectors.toList())
);
map.forEach((k,v)->{
    System.out.println(k+"="+v);
});

打印结果：
a=[abcd, acce, asys]
b=[babs]
c=[ccdb, ccld]
d=[dbca, ddls]
```

### 其它操作

　　我们把`Stream`提供的操作分为两类：转换操作和聚合操作。除了前面介绍的常用操作外，`Stream`还提供了一系列非常有用的方法。

* #### 排序

　　要求`Stream`的每个元素必须实现`Comparable`接口。如果要自定义排序，传入指定的`Comparator`即可。

```java
Stream<String> stream = Stream.of("b","d","c","e","a")
        .sorted();
stream.forEach(System.out::println); // a b c d e
```

* #### 去重

```java
Stream<String> stream = Stream.of("b","d","b","e","d")
        .distinct();
stream.forEach(System.out::println); // b d e
```

* #### 截取

　　`limit()`用于截取当前`Stream`最多前N个元素，`skip()`用于跳过当前`Stream`的前N个元素。

```java
Stream<String> stream = Stream.of("a","b","c","d","e")
        .skip(2)
        .limit(2);
stream.forEach(System.out::println); // c d
```

* #### 合并

```java
Stream<String> stream1 = Stream.of("a","b","c");
Stream<String> stream2 = Stream.of("d", "e");
Stream<String> stream = Stream.concat(stream1, stream2);
stream.forEach(System.out::println); // a b c d e
```

* #### 并行处理

　　通常情况下，对`Stream`的元素进行处理是单线程的，即一个一个元素进行处理。但是很多时候，我们希望可以并行处理`Stream`的元素，因为在元素数量非常大的情况，并行处理可以大大加快处理速度。

```java
Stream<String> stream = Stream.of("a","b","c","d","e","f");
Stream<String> parallel = stream.parallel();
parallel.forEach(System.out::println); // 由于是多线程并发，打印顺序会不固定
```

* #### 其它方法

|                                          | 作用                                                        | 例子                                   |
| ---------------------------------------- | ----------------------------------------------------------- | -------------------------------------- |
| `count()`                                | 获取`Stream`中元素个数                                      | `long count = stream.count();`         |
| `max(Comparator<? super T> cp) `         | 找出`Stream`中最大元素                                      |                                        |
| `min(Comparator<? super T> cp)`          | 找出`Stream`中最小元素                                      |                                        |
| `sum()`                                  | 对`IntStream`、`LongStream`和`DoubleStream`中的元素求和     |                                        |
| `average()`                              | 对`IntStream`、`LongStream`和`DoubleStream`中的元素求平均数 |                                        |
| `boolean allMatch(Predicate<? super T>)` | 测试是否所有元素均满足测试条件                              |                                        |
| `boolean anyMatch(Predicate<? super T>)` | 测试是否至少有一个元素满足测试条件                          |                                        |
| `forEach()`                              | 循环处理`Stream`的每个元素                                  | `stream.forEach(System.out::println);` |

### IllegalStateException

　　对`Stream`的操作分为中间操作和终止操作，终止操作只能执行一次，并且执行后就再也不能执行其它任何操作了，如果执行了就会抛出如下异常：

```java
Exception in thread "main" java.lang.IllegalStateException: stream has already been operated upon or closed
	at java.util.stream.AbstractPipeline.sourceStageSpliterator(AbstractPipeline.java:279)
	at java.util.stream.ReferencePipeline$Head.forEach(ReferencePipeline.java:580)
	at org.example.Test.main(Test.java:33)
```

　　终止操作包括`forEach()`、`count()`、`sum()`等等。