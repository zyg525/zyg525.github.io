---
title: Java面试题——语言基础 & 面向对象
tags: Java面试题
---

## 一、语言基础

* ### 如何理解Java的跨平台特性？

　　Java的一个特点是“一次编写、到处运行”，意思是编译器把Java代码编译成字节码，虚拟机加载运行字节码，字节码是跨平台的，而虚拟机的平台独立的，这样就实现了“一次编写、到处运行”。

* ### JRE和JDK有什么区别？

　　`JRE`指的是Java运行环境，负责运行Java程序，它包括`JVM`和一些标准类库；

　　`JDK`指的是Java开发工具，供开发人员使用，它包括了`JRE`，同时还包括了编译器和调试器。

* ### Java数据类型有哪些？

　　数据类型分为基本数据类型和引用数据类型，基本数据类型有8种：`byte、short、int、long、float、double、char、boolean`，它们分别占`1、2、4、8、4、8、2、不确定`个字节。除了基本数据类型，剩下的类型都是引用数据类型。

* ### Java的内存结构是什么？

![Java的内存结构](/assets/img/java/Java的内存结构.png)

　　1、**虚拟机栈**：线程私有，每调用一次方法就创建为该方法创建一个栈帧，方法结束后释放栈帧。栈帧中存放了局部变量、方法返回地址等信息，**当局部变量是基本类型时，栈帧中存放的是局部变量的引用和值，当局部变量是引用类型时，栈帧中存放的是局部变量的引用，真正的对象存放在堆中**。

　　2、**程序计数器**：线程私有，用于记录该线程执行到了哪一行字节码。

　　3、**本地方法栈**：类似于虚拟机栈，只不过是针对`native`方法的。

　　4、**堆**：线程共享，用于存放对象实例，也是垃圾回收的区域。

　　5、**方法区**：线程共享，**存放了已经被虚拟机加载了的类信息(包括类名、成员变量名、方法名等)、常量、静态变量**。对于基本类型的成员变量、常量、静态变量，它们的引用和值都存放在方法区，对于引用类型的成员变量，它的引用和实际对象都存放在堆中的对象中，对于引用类型的常量和静态变量，它们的引用存放在方法区，实际对象存放在堆中。

　　以上结论不一定对，还需更深入了解。**目前只需要记住，对于基本类型变量，变量引用和值都存放在栈中，对于引用类型变量，引用存放在栈中，实际对象存放在堆中**。<font color='red'>// TODO</font>

* ### 介绍一下字符串常量池的工作原理

　　方法区有一个运行时常量池，里面可以存放字符串常量，并且里面的字符串是不重复的。下面用几个案例来解释一下它的工作原理：

　　**1、案例1**

```java
String s1 = "ab";
String s2 = "a"+"b";
System.out.println(s1 == s2); //true
```

　　原因是在声明s1时，已经将`"ab"`对象存入了字符串常量池，声明s2时，由于是两个确定的字符串进行拼接，jvm会认为最终的结果是确定的，所以会先去字符串常量池中寻找`"ab"`对象是否已经存在，如果存在，就将常量池中的对象赋值给s2。

　　**2、案例2**

```java
String s1 = "a";
String s2 = "b";
String s3 = "ab";
String s4 = s1+s2;
System.out.println(s3 == s4); //false
```

　　原因是在声明s3时，虽然已经将`"ab"`字符串存入了字符串常量池，但是在声明s4时，是由两个变量进行拼接，jvm会认为结果不确定，不会去字符串常量池中寻找对象，而是会通过`StringBuilder`拼接字符串，最后返回新的对象。

* ### Java的参数传递是什么类型？

　　Java的参数传递是**值传递**。值传递中传递的是实际参数的副本，对副本的修改不会影响原来的参数，而引用传递中传递的是实际参数，对参数的修改会影响原来的参数。

　　当参数是基本类型时，会将参数值复制一份传递进去，在方法中对新值的修改不会影响旧值；当参数是引用类型时，会将参数的引用复制一份传递进去，在方法中修改新引用指向的地址，不会影响旧引用的指向，但由于两个引用都指向同一个地址，所以如果在方法中修改新引用指向的对象(新引用指向的地址不变)，那么旧引用指向的对象也会变化。

　　**简言之，对于基本类型的传参，传递的是值的副本，对于引用类型的传参，传递的是引用的副本**。

## 二、面向对象

* ### 说说你对Java面向对象的理解？

　　面向对象的意思是，把现实中的事物映射到Java对象中，Java对象存储了事物的属性和行为，对象之间相互作用、传递信息，就构成了程序。

　　面向对象的三大特征是：**封装、继承、多态**。

　　**封装**：将对象的属性私有化，同时提供一些可以访问属性的方法给外界。

　　**继承**：在现有类的基础上创建新的类，新类不但可以继承父类的属性和方法，还可以新增自己的属性和方法。通过继承可以实现代码复用。

　　**多态**：多态的表面意思是一个事务的多种形态，在Java中指的是一个变量所指向的对象类型在编译期并不确定，只有在运行期才会确定。Java中实现多态的方法有继承父类和实现接口。

* ### 介绍一下几种访问权限修饰符

　　访问权限从大到小依次是：

　　**public(公共权限)**：用来修饰外部类名、类的属性(包括方法)。当修饰类名时，表示这个类可以被所有类访问到；当修饰类的属性时，表示该属性可以在任何类中被访问到，可以被任何子类继承。

　　**protected(包内访问权限+包外继承权限)**：用来修饰类的属性(包括方法)。表示该属性可以在同一个包的类中被访问到、可以被任何包中的子类继承。

　　**缺省(包内访问权限+包内继承权限)**：用来修饰外部类名、类的属性(包括方法)。当修饰类名时，表示这个类只能被同一个包内的类访问到；当修饰类的属性时，表示该属性可以在同一个包的类中被访问到、可以被同一个包内的子类继承。

　　**private(本类访问权限)**：用来修饰类的属性(包括方法)。表示该属性只能在本类中访问到。

* ### 介绍一下this、super关键字

　　**this**：当`JVM`创建一个实例后，就会为该实例分配一个指向自己的引用，这个引用就是this，this只能在方法中使用。this的另一个作用是在一个构造方法中调用当前类的另一个构造方法，此时this语句应该位于构造方法中的第一行。

　　**super**：对于一个子类来说，它的实例中会持有一个父类的实例，super就是指向了父类实例的引用。super的另一个作用是在子类的构造方法中调用父类的构造方法，此时super语句应该位于构造方法中的第一行。当子类构造方法中没有显式地调用父类构造方法时，编译器会自动帮我们加上`super();`来调用父类的无参构造方法，如果父类没有无参构造方法，我们就必须显式地通过super调用父类的某个有参构造方法。

* ### 介绍一下final关键字

　　final关键字可以用来修饰类、方法、变量。

　　被final修饰的类不能被继承，被final修饰的方法不能被重写。被final修饰的变量，如果该变量是基本数据类型，那么初始化后它的值就不能再修改；如果该变量是引用类型，那么初始化后它的引用就不能再指向其它对象。

　　当final修饰成员变量时，不会为该变量分配默认值，必须在声明变量时赋值或在构造方法中为该变量赋值。

　　

　　**final、finally、finalize的区别**

　　1、final是关键字，用于修饰类、方法和变量；

　　2、finally是异常处理的一部分，finally语句块中的代码一定会被执行；

　　3、finalize是Object类中的一个方法，用于回收对象。

* ### 介绍一下static关键字

　　static可以用来修饰成员变量、成员方法、代码块、内部类。**它的作用是为属性创建与实例无关的存储空间，使得该属性与类关联，而不是与实例关联**。在不创建实例的情况下，可以直接通过`类名.静态属性名`的方式进行调用。静态方法中不能访问非静态属性，比如实例变量、实例方法、super、this关键字等，**原因是当类被`JVM`加载后，静态属性就被分配了空间，此时实例属性还未被分配空间，自然无法访问**。

* ### 成员变量和局部变量的区别是什么？

* ### 抽象类和接口的异同？

　　**抽象类的特点**：

　　1、除了可以定义抽象方法外，其它和普通类无异。抽象方法不能是private类型的。

　　**接口的特点**：

　　1、可以有成员变量和非抽象方法，但是成员变量一定是public static final类型的，非抽象方法一定是public default类型的，抽象方法一定是public abstract类型的。除了default关键字外，其它关键字都可以省略。

> **相同点**：
>
> 　　1、抽象类和接口都不能被实例化；
>
> 　　2、抽象类和接口中可以不定义抽象方法。
>
> 　　3、抽象类的子类和接口的实现类必须实现抽象方法。
>
> **不同点**：
>
> 　　1、抽象类体现的是is的关系，比如man is a person，此时person可以作为一个抽象类；而接口体现的是can的关系，比如plane和bird都能fly，此时fly可以作为一个接口，而plane和bird可以实现该接口；
>
> 　　2、一个类只可以继承一个抽象类，但是可以实现多个接口。

* ### 重载和重写的区别是什么？

　　**重载**：在一个类中，方法名相同、参数列表不同。

　　**重写**：子类和父类的方法名、参数列表相同。**重写方法的返回值类型要小于等于父类方法，访问权限要大于等于父类方法，抛出的异常范围要小于等于父类方法**。原因很简单：**为了保证向上转型能够通过编译**。

> 注意，静态方法不能被重写。

* ### 简述内部类及其作用

　　**非静态成员内部类**：可以把这种内部类看作是非静态的成员变量，它可以直接访问所在外部类的private属性，外部类也可以访问它的private属性。它的实例创建方式是：`外部类实例.new Inner()`。因为是非静态的，所以它不能定义静态属性，但是可以访问外部类的静态和非静态属性。

　　**静态成员内部类**：可以把这种内部类看作是静态的成员变量，它可以直接访问所在外部类的private static属性，外部类也可以访问它的private属性。它的实例创建方式是：`new 外部类类名.Inner()`。因为是静态的，所以它可以定义静态属性，但是不能访问外部类的非静态属性。

　　**局部内部类**：位于方法中的内部类，类似于局部变量，它没有访问权限修饰符。

　　**匿名内部类**：它的作用是实现接口，没有类名，只能使用一次。

* ### 创建实例时，代码的执行顺序是什么？

　　1、父类静态代码块、静态变量(静态代码块和静态变量按照声明顺序执行)；

　　2、子类静态代码块、静态变量；

　　3、父类局部代码块、成员变量(局部代码块和成员变量按照声明顺序执行)、父类构造方法；

　　4、子类局部代码块、成员变量、子类构造方法。

　　其中，静态代码块和静态变量只会在类加载的时候执行一次。

　　为了方便记忆，可以简称为**“父静子静、父动子动”**。

* ### 什么是浅拷贝和深拷贝？

　　**浅拷贝**：拷贝对象时，仅复制基本类型变量的值，对于引用类型变量，复制的是它们的引用。这导致两个对象的引用类型变量指向的是同一个地址。

　　**深拷贝**：拷贝对象时，对于引用类型变量，复制的不是引用，而是真正的对象。

* ### 创建Java对象有哪几种方式？

　　new关键字、反射、反序列化。前两种方式需要调用构造方法。
