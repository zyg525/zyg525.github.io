---
title: Java语言基础之加密与安全
categories: 三、Java语言基础
tags: Java语言基础
layout: post
---



## 编码算法

　　常见的编码有`ASCII`编码、`Unicode`编码、`UTF-8`编码等等，除此之外还有`URL`编码和`Base64`编码。

### URL编码

* #### 特点

　　URL编码是浏览器发送数据给服务器时使用的编码，它通常附加在URL的参数部分，例如：

```java
https://www.baidu.com/s?wd=%E4%B8%AD%E6%96%87
```

　　之所以需要URL编码，是因为出于兼容性考虑，很多服务器只识别ASCII字符。但如果URL中包含中文、日文这些非ASCII字符怎么办？不要紧，URL编码有一套规则：

　　1、如果字符是`A-Z`，`a-z`，`0-9`以及`-`、`_`、`.`、`*`，则保持不变；

　　2、如果是其他字符，先转换为`UTF-8`编码，然后对每个字节以`%XX`表示。

* #### 使用

　　Java标准库提供了`URLEncoder`类和`URLDecoder`类来对任意字符串进行URL编码、解码：

```java
// 编码，encode = %E4%BD%A0%E5%A5%BD
String encode = URLEncoder.encode("你好", "utf-8");
// 解码，decode = 你好
String decode = URLDecoder.decode(encode, "utf-8");
```

### Base64编码

* #### 特点

　　URL编码是对字符进行编码，表示成`%xx`的形式，而Base64编码是对二进制数据进行编码，表示成字符格式。它的原理是把3字节的二进制数据按6bit一组，用4个int整数表示，然后查表，把int整数用索引对应到字符，得到编码后的字符串。如果输入的`byte[]`数组长度不是3的整数倍，需要对输入的末尾补一个或两个`0x00`，编码后，在结尾加一个`=`表示补充了1个`0x00`，加两个`=`表示补充了2个`0x00`，解码的时候，去掉末尾补充的一个或两个`0x00`即可。

* #### 使用

　　Java标准库提供了`Base64`类来进行Base64编码、解码：

```java
byte[] bytes = "你好".getBytes("utf-8");
// 编码，encode = 5L2g5aW9
String encode = Base64.getEncoder().encodeToString(bytes);
// 解码，decode = {-28,-67,-96,-27,-91,-67}
byte[] decode = Base64.getDecoder().decode(encode);
```

## 哈希算法

### 特点

　　哈希算法（Hash）又称摘要算法（Digest），**哈希算法的特点是，相同的输入一定会得到相同的输出，不同的输入大概率会得到不同的输出**。如果不同的输入得到了相同的输出，我们称这种现象叫哈希碰撞。

　　一个好的哈希算法必须满足：

　　**1、哈希碰撞概论低；**

　　**2、无法从输出反推输入。**

### 使用

　　**常见的哈希算法有：`MD5、SHA-1、RipeMD-160、SHA-256、SHA-512`**，它们输出的二进制位数分别是：`128、160、160、256、512`，输出长度越长，哈希碰撞概率越低，哈希算法越安全。

　　Java标准库提供了常用的哈希算法，并且有一套统一的接口。我们以`MD5`算法为例，看看如何对输入计算哈希：

```java
// 1、获取MessageDigest实例
MessageDigest md5 = MessageDigest.getInstance("MD5");
// 2、输入数据
md5.update("123".getBytes(StandardCharsets.UTF_8));
md5.update("456".getBytes(StandardCharsets.UTF_8));
// 3、计算二进制形式的哈希值
byte[] bytes = md5.digest();
// 4、将二进制转换为16进制
String res = new BigInteger(1, bytes).toString(16);
```

　　在Java中使用`SHA-1、SHA-256、SHA-512`算法，和`MD5`完全一样，只需要修改一下构造方法中的参数即可。`MD5`算法因为输出长度较短，短时间内破解是可能的，目前已经不推荐使用。如果想使用`RipeMD-160`算法，需要引入一个第三方库`BouncyCastle`，这个库提供了很多哈希算法和加密算法。

### Hmac算法

　　使用哈希算法时，需要注意防止**彩虹表攻击**。如果只拿到MD5，从MD5反推明文口令，只能使用暴力穷举的方法。暴力穷举会消耗大量的算力和时间。但是，如果有一个预先计算好的常用口令和它们的MD5的对照表，这个表就是彩虹表。如果用户使用了常用口令，黑客从MD5一下就能反查到原始口令。这就是为什么不要使用常用密码，以及不要使用生日作为密码的原因。

　　即使用户使用了常用口令，我们也可以采取措施来抵御彩虹表攻击，方法是对每个口令额外添加随机数，这个方法称之为**加盐**（salt）。**`Hmac`算法是一种基于密钥的加盐算法，它总是和某种哈希算法配合起来使用**。例如，我们使用MD5算法，对应的就是HmacMD5算法，它相当于“加盐”的MD5：

```java
// 1、生成密钥
KeyGenerator keyGenerator = KeyGenerator.getInstance("HmacMD5");
SecretKey secretKey = keyGenerator.generateKey();
// 2、获取Mac实例
Mac hmacMD5 = Mac.getInstance("HmacMD5");
// 3、加盐
hmacMD5.init(secretKey);
// 4、输入数据
hmacMD5.update("123456".getBytes(StandardCharsets.UTF_8));
// 5、计算二进制形式的哈希值
byte[] bytes = hmacMD5.doFinal();
// 6、将二进制转换为16进制
String result = new BigInteger(1,bytes).toString(16);
```

## 对称加密算法

### 特点

　　**对称加密算法就是传统的用一个密码进行加密和解密**。例如，我们常用的WinZIP和WinRAR对压缩包的加密和解密，就是使用对称加密算法。在软件开发中，**常用的对称加密算法有：`DES、AES、IDEA`**，DES算法由于密钥过短，可以在短时间内被暴力破解，所以现在已经不安全了。

### 使用

　　`AES`算法是目前应用最广泛的加密算法。我们先用`ECB`模式加密并解密：

```java
// 密钥长度必须是16
byte[] secretKey = "1234567890abcdef".getBytes(StandardCharsets.UTF_8);
// 明文
byte[] plainText = "helloworld".getBytes(StandardCharsets.UTF_8);

// 加密
// 1、获取Cipher实例
Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
// 2、添加密钥
SecretKeySpec keySpec = new SecretKeySpec(secretKey, "AES");
// 3、选择加密模式
cipher.init(Cipher.ENCRYPT_MODE, keySpec);
// 4、根据明文计算密文
byte[] bytes1 = cipher.doFinal(plainText);
// 5、将密文转换为16进制
String res1 = new BigInteger(1, bytes1).toString(16);

// 解密
// 1、选择解密模式
cipher.init(Cipher.DECRYPT_MODE, keySpec);
// 2、根据密文计算明文
byte[] bytes2 = cipher.doFinal(bytes1);
// 3、将明文转换为字符
InputStreamReader reader = new InputStreamReader(new ByteArrayInputStream(bytes2));
char[] chars = new char[10];
reader.read(chars);
```

　　`ECB`模式是最简单的`AES`加密模式，它只需要一个固定长度的密钥，固定的明文会生成固定的密文，这种一对一的加密方式会导致安全性降低，更好的方式是通过`CBC`模式，它需要一个随机数作为IV参数，这样对于同一份明文，每次生成的密文都不同。

### DH算法

* #### 特点

　　对称加密算法的缺点是，当两个人需要通过网络加密通信时，密钥无法安全地传递，而一旦密钥泄漏，通信就不再安全。`DH`算法可以解决这个问题，通信双方各自在本地生成一对公钥私钥，然后将公钥发送给对方，私钥只有自己知道，在接收到对方发来的公钥后，用对方的公钥和自己的私钥计算出一个密钥，数学理论可以保证双方生成的密钥相同，然后就可以用这个密钥进行加密通信了。由于私钥保存在本地，因此即使公钥泄漏，也无法得到真正的密钥。

　　**`DH`算法实际上也是一种对称加密算法，只不过它的密钥要经过通信双方协商得到，因此`DH`算法也叫做密钥协商算法。**

　　`DH`算法的不足是，无法避免中间人攻击。中间人攻击在密码学和计算机安全领域中是指**攻击者与通讯的两端分别建立独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制**。

* #### 使用

　　在Java中使用DH算法：

```java
KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("DH");
keyPairGenerator.initialize(512);
// 通信甲方生成公钥publicKey1和私钥PrivateKey1，公钥要通过网络传递，所以要转换成二进制
KeyPair keyPair1 = keyPairGenerator.generateKeyPair();
byte[] publicKey1 = keyPair1.getPublic().getEncoded();
PrivateKey privateKey1 = keyPair1.getPrivate();
// 通信乙方生成公钥publicKey2和私钥PrivateKey2
KeyPair keyPair2 = keyPairGenerator.generateKeyPair();
byte[] publicKey2 = keyPair2.getPublic().getEncoded();
PrivateKey privateKey2 = keyPair2.getPrivate();

// 乙方用甲方的公钥publicKey1和自己的私钥privateKey2计算出密钥
X509EncodedKeySpec keySpec1 = new X509EncodedKeySpec(publicKey1);
KeyFactory keyFactory1 = KeyFactory.getInstance("DH");
PublicKey pubKey1 = keyFactory1.generatePublic(keySpec1);
KeyAgreement keyAgreement1 = KeyAgreement.getInstance("DH");
keyAgreement1.init(privateKey2);
keyAgreement1.doPhase(pubKey1, true);
byte[] secretKey1 = keyAgreement1.generateSecret();

// 甲方用乙方的公钥publicKey2和自己的私钥privateKey1计算出密钥
X509EncodedKeySpec keySpec2 = new X509EncodedKeySpec(publicKey2);
KeyFactory keyFactory2 = KeyFactory.getInstance("DH");
PublicKey pubKey2 = keyFactory2.generatePublic(keySpec2);
KeyAgreement keyAgreement2 = KeyAgreement.getInstance("DH");
keyAgreement2.init(privateKey1);
keyAgreement2.doPhase(pubKey2, true);
byte[] secretKey2 = keyAgreement2.generateSecret();

// 甲方计算出的密钥和乙方计算出的密钥相同
String s1 = Arrays.toString(secretKey1);
String s2 = Arrays.toString(secretKey2);
System.out.println(s1.equals(s2)); // true
```

## 非对称加密算法

### 特点

　　非对称加密的特点是加密、解密使用的是不同的密钥，和`DH`算法一样，在加密通信时，通信双方持有对方的公钥，私钥保存在本地，传输数据时，用对方的公钥加密，对方接收数据后用自己的私钥解密。

　　非对称加密算法相对于`DH`算法的优势是，在N个人之间进行加密通信时，`DH`算法要求任意两个人都有独一无二的一对公钥私钥，密钥对总数是`N*(N-1)/2`，而非对称加密算法只要求每个人持有自己的一对公钥私钥，密钥对总数是`N`。**因此非对称加密算法的密钥管理简单，而且不容易泄漏。**

　　**非对称加密的缺点就是运算速度非常慢**，比对称加密要慢很多。所以，在实际应用的时候，非对称加密总是和对称加密一起使用，比如加密“AES口令”。**这也是我们在浏览器中常用的HTTPS协议的做法，即浏览器和服务器先通过RSA交换AES口令，接下来双方通信实际上采用的是速度较快的AES对称加密，而不是缓慢的RSA非对称加密。**

　　非对称加密算法也无法防止中间人攻击。

### 使用

　　非对称加密的典型算法就是`RSA`算法，Java标准库提供了`RSA`算法的实现，示例代码如下：

```java
byte[] plainText = "helloworld".getBytes(StandardCharsets.UTF_8);

// 生成一对公钥私钥
KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
keyPairGenerator.initialize(1024);
KeyPair keyPair = keyPairGenerator.generateKeyPair();
PublicKey publicKey = keyPair.getPublic();
PrivateKey privateKey = keyPair.getPrivate();

// 用公钥加密
Cipher cipher = Cipher.getInstance("RSA");
cipher.init(Cipher.ENCRYPT_MODE, publicKey);
byte[] res = cipher.doFinal(plainText);

// 用私钥解密
cipher.init(Cipher.DECRYPT_MODE, privateKey);
byte[] bytes = cipher.doFinal(res);
InputStreamReader reader = new InputStreamReader(new ByteArrayInputStream(bytes));
char[] chars = new char[10];
reader.read(chars);
```

### 签名算法

* #### 特点

　　签名算法的特点是用私钥加密、公钥解密。私钥加密得到的密文实际上就是数字签名，要验证这个签名是否正确，只能用私钥持有者的公钥进行解密验证。**使用数字签名的目的是为了确认某个信息确实是由某个发送方发送的，任何人都不可能伪造消息，并且，发送方也不能抵赖。因为用户总是使用自己的私钥进行签名，所以，私钥就相当于用户身份。而公钥用来给外部验证用户身份。**

　　在实际应用的时候，签名实际上并不是针对原始消息，而是针对原始消息的哈希进行签名，**因此签名算法还可以保证数据的完整性。**常用数字签名算法有：`MD5withRSA、SHA1withRSA、SHA256withRSA`，它们实际上就是指定某种哈希算法进行RSA签名的方式。

* #### 使用

　　使用`SHA1withRSA`签名算法进行签名、验证：

```java
byte[] hashCode = "helloworld".getBytes(StandardCharsets.UTF_8);

// 生成一对公钥私钥
KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
keyPairGenerator.initialize(1024);
KeyPair keyPair = keyPairGenerator.generateKeyPair();
PublicKey publicKey = keyPair.getPublic();
PrivateKey privateKey = keyPair.getPrivate();

// 用私钥加密，生成签名
Signature signature = Signature.getInstance("SHA1withRSA");
signature.initSign(privateKey);
signature.update(hashCode);
byte[] sign = signature.sign();

// 用公钥解密签名，然后和哈希码作对比，如果相同说明签名正确，并且文件完整
signature.initVerify(publicKey);
signature.update(hashCode);
boolean verify = signature.verify(sign); // true
```

## <font color='red'>数字证书</font>

　　我们知道，摘要算法用来确保数据没有被篡改，非对称加密算法可以对数据进行加解密，签名算法可以确保数据完整性和抗否认性，把这些算法集合到一起，并搞一套完善的标准，这就是数字证书。因此，**数字证书就是集合了多种密码学算法，用于实现数据加解密、身份认证、签名等多种功能的一种安全标准**。

　　**数字证书可以防止中间人攻击，因为它采用链式签名认证**，即通过根证书（Root CA）去签名下一级证书，这样层层签名，直到最终的用户证书。而Root CA证书内置于操作系统中，所以，任何经过CA认证的数字证书都可以对其本身进行校验，确保证书本身不是伪造的。我们在上网时常用的HTTPS协议就是数字证书的应用。浏览器会自动验证证书的有效性。

　　以HTTPS协议为例，浏览器和服务器建立安全连接的步骤如下：

　　1、浏览器向服务器发起请求，服务器向浏览器发送自己的数字证书；

　　2、浏览器用操作系统内置的Root CA来验证服务器的证书是否有效，如果有效，就使用该证书加密一个随机的AES口令并发送给服务器；

　　3、服务器用自己的私钥解密获得AES口令，并在后续通讯中使用AES加密。

　　上述流程只是一种最常见的单向验证。如果服务器还要验证客户端，那么客户端也需要把自己的证书发送给服务器验证，这种场景常见于网银等。