---
title: 数据库之JDBC
categories: 七、数据库
tags: 数据库
layout: post
---



## 一、概述

　　JDBC是`Java DataBase Connectivity`的缩写，它是Java程序访问数据库的标准接口。使用Java程序访问数据库时，Java代码并不是直接通过TCP连接去访问数据库，而是通过JDBC接口来访问，而JDBC接口则通过JDBC驱动来实现真正对数据库的访问。JDBC接口是Java标准库自带的，所以可以直接编译。而具体的JDBC驱动是由数据库厂商提供的，例如，MySQL的JDBC驱动由Oracle提供。

　　因此，访问某个具体的数据库，我们只需要引入该厂商提供的JDBC驱动，就可以通过JDBC接口来访问，这样保证了Java程序编写的是一套数据库访问代码，却可以访问各种不同的数据库。从代码来看，Java标准库自带的JDBC接口其实就是定义了一组接口，而某个具体的JDBC驱动其实就是实现了这些接口的类。

　　实际上，一个MySQL的JDBC的驱动就是一个jar包，它本身也是纯Java编写的。我们自己编写的代码只需要引用Java标准库提供的java.sql包下面的相关接口，由此再间接地通过MySQL驱动的jar包通过网络访问MySQL服务器，所有复杂的网络通讯都被封装到JDBC驱动中，因此，Java程序本身只需要引入一个MySQL驱动的jar包就可以正常访问MySQL服务器。

## 二、JDBC查询

### 简单查询

　　使用JDBC前要先添加数据库驱动的依赖，这是MySQL数据库的驱动依赖：

```xml
<!-- JDK8 -->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>5.1.49</version>
    <!-- runtime表示只在运行期会引入依赖，编译期不引入，目的是为了避免和JDK的类名混淆 -->
    <scope>runtime</scope>
</dependency>
```

　　一个简单的JDBC查询：

```java
public static void main(String[] args) throws SQLException {
    String url = "jdbc:mysql://192.168.220.128:3306/test?useSSL=false&characterEncoding=utf8&serverTimezone=Asia/Shanghai";
    String username = "root";
    String password = "123456";

    // Connection、Statement、ResultSet在用完后都要关闭，以节省资源
    try(Connection connection = DriverManager.getConnection(url, username, password);
        Statement statement = connection.createStatement();
        ResultSet resultSet = statement.executeQuery("SELECT id, name, age FROM t_student WHERE id = 10")) {

        while (resultSet.next()) {
            int id = resultSet.getInt(1);
            String name = resultSet.getString(2);
            int age = resultSet.getInt(3);

            System.out.println("id="+id+" name="+name+" age="+age);
        }
    }
}
```

### SQL注入

　　使用`Statement`执行SQL时，SQL参数是通过字符串拼接的方式传进SQL语句的，这会导致SQL注入的安全问题。比如：

```java
// 本意是要查询id=10的数据，结果查出来了所有数据
String id = "10 or 1=1";
String sql = "SELECT id, name, age FROM t_student WHERE id = " + id;
```

　　使用`PreparedStatement`代替`Statement`可以防止SQL注入攻击。当然，写法也会有变化：

```java
public static void main(String[] args) throws SQLException {
    String url = "jdbc:mysql://192.168.220.128:3306/test?useSSL=false&characterEncoding=utf8&serverTimezone=Asia/Shanghai";
    String username = "root";
    String password = "123456";
    
    try(Connection connection = DriverManager.getConnection(url, username, password);
        // 使用占位符传入参数
        PreparedStatement preparedStatement = connection.prepareStatement("SELECT id, name, age FROM t_student WHERE id = ?")) {

        preparedStatement.setObject(1, 10);
        ResultSet resultSet = preparedStatement.executeQuery();
        
        while (resultSet.next()) {
            int id = resultSet.getInt(1);
            String name = resultSet.getString(2);
            int age = resultSet.getInt(3);

            System.out.println("id="+id+" name="+name+" age="+age);
        }
    }
}
```

## 三、JDBC修改

　　JDBC插入、更新、删除的写法一模一样。

### 插入

　　一个简单的JDBC插入：

```java
public static void main(String[] args) throws SQLException {
    String url = "jdbc:mysql://192.168.220.128:3306/test?useSSL=false&characterEncoding=utf8&serverTimezone=Asia/Shanghai";
    String username = "root";
    String password = "123456";
    
    try(Connection connection = DriverManager.getConnection(url, username, password);
        PreparedStatement preparedStatement = connection.prepareStatement("INSERT INTO t_student (name, age) VALUES (?, ?)")) {

        preparedStatement.setObject(1, "王五");
        preparedStatement.setObject(2, 20);
        // 返回插入的条数
        int n = preparedStatement.executeUpdate();

        System.out.println(n);
    }
}
```

### 更新

　　一个简单的JDBC更新：

```java
public static void main(String[] args) throws SQLException {
    String url = "jdbc:mysql://192.168.220.128:3306/test?useSSL=false&characterEncoding=utf8&serverTimezone=Asia/Shanghai";
    String username = "root";
    String password = "123456";
    
    try(Connection connection = DriverManager.getConnection(url, username, password);
        PreparedStatement preparedStatement = connection.prepareStatement("UPDATE t_student SET age = ? WHERE id = 10")) {

        preparedStatement.setObject(1, 22);
        // 返回更新的条数
        int n = preparedStatement.executeUpdate();

        System.out.println(n);
    }
}
```

### 删除

　　一个简单的JDBC删除：

```java
public static void main(String[] args) throws SQLException {
    String url = "jdbc:mysql://192.168.220.128:3306/test?useSSL=false&characterEncoding=utf8&serverTimezone=Asia/Shanghai";
    String username = "root";
    String password = "123456";
    
    try(Connection connection = DriverManager.getConnection(url, username, password);
        PreparedStatement preparedStatement = connection.prepareStatement("DELETE FROM t_student WHERE id >= ? AND id <= ?")) {

        preparedStatement.setObject(1, 3);
        preparedStatement.setObject(2, 9);
        // 返回删除的条数
        int n = preparedStatement.executeUpdate();

        System.out.println(n);
    }
}
```

## 四、JDBC事务

　　JDBC实现事务的原理是：**在事务开始时关闭数据库事务的自动提交，当事务完成后手动提交，如果事务执行过程中发生异常，就在异常处理中对数据库事务进行回滚。**

　　一个简单的JDBC事务如下：

```java
Connection connection = DriverManager.getConnection(url, username, password);
// 设置数据库事务的隔离级别
connection.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
try {
    // 1、关闭数据库事务的自动提交
    connection.setAutoCommit(false);
    insert(connection);
    int a = 1/0;
    insert(connection);
    // 2、事务执行完成后手动提交事务
    connection.commit();
}catch (Exception e) {
    // 3、事务执行过程中发生异常后回滚事务
    connection.rollback();
}finally {
    connection.setAutoCommit(true);
    connection.close();
}
```

　　还可以为JDBC事务设置回滚点，在回滚点之前执行的操作会被提交：

```java
Connection connection = DriverManager.getConnection(url, username, password);
connection.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
Savepoint savepoint = null;
try {
    connection.setAutoCommit(false);
    insert(connection);
    // 设置回滚点
    savepoint = connection.setSavepoint();
    int a = 1/0;
    insert(connection);
    connection.commit();
}catch (Exception e) {
    connection.rollback(savepoint);
}finally {
    connection.setAutoCommit(true);
    connection.close();
}
```

## 五、JDBC连接池

　　在执行JDBC的增删改查的操作时，如果每一次操作都来一次打开连接，操作，关闭连接，那么创建和销毁JDBC连接的开销就太大了。为了避免频繁地创建和销毁JDBC连接，我们可以通过连接池（Connection Pool）复用已经创建好的连接。

　　JDBC连接池有一个标准的接口javax.sql.DataSource，注意**这个类位于Java标准库中，但仅仅是接口。要使用JDBC连接池，我们必须选择一个JDBC连接池的实现**。常用的JDBC连接池有`HikariCP`、`C3P0`、`BoneCP`、`Druid`等。

　　以`HikariCP`为例，创建JDBC连接池之前要先添加连接池依赖：

```xml
<dependency>
    <groupId>com.zaxxer</groupId>
    <artifactId>HikariCP</artifactId>
    <version>2.7.1</version>
</dependency>
```

　　然后从JDBC连接池中获取`Connection`对象即可：

```java
HikariConfig hikariConfig = new HikariConfig();
hikariConfig.setJdbcUrl(url);
hikariConfig.setUsername(username);
hikariConfig.setPassword(password);
HikariDataSource dataSource = new HikariDataSource(hikariConfig);

try(Connection connection = dataSource.getConnection()) {
    ...
}
```

　　注意**创建DataSource也是一个非常昂贵的操作，所以通常DataSource实例总是作为一个全局变量存储，并贯穿整个应用程序的生命周期**。连接池内部维护了若干个Connection实例，如果调用`getConnection()`，就选择一个空闲连接，并标记它为“正在使用”然后返回，如果对Connection调用`close()`，那么就把连接再次标记为“空闲”从而等待下次调用。这样一来，我们就通过连接池维护了少量连接，但可以频繁地执行大量的SQL语句。